# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N, M;
vector<int> parents(100001, 0), armys(100001, 0);

int find_root(int x)
{
    if (parents[x] == x) return x;
    return parents[x] = find_root(parents[x]);
}


void union_root(int x, int y, int command)
{
    int r_x = find_root(x);
    int r_y = find_root(y);
    
    if (r_x == -1 || r_y == -1 || r_x == r_y) return;
    if (r_x > r_y) swap(r_x, r_y);
    
    if (command == 1) {
        parents[r_y] = r_x;
        armys[r_x] += armys[r_y];
        armys[r_y] = 0;
    }
    else {
        if (armys[r_x] > armys[r_y]) {
            parents[r_y] = r_x;
            armys[r_x] -= armys[r_y];
            armys[r_y] = 0;
        }
        else if (armys[r_x] < armys[r_y]) {
            parents[r_x] = r_y;
            armys[r_y] -= armys[r_x];
            armys[r_x] = 0;
        }
        else {
            parents[r_x] = -1;
            parents[r_y] = -1;
            armys[r_x] = 0;
            armys[r_y] = 0;
        }
    }
    
    return;
}


void get_result()
{
    int cnt = 0;
    for (int i=1; i<=N; ++i) {
        if (parents[i] == i) cnt++;
    }
    cout << cnt << "\n";
    sort(armys.begin(), armys.end(), less<int>());
    
    for (int a : armys) {
        if (a > 0) {
            cout << a << " ";
        }
    }
    
    return;
}


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    for (int i=1; i<=N; ++i) {
        cin >> armys[i];
    }
    
    for (int i=1; i<=N; ++i) {
        parents[i] = i;
    }
    
    int command, s, e;
    for (int i=0; i<M; ++i) {
        cin >> command >> s >> e;
        union_root(s, e, command);
    }
    
    get_result();

    return 0;
}

```

> ## 문제
>
> 전국시대엔 N개의 국가가 존재한다. 각 국가는 1부터 N까지의 번호를 가지고 있다.
>
> 또한, 모든 국가는 각자 자신의 국가의 힘을 상징하는 병력을 가지고 있다. 이때 M개의 기록이 주어진다. 각각의 기록은 다음과 같다.
>
> 1. 동맹 - 두 나라가 서로 동맹을 맺는다. 두 나라의 병력이 하나로 합쳐진다.
> 2. 전쟁 - 두 나라가 서로 전쟁을 벌인다. 병력이 더 많은 나라가 승리하며 패배한 나라는 속국이 된다. 이때 남은 병력은 승리한 나라의 병력에서 패배한 나라의 병력을 뺀 수치가 된다. 두 나라의 병력이 같을 경우 두 나라 모두 멸망한다.
>
> 모든 나라는 정직하기 때문에 내 동맹의 동맹도 나의 동맹이고, 내 동맹이 적과 전쟁을 시작하면 같이 참전한다. 속국인 경우도 동맹의 경우와 마찬가지이다.
>
> 따라서, 전쟁에서 진 국가와 동맹인 다른 국가 또한 전쟁에서 이긴 국가의 속국이 된다.
>
> 모든 기록이 끝났을 때 남아있는 국가의 수를 출력하고, 그 국가들의 남은 병력의 수를 오름차순으로 출력하는 프로그램을 작성하시오.
>
> 단, 여러 국가가 서로 동맹이거나 속국 관계인 경우는 한 국가로 취급한다.
>
> ## 입력
>
> 첫 번째 줄에 국가의 수를 나타내는 N과 기록의 수 M이 주어진다. (1 ≤ N, M ≤ 100,000)
>
> 두 번째 줄 부터 N개의 줄에 걸쳐 i번째 국가의 병력 Ai (1 ≤ i ≤ N)가 자연수로 주어진다. (1 ≤ Ai ≤ 10,000)
>
> 다음 M개의 줄에는 기록이 3개의 정수 O, P, Q로 주어진다. O가 1인 경우 P, Q가 서로 동맹을 맺었음을 의미하고, O가 2인 경우 P, Q가 서로 전쟁을 벌였음을 의미한다.
>
> 동맹끼리 다시 동맹을 맺거나 전쟁하는 입력은 주어지지 않는다.
>
> ## 출력
>
> 첫째 줄에 남아있는 국가의 수를 출력한다.
>
> 다음 줄에 각 국가의 남은 병력의 수를 띄어쓰기를 간격으로 오름차순으로 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을 때 유니온 파인드를 떠올렸다. 동맹국가들은 하나의 root를 공유하고, 해당 root가 동맹 국가의 모든 병력을 가지고 전쟁 및 동맹을 맺으면 관리가 용이할 것이라고 생각했다.
>
> > 1. 각 국가의 root를 기록할 배열 parents와 각 국가가 가지는 병력을 기록할 배열 armys를 선언한다.
> >
> > 2. 주어지는 국가들의 병력을 armys에 국가 번호를 인덱스 값으로 하여 기록한다.
> >
> > 3. 주어지는 M개의 전쟁 현황을 union_root 함수를 통해 반영한다.
> >
> >    - 우선적으로 이미 root가 같거나 이미 멸망한 나라가 인자로 들어온다면 탈출한다.
> >
> >    - 만약 주어지는 상황이 동맹이라면 주어진 2개의 국가의 root 중 가장 번호가 낮은 국가를 기준으로 두 나라를 통합한다. 이 때 기준이 되는 나라의 병력에 속국이 되는 나라의 병력을 더하고 속국이 되는 나라의 병력을 0으로 한다 (추후 병력을 출력할때 용이하기 위함)
> >    - 만약 주어지는 상황이 전쟁이라면 주어진 2개의 국가의 root 중 더 병력이 많은 나라를 기준으로 두 나라를 통합한다. 이 때 기준이 되는 나라의 병력에 속국이 되는 나라의 병력을 빼고 속국이 되는 나라의 병력을 0으로 한다.
> >      - 만약 두 나라의 병력이 같다면 두 나라의 병력을 모두 0으로 하고 root를 -1로 바꾸어 두 나라 모두 멸망했음을 체크한다.
> >
> > 4. 3번이 모두 끝나면 1~N번의 나라를 모두 순회하여 해당 나라의 root 값이 나라의 번호와 같은 경우 살아남은 하나의 나라로 인식하여 개수를 더한다. 이 후 모든 나라를 순회하면 나라의 개수를 출력한다.
> >
> > 5. armys를 오름차순으로 정렬하여 0이 아닌(이미 속국이 되었거나 멸망한 나라가 아닌) 나라의 병력들을 정렬한 순서대로 출력한다.
>
> 위와 같은 방식으로 문제를 풀었다! 오오... 오랜만에 빠르게 알고리즘을 찾아내고 한번에 문제를 풀었다... 이번에는 실수 하지 않게 제출 전에 문제를 확실히 확인하고 변수를 제거하기 위한 알고리즘도 넣으려고 노력했는데... 좋은 결과가 돌아와서 상당히 좋다! 다음에도 이런식으로 차분하게 잘 정리하면서 풀어보자!!
