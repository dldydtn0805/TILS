# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, num;
int result = 0;
vector<int> lines;
vector<int> LIS;

int binary_check(int x)
{
    int start = 0;
    int end = LIS.size() - 1;
    
    while (start <= end) {
        int mid = (start + end) / 2;
        
        if (LIS[mid] <= x) {
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    
    return start;
}

void make_sort()
{
    LIS.push_back(lines[0]);
    
    for (int i=1; i<N; ++i) {
        int idx = binary_check(lines[i]);
        
        if (idx > LIS.size() - 1) {
            LIS.push_back(lines[i]);
        }
        else {
            LIS[idx] = lines[i];
        }
    }
    
    cout << N - LIS.size();
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N;
    
    for (int i=0; i<N; ++i) {
        cin >> num;
        lines.push_back(num);
    }
    
    make_sort();

    return 0;
}

```



# 해설

> ## 문제
>
> KOI 어린이집에는 N명의 아이들이 있다. 오늘은 소풍을 가는 날이다. 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌었다. 그래서 선생님은 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 그리고 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다.
>
> 예를 들어, 7명의 아이들이 다음과 같은 순서대로 줄을 서 있다고 하자.
>
> 3 7 5 2 6 1 4
>
> 아이들을 순서대로 줄을 세우기 위해, 먼저 4번 아이를 7번 아이의 뒤로 옮겨보자. 그러면 다음과 같은 순서가 된다.
>
> 3 7 4 5 2 6 1
>
> 이제, 7번 아이를 맨 뒤로 옮긴다.
>
> 3 4 5 2 6 1 7
>
> 다음 1번 아이를 맨 앞으로 옮긴다.
>
> 1 3 4 5 2 6 7
>
> 마지막으로 2번 아이를 1번 아이의 뒤로 옮기면 번호 순서대로 배치된다.
>
> 1 2 3 4 5 6 7
>
> 위의 방법으로 모두 4명의 아이를 옮겨 번호 순서대로 줄을 세운다. 위의 예에서 3명의 아이만을 옮겨서는 순서대로 배치할 수가 없다. 따라서, 4명을 옮기는 것이 가장 적은 수의 아이를 옮기는 것이다.
>
> N명의 아이들이 임의의 순서로 줄을 서 있을 때, 번호 순서대로 배치하기 위해 옮겨지는 아이의 최소 수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에는 아이들의 수 N이 주어진다. 둘째 줄부터는 1부터 N까지의 숫자가 한 줄에 하나씩 주어진다. N은 2 이상 200 이하의 정수이다.
>
> ## 해설
>
> 처음 문제를 봤을 때 그리디 문제 같았다. 그래서 처음에는 자신이 가야할 위치에서 가장 멀리 떨어져있는 수들을 우선적으로 옮겨주었다. 그러니 수를 옮길때 다른 수들이 이동하여 발생하는 자동적인 정렬이 유리한 방향으로 계산하지 못해서 불가능했다...
>
> 이외에도 가운데를 기준으로 움직이기 이런 식으로 해보았으나 잘 안되었다..
>
> 하도 고민해도 답이 안나와서 알고리즘 분류를 봤는데 DP가 나왔다.. 나오자마자 잉? 소리가 절로 나왔다.. 어떤 값을 기준으로 계산 후 저장하여 이용할지 감도 안잡혔기 때문이다.. 1차원 DP를 이용해 이동 횟수에 따른 최적의 줄 세우기 상태를 작성하자니 뭐가 최적인지 알수가 없었고 다차원 DP를 이용해 모든 경우의 수를 보기에는... 최대 200자리라서 불가능해보였다... 계속해서 고민해도 답이 안나와서.. 결국 블로그를 보고 힌트를 얻었다.
>
> 블로그에서는 `가장 긴 증가하는 부분 수열(LIS)`를 이용하면 된다고 하였다.. `LIS`로 이루어진 값들은 그 사이에 끼어있는 LIS가 아닌 값들이 정렬을 하기 위해 움직인다면, 결국 LIS가 이루어진 값들은 저절로 정렬이 되기 때문에 굳이 움직일 필요가 없는 것이다.
>
> ```
> 5 4 3 2 1
> ```
>
> 위의 예제의 LIS의 길이는 1이다. 따라서 4개의 숫자를 이동시켜야 정확히 줄 세울 수 있다.
>
> ```
> 3 7 5 2 6 1 4
> // LIS = 3 5 6
> ```
>
> 위의 예제의 LIS의 길이는 3이다. 따라서 7 2 1 4만 움직이면 나머지 LIS는 알아서 정렬이 되는 것이다.
>
> LIS의 길이만 알면 되기 때문에 저번 문제에서 배웠던 `nlogn 의 LIS 알고리즘`을 이용하기로 했다. vector를 하나 선언하여 현재 LIS 현황을 담고 
>
> 주어진 값들을 순회하며 해당 vector에 대해 주어진 값을 기준으로 LIS vector에 이분탐색을 시작해 주어진 값의 위치를 찾는다. 만약 LIS안의 모든 값보다 값이 크다면 LIS 맨뒤에 추가하여 길이를 늘린다. 위의 방식으로 LIS 길이를 구하여 `N - LIS의 길이`를 하면 답을 구할 수 있었다.
>
> 아에 생각지도 못한 알고리즘이 나와서 깜짝 놀랐다.... 아이디어를 이용한 문제라고 생각해서 생각해내지 못한게 너무 아쉬웠다.. 다양한 문제를 접해서 생각을 트여보는게 중요할 것 같다...
