# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// ccw알고리즘을 이용해 2개의 점(즉, 선분) 에 대해 1개의 점에 대한 외적이 어느 방향에 있는지 구분한다.
// 만약 결과값이 음수라면 시계방향, 양수라면, 반시계방향, 0이라면 평행이다.
int CCW(long long x1, long long y1, long long x2, long long y2, long long tx, long long ty)
{
    long long target = (x2 - x1) * (ty - y1) - (tx - x1) * (y2 - y1);
    
    if (target > 0) return 1;
    else if (target < 0) return -1;
    else return 0;
}

int main()
{
    long long x1, y1, x2, y2, x3, y3, x4, y4;
    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;

    // 한 선분에 대해, 다른 선분을 구성하는 점 2개에 대한 외적의 방향을 확인한다. 
    int base_one = CCW(x1, y1, x2, y2, x3, y3);
    int base_two = CCW(x1, y1, x2, y2, x4, y4);
    int base_three = CCW(x3, y3, x4, y4, x1, y1);
    int base_four = CCW(x3, y3, x4, y4, x2, y2);
    
    // 만약 두 점에 대한 외적의 방향이 서로 다르다면 (두 결과값의 곱이 음수라면 -와 + 가 곱해진것으로 다른 방향이다.)
    // 교차하고 있다는 뜻이다.
    // 하지만 2개의 방향이 서로 다르다고 하더라도 반드시 교차하는 것은 아니다. 만약 해당 선분이 교차하는 듯이 구성되어있어도
    // 자신의 선분의 안에 들어와 있지 않다면 교차하지 않는 것이다 이를 확인하기 위해 비교 대상이었던 선분을 기준으로 잡아
    // 다시 서로 교차하는지 비교한다. 만약 두 선분이 만나지 않는다면 두 조건문 중 한 개의 조건문에서는 비교 대상인 두 점에 대한 외적이 같은 방향으로 나온다.
    if (base_one * base_two <= 0 && base_three * base_four <= 0) {
        
        // 만약에 두 조건문 모두 0의 값을 갖는다면 완벽히 평행하고 있다는 뜻이다 하지만 이는 반드시 교차한다는 뜻은 아니다.
        // 두 개의 선분이 같은 선상에 존재할 뿐 두 선분이 떨어져 있을 수도 있다. 이때는 좌표값을 이용해 두 선분이 겹쳐져 있는지 확인하여
        // 교차 여부를 판단해야 한다.
        if (base_one * base_two == 0 && base_three * base_four == 0) {
            // 비교하기 쉽게 좌표를 정렬한다.
            // 대각선으로 일직선일때도 판단해야하기 때문에 pair를 이용하여 손쉽게 판단한다.
            pair<long long, long long> one = {x1, y1};
            pair<long long, long long> two = {x2, y2};
            pair<long long, long long> three = {x3, y3};
            pair<long long, long long> four = {x4, y4};
            
            if (one > two) {
                swap(one, two);
            }
            if (three > four) {
                swap(three, four);
            }
            
            // 만약 일직선 상의 두 선분이 겹친다면 1을 반환
            if (three <= two && one <= four) {
                cout << 1;
            }
            else {
                cout << 0;
            }
        }
        // 만약 둘 다 0이 아니라면 잘 교차하고 있으므로 1을 반환
        else {
            cout << 1;
        }
    }
    else {
        cout << 0;
    }

    return 0;
}

```



# 해설

> ## 문제
>
> N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.
>
> 각각의 벽에 대해서 다음을 구해보려고 한다.
>
> - 벽을 부수고 이동할 수 있는 곳으로 변경한다.
> - 그 위치에서 이동할 수 있는 칸의 개수를 세어본다.
>
> 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.
>
> ## 입력
>
> 첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.
>
> ## 해설
>
> 새로보는 ccw 알고리즘을 이용해 풀었다 이를 알아보자
>
> ccw 알고리즘은 두 벡터를 외적했을 때 두 벡터의 수직 벡터가 나오는 점을 이용한 알고리즘이다.
>
> 이는 오른손 법칙을 이용하는 것이다. 오른손으로 해당하는 방향으로 쥐었을 때의 엄지 방향이 그 수직 벡터가 되는 것인데 이는
>
> 벡터 u와 벡터 v에 대한 수직 벡터가 (u * v)가 되는것을 나타낸다. 만약 벡터 v와 벡터 u에 대한 수직 벡터는 (v * u)가 되며 이는 (u * v)와 정 반대의 벡터를 뜻한다.
>
> 공식은 다음과 같다.
>
> ```
> S = (x₂ - x)(y₃ - y₁) - (x₃ - x₁)(y₂ + y₁)
> ```
>
> 현재 문제에서는 2차원이기 때문에 Z값에는 0을 넣고 공식을 수행한 것이다.
>
> 여기서 S 값이 `양수`이면 `반시계 방향 벡터`, `음수`이면 `시계 방향 벡터`, `0`이면 `일직선상` 임을 뜻한다.
>
> 이 특징을 봤을때 어떤 선분을 이루는 두 점에 대해서 다른 선분의 각각의 점의 외적을 확인 했을때 방향이 서로 다르다면 교차한다고 볼 수 있다.
>
> 따라서 기준이 되는 선분의 2개의 점과 비교 대상인 선분의 두 개의 점을 각각 1개씩 cws알고리즘을 이용해 S 값을 구하고 해당 S끼리의 곱이 음수라면 교차하는 것이다.
>
> 그런데 기준이 되는 선분에 대해 두 개의 점이 각각 방향이 달라도 반드시 교차하는 것은 아니다.
>
> 선분이 서로 떨어져 있어도 서로 방향이 다를 수 있기 때문이다. 그렇다면 이럴때는 기준과 비교대상 선분을 서로 맞바꾸어 다시 한번 S 값을 구하는 것이다.
>
> 만약 서로 선분이 떨어져 있다면 선분끼리 맞바꾸어 S₁ * S₂값을 구했을때 2개의 경우중 한 곳은 반드시 양수가 나타날 것이다. 이말은 즉, 번갈아서 S₁ * S₂ 값을 구했을 때 두 번 다 음수가 나온다면 교차한다는 얘기다.
>
> 하지만 만약 두 S₁ * S₂의 값이 모두 0, 0이 나온다면 이는 두 선분이 일직선상에 존재한다는 얘기다 하지만 일직선상에 있다하더라도 교차하는지 교차하지 않는지는 판단할 수 없다. 따라서 이 경우에는 주어진 좌표 값을 이용해 교차되는지 확인한다.
>
> ```c++
> pair<long long, long long> one = {x1, y1};
> pair<long long, long long> two = {x2, y2};
> pair<long long, long long> three = {x3, y3};
> pair<long long, long long> four = {x4, y4};
> 
> if (one > two) swap(one, two);
> if (three > four) swap(three, four);
> 
> // 만약 일직선 상의 두 선분이 겹친다면 1을 반환
> if (three <= two && one <= four) cout << 1;
> else cout << 0;
> ```
>
> - 각각 one, two는 선분A를 이루는 점들이고  ,three, four는 선분 B를 이루는 점들일 때, 먼저 선분 A안의 두 점 one, two 중 one이 더 낮은 값을 가지게 조정하고 선분 B도 three가 four보다 더 낮은 값을 갖게 조정해준다.
> - 위의 조건을 만족한다면 선분 B의 시작점이 선분 A의 끝점 안에 들어가고 선분 A의 시작점이 선분 B의 끝점보다 크거나 같다면 선분 A와 선분 B가 겹치는부분이 있다는 것이므로 이는 교차함을 뜻한다.
>
> 위와 같은 조건을 이용해서 두 선분의 교차여부를 판단할 수 있었고 이를 통해 결괏 값을 출력하였다.
>
> 문제를 풀다가 분명 로직이 맞는것 같은데 계속해서 틀려서 정말 애먹었다. 그 이유는 바로 또 자료형 선언 때문이었다.
>
> 주어지는 좌표의 절댓값의 최대가 100만이고, 이를 CCW를 구하는 도중에 100만^2은 int의 범위를 초과할 수 있으므로 int 내에서의 연산에 오버플로우가 생겨 문제가 생겼다. 그래서 좌표값을 받을 때도 long long으로 선언했어야 했다 ㅠㅠ
>
> 요즘 자주 자료형 때문에 문제도 많이 발생하고 코드가 조건문이 너무 많은 것 같은데... 자료형을 잘 분석하고 정하고, 코드도 깔끔하게 적을 수 있게 노력해야겠다..

