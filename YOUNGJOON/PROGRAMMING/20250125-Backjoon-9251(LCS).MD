# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

string one, two;

int result = 0;

void lcs()
{
    int N = one.size();
    int M = two.size();
    vector<vector<int> > dp(N+1, vector<int>(M+1, 0));
    
    for (int i=1; i<=N; ++i) {
        for (int j=1; j<=M; ++j) {
            if (one[i-1] == two[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                if (result < dp[i][j]) {
                    result = dp[i][j];
                }
            }
            else {
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        }
    }
    
    cout << result;
    
    return;
    
}

int main()
{
    cin >> one >> two;
    
    lcs();

    return 0;
}

```



> ## 문제
>
> LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.
>
> 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.
>
> ## 입력
>
> 첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.
>
> ## 해설
>
> 처음 문제를 봤을 때 오랜만에 풀어보는 LCS라 풀이방법이 바로 구상이 안되었다.. 2차원 DP를 이용한것 까지는 기억이 났는데... 어떻게든 안보고 풀어보려다가 도저히 생각이 안나서 복습하는 겸 개념을 보았다.
>
> 학습한 개념은 다음과 같다.
>
> > 0. N+1*M+1의 크기에 모든 값이 0인 2차원 DP를 선언한다(N = 첫번째 문자열의 길이, M = 두번째 문자열의 길이)
>> 1. 각 문자열을 순회하며 n번째 문자에 대해 m개의 문자를 비교하여 값이 똑같은지 확인한다.
> > 2. 만약 값이 같다면 DP\[n-1]\[m-1] + 1 한 값을 DP\[n]\[m]에 기록한다.
>> 3. 만약 값이 틀리다면 DP\[n]\[m] = max(DP\[n-1]\[m], DP\[n][m-1])을 한다.
> >    - 왜 값이 틀리면 위와 같이 실행하는지 알아보자. 그 이유는 현재 위치의 값이 틀리다고 해도 현재 위치까지의 발생할 수 있는 최장 부분 수열의 길이를 알고 있어야 후에 값이 똑같은 경우가 발생했을 때 이전에 기록된 최장 부분 수열의 길이를 알고 그 값에 더할 수 있기 때문이다.
>>      - 현재 위치에서 m-1을 하면 1~n 까지와 1~m-1까지의 발생하는 최장 부분 수열의 길이를 의미하는 것이다.
> >      - 현재 위치에서 n-1을 하면 1~n-1 까지와 1~m까지의 발생하는 최장 부분 수열의 길이를 의미하는 것이다.
>>    - 그 두 개의 값을 비교하면 현재 위치까지 발생할 수 있는 최장 부분 수열의 길이를 알 수 있는 것이다.
> 
>위와 같은 방식으로 진행되었다. 오랜만에 풀었다고해서 풀지못한건 좀 많이 아쉽다... 오늘 복습한 만큼 다음번에는 꼭 풀 수 있도록 하자!
