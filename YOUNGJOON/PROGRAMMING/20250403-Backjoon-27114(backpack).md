# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>

using namespace std;

int numbers[3]; 
int K;
vector<int> directions = {3, 1, 2};

void lets_rock()
{
    vector<vector<int> > dp(K+1, vector<int>(4, -1));
    dp[0][0] = 0;
    for (int i=0; i<K; ++i) {
        for (int j=0; j<4; ++j) {
            if (dp[i][j] == -1) continue;
            
            for (int k=0; k<3; ++k) {
                int power = i + numbers[k];
                int next = (j + directions[k]) % 4;
                if (power <= K && (dp[power][next] == -1 || dp[power][next] > dp[i][j] + 1)) dp[power][next] = dp[i][j] + 1;
            }
            
        }
    }
    
    cout << dp[K][0];
    
    return;
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
       
    cin >> numbers[0] >> numbers[1] >> numbers[2] >> K;
    
    lets_rock();

    return 0;
}

```



> ## 문제
>
> 공군 훈련소의 훈육조교는 훌륭한 조교가 되기 위해 오늘도 피나는 제식 연습을 진행한다. 오늘 연습하려고 하는 제식은 총 세 가지로, 현재 바라보는 방향을 기준으로 각각 왼쪽으로 90∘$90\,^\circ$ 회전하는 `좌로 돌아`, 오른쪽으로 90∘$90\,^\circ$ 회전하는 `우로 돌아`, 뒤로 180∘$180\,^\circ$ 회전하는 `뒤로 돌아`이다.
>
> `좌로 돌아`, `우로 돌아`,` 뒤로 돌아`를 1$1$회 수행하는 데에는 각각 A,B,C$A, B, C$만큼의 에너지가 든다. 오늘 조교의 총 에너지는 K$K$만큼 남아있으며, 최고의 훈련을 위해 모든 K$K$만큼의 에너지를 전부 소진하려고 한다.
>
> 조교는 본인의 에너지를 모두 소모하여 연습을 끝냈을 때 처음 바라보던 방향과 완벽히 동일한 방향을 바라보고자 한다. 또한, 어지러움으로 인한 흐트러짐을 막기 위해 제식의 수행 횟수를 최소화하고자 한다.
>
> 조교가 정확히 K$K$만큼의 에너지를 소모하며 처음 바라보고 있던 방향을 바라보며 연습을 끝내고자 할 때 제식 수행 횟수의 최솟값을 구하여라.
>
> ## 입력
>
> 첫 번째 줄에 각각 `좌로 돌아`, `우로 돌아`,` 뒤로 돌아`에 들어가는 에너지를 나타내는 세 정수 A,B,C$A, B, C$와 사용하고자 하는 총 에너지양을 나타내는 정수 K$K$가 공백으로 구분되어 주어진다. (1≤A,B,C,K≤1000000)$(1\leq A,B,C,K\leq 1\,000\,000)$ 
>
> ## 출력
>
> 정확히 K$K$만큼의 에너지를 소모하며 처음 바라보고 있던 방향을 바라보며 연습을 끝내고자 할 때 제식 수행 횟수의 최솟값을 출력한다.
>
> 만약 정확히 K$K$만큼의 에너지를 소모하며 처음 바라보고 있던 방향을 보는 것이 불가능하다면, −1$-1$을 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을때 단순히 원위치로 돌아오는 방법을 찾아 사칙연산으로 풀어보려했으나 다시 생각해보니 다양한 경우의 수가 존재한다는걸 알았다. 따라서 모든 경우의 수를 판단하기위해
>
> 배낭 문제, DP, set를 떠올렸다.
>
> 하지만 배낭 문제는 100만 * 100만의 배열을 만드는 순간 터져서 아닐거라고 생각하고 set로 문제를 풀었다.
>
> 결국 set도 시간초과가 났다 매 연산마다 약 100만개씩 경우의 숫자가 발생하면 결국 다를게 없었다.
>
> 하지만 알고리즘을 보니 배낭 문제였고 아무리 생각해도 방법이 떠오르질 않았다. 결국 코드를 봤는데 배낭을 만드는 방식을 바꾸면 되는 것이었다.
>
> 2차원 배열을 방향의 개수(4) * 에너지의 수(최대 100만)으로 선언하고 해당 배열의 값이 움직인 횟수인 것이다.
>
> 초기에 생각했을때는 움직인 횟수(최대 100만) * 에너지의 수(100만)를 4개 만들어 관리하려고 했다.
>
> 그런데 위의 방법으로 하여 문제를 푸니 풀 수 있었다!
>
> 꼭 풀던 방식이 아닌 다양한 접근으로 문제를 봐야한다는 걸 느꼈다...
