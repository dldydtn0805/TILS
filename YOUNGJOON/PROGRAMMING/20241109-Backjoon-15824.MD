# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>

using namespace std;

int N;
long long result = 0;
vector<long long> numbers;
vector<long long> dp(300010, 1);

void get_scobill()
{
    int idx = N - 1;
    for (int i=N-1; i>0; i--) {
        // cout << (((dp[i] - 1) * numbers[i]) % 1000000007) << " " << (((dp[i] - 1) * numbers[idx - i]) % 1000000007) << "\n";
        
        result += (dp[i] - 1) * numbers[i] % 1000000007;
        result -= (dp[i] - 1) * numbers[idx - i] % 1000000007;
        // cout << tmp << "\n";
        result %= 1000000007;
    }
    
    result += 1000000007;
    result %= 1000000007;
    
    cout << result;
    
    return;
}


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N;
    cin.ignore();
    
    string data;
    getline(cin, data);
    istringstream iss(data);
    long long num;
    while (iss >> num) {
        numbers.push_back(num);
    }
    
    sort(numbers.begin(), numbers.end());
    
    
    dp[1] = 2;
    for (int i=2; i<=N; ++i) {
        dp[i] = dp[i-1] * 2;
        dp[i] %= 1000000007;
    }
    
    get_scobill();

    return 0;
}

```



# 해설

> 주어지는 숫자들로 만들수 있는 모든 조합의 조합내의 최댓값 - 최소값한 값을 모두 더해 1,000,000,007로 나누어야 한다.
>
> 그런데 N이 최대 30만개라서 일반적인 조합을 만드는 알고리즘을 이용하면 20억가량 계산해야해서 20초? 가 걸린다.
>
> 흠 어떻게 해야 1초안에 끊어서 모든 조합들의 값을 계산할 수 있을까?
>
> 어떤 숫자 A가 들어가는 모든 조합의 개수를 구한다면 2^N-1 - 1이 될것이다. (공집합 제외)
>
> 그렇다면 최댓값이 들어가는 조합의 개수와, 최소값이 들어가는 조합의 개수를 구해서 두개값과 개수를 곱한값을 빼준다면? 
>
> 사이에 있는 값들은 어차피 결괏값을 구하는데 도움이 되지 않으므로 최대, 최소값만 구하고 발생하는 조합의 개수만 찾는 것이다.
>
> {2, 8}과 {2, 5, 8}은 어차피 결괏값이 똑같다.
>
> 2가 들어가는 조합의 개수 = {2}, {2, 5}, {2, 8}, {2, 5, 8}
>
> 8이 들어가는 조합의 개수 = {8}, {2, 8}, {5, 8}, {2, 5, 8}
>
> 이 때, 공집합은 {2} 와 {8}을 의미하게 되므로 두개는 빼고 생각한다.
>
> 그런데 조합을 보면 {2, 5}와 {5, 8}은 내가 정한 최소값 2, 최댓값 8이 들어가 있지 않는다..
>
> 그러나 2개의 결괏값을 합하면 6이 되므로 2와 8로 이루어진 조합의 값과 같다.
>
> 이런 점을 이용해 양끝단에서 최소값과 최댓값을 설정하여 계산해온다.
>
> 만약 {1, 2, 3, 4}라는 배열이 있다고 생각한다면,
>
> 1, 4를 최소, 최대로 설정한다.
>
> 그 다음 최소와 최대가 될수 있는 값은 2, 3이고 2를 고려할때 1이 들어가면 안되므로 조합의 개수를 구할때 2^(4-2)의 개수만큼 계산해야한다.
>
> 마찬가지로 최대값을 3으로 볼때도 4가 들어가면 안되므로 조합의 개수를 2^(N-2)로 구한다.
>
> 이런식으로 값을 구해나가면 된다!
>
> 수학적 요소가 들어가 있어서(어떤 숫자가 들어간 모든 조합의 개수 구하기) 너무 어려워서 참고를 했다...
>
> 최대값과 최소값만 정해서 더하면 될 것이라고 생각하긴 했는데 1부터 N개 까지 2부터 N-1 개까지 이런식으로 히려고 했었는데
>
> 이렇게 해도 약 20억번 정도의 연산이 필요해서 불가능했다.. 이런 방법이 존재한다니 놀랍다!
>
> 아직도 수련이 모자란듯하다..
>
> 심지어 계속 틀리길래 뭔가 했더니 %=를 안하고 %만 적었다 그것도 두번이나 코드를 좀 제대로 보고 짜자 나머지 연산은 주어지는 값이 넘지않는 예제를 넣었을때는 문제점을 찾기 어렵기 때문에 쉽게 틀릴 수 있다. 정신차리면서 풀자~~~~~~~~~~~~~~



