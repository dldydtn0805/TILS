# 코드

```c++
#include <iostream>
#include <vector>
#include <deque>
#include <queue>

#define pll pair<int, int>

using namespace std;

int N, M;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    int arrive, stay;
    deque<pair<int, pll> > bus_station; 
    queue<pair<int, pll> > waiting;
    int now_time = 0;

    for (int i=1; i<=M; ++i) {
        cin >> arrive >> stay;
        waiting.push({i, {arrive, stay}});
    }
    
    while (!waiting.empty()) {
        now_time++;
        while (!bus_station.empty() && bus_station.front().first <= now_time) {
            bus_station.pop_front();
        }
        while (!waiting.empty() && waiting.front().second.first <= now_time) {
            if (bus_station.empty()) {
                bus_station.push_back({max(waiting.front().second.first, now_time) + waiting.front().second.second, {1, waiting.front().first}});
                waiting.pop();
            }
            else {
                if (bus_station.back().second.first < N) {
                    bus_station.push_back({max(waiting.front().second.first, now_time) + waiting.front().second.second, {bus_station.back().second.first + 1, waiting.front().first}});
                    waiting.pop();
                }
                else break;
            }
        }
    }
    
    while (!bus_station.empty()) {
        pair<int, pll> now = bus_station.front();
        bus_station.pop_front();
        if (now.second.second == M) {
            cout << now.second.first;
            break;
        }
    }

    return 0;
}
```

> ## 문제
>
> 영우는 6년간 매일 수원에서 서울까지 버스로 통학하는 프로통학러다. 영우가 타는 광역버스는 이용객이 너무 많아 잘못하면 사람에 밀려 못 탈수도 있고, 배차시간이 너무 길어 버스를 놓치고 강의에 지각한 적이 한두번이 아니다. 잦은 지각으로 출석점수에 위기를 느낀 영우는 오늘만은 자신의 버스가 정차할 위치를 미리 계산해서 그 자리에 미리 줄을 서려고 한다. 당신의 임무는 영우를 위해 영우가 탈 버스의 정차 위치를 미리 계산해주는 것이다. 
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15804/1.png)
>
> 버스 정류장은 1차선 통로 모양으로, 진행방향의 맨 앞부터 1번, 2번, n번 위치까지 총 n대의 버스가 동시에 정차해 있을 수 있다. (그림1) 정류장 알림판에는 각 버스의 도착시각(분)과 승객들의 탑승을 위해 몇 분간 정차해 있을지 정차시간(분)이 안내 된다. 또한, 정류장 내 교통 혼잡을 막기 위해 버스들은 다음과 같은 규칙에 따라 정류장에 들어오고 나간다.
>
> 1. 버스 정류장은 1차선 통로이기 때문에, 뒤의 버스는 앞의 버스를 추월할 수 없다. 즉 뒤에 정차한 버스는 자신의 정차시간이 다 끝나도 앞에 정차해 있는 버스가 모두 떠날 때까지 출발할 수 없다.
> 2. 정류장 입구에 도착한 버스는 자신이 정차할 수 있는 위치 중 가장 앞쪽에 정차한다. 만약 n번 위치에 다른 버스가 정차해 있어 들어갈 수 없다면, 정류장 입구에 도착한 순서대로 일렬로 대기한다. (그림2)
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15804/2.png)
>
> 1. 매 분 단위 시각에 정류장 내 버스들은 다음과 같은 순서로 이동한다. 떠나는 버스들은 자신의 위치부터 맨 앞 출구 사이에 장애물(즉, 아직 정차시간이 끝나지 않아 더 정차해 있어야 하는 버스)이 없다면 앞에서부터 차례차례 출구로 빠져나간다. 그런 다음, 이 시각 입구에 대기하고 있거나 막 도착한 버스들이 도착한 순서대로 차례차례 진입하여 가능한 맨 앞자리에 정차한다. 버스들의 속도는 무한대에 가까워서 이 과정에 소요되는 시간, 즉 떠나는 버스들이 모두 빠져나가고 도착한 버스들이 모두 정차하는 순간까지 걸린 시간은 0이라고 가정한다. 예를 들어, 버스 A는 1분에 도착해 1번 위치에 2분 동안 정차하고, 버스 B는 3분에 도착하고, 다른 버스들은 없다고 가정하자. 그러면 3분이 되는 순간, 버스 A가 먼저 정류장을 빠져나가고 버스 B가 입구로 들어와 가능한 위치 중 가장 앞쪽인 1번 위치에 정차하게 된다.
>
> ## 입력
>
> 프로그램의 입력은 표준 입력으로 받는다. 첫줄에는 정류장에 동시에 정차 가능한 버스 수 n, 영우가 타려는 버스까지의 버스 수 m이 주어진다.(1 ≤ n ≤ 10, 1 ≤ m ≤ 100)
>
> 다음 m줄에는 각 버스가 정류장에 도착하는 시간 t와 정차하고 있는 시간 p가 버스가 도착하는 순서대로 주어진다. 만약 여러 버스가 같은 시각에 도착한다면 입력에 주어진 순서대로 버스가 도착한 것으로 본다. (1 ≤ t ≤ 100, 1 ≤ p ≤ 10, ti ≤ ti+1)
>
> ## 출력
>
> 프로그램의 출력은 표준 출력으로 한다. 영우가 타려는 버스(즉, m번째 버스)가 정류장의 어느 위치에 정차하는지 구하시오.
>
> ##  해설
>
> 처음 문제를 봤을 때 queue를 이용하면 되겠다고 생각했다.
>
> queue를 이용하여 버스정류장을 구현하고, 버스가 queue에 들어갈 때 현재 몇번째 버스이며, 몇번 위치에 정차했는지를 기록한다. 그리고 가장 마지막에 들어간 버스의 위치를 저장한다. 이후 만약 마지막 버스의 위치가 N번이라면 더이상 버스가 들어갈 수 없으므로 해당 버스가 나갈때까지 기다렸다가 입장하면 되겠다고 생각했다.
>
> 그런데 계속해서 틀렸습니다를 받았다... 그래서 결국 여러방면으로 시도해보다가 도저히 안되겠어서 다른 사람들의 블로그에서 코드를 좀 확인했다. 그랬더니 로직은 정말 비슷한데... 라고 생각이 들었다... 틀린 이유는 풀이 방법을 해설하고 마지막에 작성하겠다!
>
> > 1. 들어오는 모든 버스의 도착시간과, 대기 시간을 받아 queue인 waiting에 push한다. 버스가 N번까지 찼을때 더이상 버스가 들어갈 수 없으므로 선입선출의 방식이 가장 어울린다고 생각했다. 현재 시간을 나타내는 now_time을 0으로 선언한다.
> >
> > 2. 버스 정류장을 나타낼 deque bus_station을 선언한다.
> >
> > 3. 모든 버스가 버스 정류장에 들어갈 때까지 반복한다.
> >
> >    > 1. 현재 시간인 now_time을 1 올린다.
> >    >
> >    > 2. now_time이 bus_station의 가장 앞에 있는 버스의 출발시간과 같거나 큰지 확인한다. 만약 같다면 해당 버스를 bus_station에서 꺼낸다. 이를 가장 앞에 있는 버스의 출발시간이 now_time보다 높아질때까지 반복한다.
> >    >
> >    > 3. 현재 시간이 waiting의 가장 앞에 있는 버스의 도착시간과 같거나 큰지 확인한다. 만약 같다면 해당 버스를 아래의 경우를 따져본다. 이를 가장 앞에 있는 버스의 도착시간이 now_time보다 높아질때까지 반복한다.
> >    >
> >    >    - bus_station에 버스가 하나도 없다면 `해당 버스의 출발시간과, 버스 정류장의 위치를 1로하고, 현재 버스의 번호`를 같이 bus_station에 기록한다.
> >    >
> >    >    - 만약 bus_station에 버스가 있다면, 가장 뒤에 있는 버스의 버스 정류장 위치를 확인한다.
> >    >
> >    >      - 만약 가장 뒤 버스의 버스 정류장 위치가 N이라면 버스가 들어갈 곳이 없으므로 나간다.
> >    >      - 만약 가장 뒤 버스의 버스 정류장 위치가 N보다 작다면, `해당 버스의 출발시간과 버스 정류장의 위치를 가장 뒤 버스의 정류장 위치 + 1로하고, 현재 버스의 번호`를 같이 bus_station에 기록한다.
> >    >
> >    >      > 이때, 버스의 출발시간은 `max(현재 버스의 도착시간, now_time) + 현재 버스의 대기시간`이 된다.
> >    >      >
> >    >      > 이는, 해당 버스가 도착시간에 반드시 들어갈 수 있다는 보장이 없기 때문에 현재 들어간 시간을 기준으로 할지 now_time을 기준으로 할지가 나뉘기 때문!
> >
> > 4. waiting이 모두 비었다면, 현재 bus_station에 있는 모든 버스를 순회한다. 그리고 M번째 버스를 찾아 해당 버스와 같이 저장된 `현재 버스의 정류장 위치`를 출력한다.
>
> 위와 같은 로직으로 문제를 풀었다!
>
> 이 문제는 계속해서 틀렸는데 아무리 생각해도 로직이 맞다고 생각해서 이틀동안 붙잡은 문제였다.
>
> 그런데 틀린 이유는 정말 단 하나의 로직이 빠져서 틀렸었는데 그것은 바로 **버스의 출발시간을 구하는 방법**때문이었다.
>
> 이전의 내 코드는 그냥 버스의 도착시간을 기준으로만 출발시간을 연산했다. 이렇게되면 문제가 발생하는데,
>
> > 만약 정류장의 개수가 5개인 상황이다. 현재 5번까지 버스가 가득 차있는 상황이라 버스가 들어서지 못하고 있다. 이때, 5번 위치에 있는 버스가 50초에 나갔다. 그러나, 그 다음에 들어갈 예정이었던 버스는 10초에 들어갈 예정이었다 그리고 대기는 5초할 생각이었다. 그렇다면 해당 버스의 출발시간은 15초로 적혀버리고 이미 나갈 시간이 되었으니 곧장 나가버린다. 그러나 사실상 도착한 시간은 50초이고 55초에 출발했어야했던것이다. 만약 이후의 버스가 M번째 버스이고 도착 시간이 15초 대기 시간이 1초 밖에 안됬다면, `(앞) 55초 출발 - 51초 출발 (뒤)`와 같은 상황이 되었어야 했으나 앞에 버스는 15초로 생각하고 출발해버렸기 때문에 M번 버스는 바로 1번위치로 가버린다.
>
> 위와 같은 문제가 발생해서 반드시 출발시간을 현재시간과 도착시간 중 어떤것을 사용해야할지 잘 따져봤어야했는데, 그냥 도착시간을 기준으로 연산해버려서 문제가 발생했던 것이다... 아아... 정말 이런 실수 하나 때문에 이틀이나 시간을 써가면서 문제를 풀었다는게 좀 아쉽다... 엄청난 로직이었던것도 아니고 큰틀은 맞았는데 이런걸 놓쳐서 고통받았다는게 너무 아쉬웠다.. 그래도 정말 생각지도 못한 것이었기 때문에 아직 실력이 미흡하다고밖에 못하겠다...
>
> 앞으로 문제를 너무 못풀면 속시원하게 힌트를 얻는것도 좋은 방법인거 같다...! 더 정진하자!!
