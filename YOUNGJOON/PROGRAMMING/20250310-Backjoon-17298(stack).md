# 코드

```c++
#include <iostream>
#include <vector>

#define pll pair<int, int>

using namespace std;

int N;
vector<int> numbers, O_big;

void O_big_num()
{
    vector<int> stacker;
    int stack_size = 0;
    
    for (int i=N-1; i>=0; --i) {
        
        while (stack_size > 0 && stacker.back() <= numbers[i]) {
            stacker.pop_back();
            stack_size--;
        }
        
        if (stack_size > 0) {
            O_big[i] = stacker.back();
        }
        stacker.push_back(numbers[i]);
        stack_size++;
    }
    
    for (int a : O_big) {
        cout << a << " ";
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    cin >> N;
    int num;
    O_big.resize(N, -1);
    for (int i=0; i<N; ++i) {
        cin >> num;
        numbers.push_back(num);
    }
    
    O_big_num();

    return 0;
}

```



> ## 문제
>
> 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.
>
> 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.
>
> ## 입력
>
> 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.
>
> ## 해설
>
> 이 문제는 스택을 이용하여 풀었다. 
>
> > 1. 빈 스택을 하나 선언한다. 그리고 주어진 숫자를 뒤에서 부터 순회한다.
> > 2. 현재 스택에 값이 있다면, 스택안에 현재 숫자보다 작거나 같은 숫자를 모두 뺀다. 
> >
> > 3. 2번을 진행 후 현재 스택에 값이 없으면 앞에 숫자가 없거나 앞에 자신보다 큰 숫자가 없다는 뜻이 된다.
> > 4. 2번을 진행 후 현재 스택에 값이 있다면 스택 맨 앞에 있는 숫자가 현재 숫자의 오큰수 이므로 이를 따로 기록해둔다.
> > 5. 현재 숫자를 스택에 push 한다.
>
> 위의 절차를 모두 거치면 뒤에서 부터 현재 숫자의 모든 오큰수를 알 수 있다.
>
> 처음에 문제를 잘못 읽어서 오른쪽에 있는 현재보다 큰 숫자 중 가장 작은 숫자를 찾으라고 봤다.... 그러자 난이도가 폭등했다.... 정렬을 이용하거나, queue를 이용하거나 역순 정순 순회 등 여러 방면에서 해보려고 했는데... 도저히 못하겠어서 알고리즘 분류를 봤다 그러자 스택이 뙇...!
>
> 근데 처음 문제를 잘못본 경우에서도 스택으로 문제를 풀기는 어려웠다. 스택에 들어있는 자신보다 큰 숫자 중 작은 숫자를 찾아야하고.... 스택에서 값을 빼버리는 경우에는 후에 해당 숫자가 쓰이지 못해서 틀리고... 난리가 났다... 결국 다른 사람의 블로그에서 코드를 봤는데 문제를 잘못봤으니 해당 코드가 왜 맞는지 이해가 안갔다... 그래서 문제를 다시 읽어보니... 아...! 문제를 잘못봤다는걸 알았다..............................
>
> 위처럼 문제를 잘못보지 않았다면 충분히 풀었을 것 같기도 하고..... 이제와서 무슨 소용이겠냐마는.... 제발 문제를 잘보고 푸는 습관을 들이자 최근들이 이런 경우가 너무 자주 일어난다 코딩테스트에서 이러면 죽도밥도 안되니까.....
