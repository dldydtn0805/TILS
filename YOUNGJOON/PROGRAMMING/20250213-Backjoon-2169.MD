# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>

#define pll pair<int, int>

using namespace std;

int N, M;
vector<vector<int> > board;
int dp[2][1001][1001];
// vector<pll> direction = {{0, 1}, {1, 0}, {0, -1}};

void make_dp()
{
    dp[0][0][0] = dp[1][0][0] = board[0][0];
    
    for (int i=0; i<M; ++i) {
        dp[0][0][i] = dp[1][0][i] = dp[0][0][i - 1] + board[0][i]; 
    }
    
    for (int i=1; i<N; ++i) {
        for (int j=0; j<M; ++j) {
            if (j == 0) {
                dp[0][i][j] = max(dp[0][i - 1][j] + board[i][j], dp[1][i - 1][j] + board[i][j]);
            }
            else {
                dp[0][i][j] = max({dp[0][i - 1][j] + board[i][j], dp[1][i - 1][j] + board[i][j], dp[0][i][j - 1] + board[i][j]});
            }
        }
        for (int j=M-1; j>=0; --j) {
            if (j == M-1) {
                dp[1][i][j] = max(dp[0][i - 1][j] + board[i][j], dp[1][i - 1][j] + board[i][j]);
            }
            else {
                dp[1][i][j] = max({dp[0][i - 1][j] + board[i][j], dp[1][i - 1][j] + board[i][j], dp[1][i][j + 1] + board[i][j]});
            }
        }
    }
    
    cout << max(dp[0][N-1][M-1], dp[1][N-1][M-1]);
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    cin >> N >> M; cin.ignore();
    
    string data;
    int num;
    for (int i=0; i<N; ++i) {
        getline(cin, data);
        istringstream iss(data);
        vector<int> one_line;
        while (iss >> num) {
            one_line.push_back(num);
        }
        board.push_back(one_line);
    }
    
    make_dp();
    
    // for (int i=0; i<2; ++i) {
    //     cout << "이번에는 " << i << " 입니다" << "\n";
    //     for (int j=0; j<N; ++j) {
    //         for (int k=0; k<M; ++k) {
    //             cout << dp[i][j][k] << " ";
    //         }
    //         cout << "\n";
    //     }
    // }
    
    return 0;
}

```



> ## 문제
>
> NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.
>
> 지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.
> 
> 각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.
>
> ## 해설
>
> 처음 문제를 보고 BFS를 이용하여 발생할 수 있는 최적의 값을 visited에 저장해두고 그 값을 기준으로 움직이려고 했다.
>
> 그러나 문제의 조건에서 보이듯이 왼쪽, 오른쪽으로 이동이 가능하기 때문에 현재 기록된 값이 최적이라고 하더라도, 멀리서 돌아온 값이 최적일 수 있었다. 그러나 계속해서 0,0 -> 0, 1 -> 0,0 ...을 무한 반복하는걸 막기위해 이전에 들렸던 곳은 들리지 못하게 처리하려고 했고 왼쪽에서 계속해서 더해와서 5*5라고 할때 1, 0 ~> 1, 4까지 온값이 1, 5 -> 1, 4까지간 값보다 큰 경우가 많아 막혀버리고 말았으나 사실 1, 5에서 1, 0까지 가는 값이 더 큰 경우도 있었다. 따라서 BFS는 버리고 DFS로 가기로 했다.
>
> DFS 역시 문제가 있었다 모든 경로를 확인할 수 있는건 좋았으나 따로 완전 탐색에서 최적화 시킬 방법이 막상 떠오르지 않았다...
>
> 결국 알고리즘 분류를 봤고 의외의 알고리즘인 DP가 등장했다.. 이럴수가...
>
> DP를 보고 생각해보니 음... BFS 당시에 좌측에서 우측으로와 우측에서 좌측으로의 경우가 문제였었으니까... 그걸 3차원 DP를 이용해 왼쪽만 가능 경우와 오른쪽만 가는 경우를 나누어서 보기로 하면 어떨까 생각이 들었다.
>
> 처음 맨 윗줄은 반드시 0, 0으로 시작하기 때문에 왼쪽에서 오른쪽으로만 간다. 따라서 이를 기록해두고 두번째 줄부터 시작했다.
>
> 지정된 방향으로 계속해서 확인한다. 우선적으로 두방법의 시작점 (n, 0) , (n, M-1)은 바로 위줄에서 값을 내려 받고 정해진 방향으로 순회한다. 
>
> 이때 윗줄에서 내려받는 값은 왼쪽이나 오른쪽 둘 중 더 높은 값으로 내려받는다. 현재 구간을 나누긴 했지만 위에서 내려받을 값은 반드시 일어날 수 있는 최적의 값이어야 하기 때문이다. 시작점이 값을 받았으면 정해진 방향으로 계속해서 값을 더한다. 이를 각각의 방향에 따라 기록한다. 그리고 최종적으로 2개의 2차원 DP중 (N-1, M-1)에 기록된 최대값을 출력하였다.
>
> BFS를 돌릴때 문제의 키포인트를 파악한게 중요한 것 같다 (왼쪽, 오른쪽으로 이동이 가능하기 때문에 현재 기록된 값이 최적이라고 하더라도, 멀리서 돌아온 값이 최적일 수 있었다.)
>
> 이걸 알고 DP로 푸는걸 알아서 유형을 보자마자 해결할 방법을 떠올렸던것 같다. 하지만... 결국 알고리즘은 혼자 힘으로 생각해내진 못했으니... 아쉽다....
>
> 더 많이 풀어서 좋은 결과를 내도록 노력하자!

