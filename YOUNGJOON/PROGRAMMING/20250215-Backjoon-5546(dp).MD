# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, K;
vector<vector<vector<int> > > dp;
vector<int> must_p;

void eat_pasta()
{
    for (int i=1; i<=N; ++i) {
        if (must_p[i] != -1) {
            if (i == 1) {
                dp[must_p[i]][0][i] = 1;
            }
            else {
                for (int j=0; j<3; ++j) {
                    if (j != must_p[i]) {
                        for (int k=0; k<2; ++k) {
                            dp[must_p[i]][0][i] += dp[j][k][i - 1]; 
                        }
                        dp[must_p[i]][0][i] %= 10000; 
                        
                    }
                    else {
                        dp[must_p[i]][1][i] += dp[must_p[i]][0][i-1];
                        dp[must_p[i]][1][i] %= 10000;
                    }
                }
            }
        }
        else {
            if (i == 1) {
                for (int j=0; j<3; ++j) {
                    dp[j][0][i] = 1;
                }
            }
            else {
                for (int j=0; j<3; ++j) {
                    for (int k=0; k<3; ++k) {
                        if (j == k) {
                            // cout << "나는 " << j << "소스를 한번 더 먹어서" << dp[j][0][i - 1] << "을 " << dp[j][1][i] << "에 더할거야" << "\n";
                            dp[j][1][i] += dp[j][0][i - 1];
                            dp[j][1][i] %= 10000;
                        }
                        else {
                            for (int p=0; p<2; ++p) {
                                // cout << "나는 " << dp[k][p][i-1] << "을 " << dp[j][0][i] << "에 더할거야" << "\n";
                                dp[j][0][i] += dp[k][p][i-1];
                            }
                            dp[j][0][i] %= 10000;
                        }
                    }
                }
            }
        }
        for (int j=0; j<3; ++j) {
            for (int k=0; k<2; ++k) {
                // cout << i << "일에 " << j << "번 소스를 " << k << "번 먹은 경우는 " << dp[j][k][i] << "\n";
            }
        }
        
    }
    
    int result = 0;
    
    for (int i=0; i<3; ++i) {
        for (int j=0; j<2; ++j) {
            result += dp[i][j][N];
        }
    }
    result %= 10000;
    
    cout << result;
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    cin >> N >> K;
    dp.resize(3, vector<vector<int> >(2, vector<int>(N+1, 0)));
    must_p.resize(N+1, -1);
    int d, p;
    for (int i=0; i<K; ++i) {
        cin >> d >> p;
        must_p[d] = p - 1;
    }
    
    eat_pasta();

    return 0;
}

```



> ## 문제
>
> 상근이는 매일 저녁으로 파스타를 만들어 먹는다. 상근이가 만들 수 있는 파스타는 총 세 종류로 토마토 소스, 크림 소스, 바질 소스이다.
>
> 상근이는 앞으로 N일 동안 먹을 파스타를 계획하려고 한다. 매일 매일 세 종류의 파스타 중 한 종류를 선택할 것이다. 하지만, 같은 파스타를 계속해서 먹으면 질려버릴 수 있기 때문에, 3일 이상 연속해서 같은 파스타를 먹지 않는다.
>
> 또, N일 중 K일에 먹을 파스타는 미리 정해두었다.
>
> N과 K일에 먹을 파스타가 주어졌을 때, 가능한 계획의 수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 N과 K가 주어진다. (3 ≤ N ≤ 100, 1 ≤ K ≤ N)
>
> 둘째 줄부터 K개 줄에는, 미리 파스타를 정해놓은 날의 정보가 주어진다. 이 정보는 Ai Bi와 같은 형식이며, Ai일에 먹을 파스타는 Bi라는 뜻이다. 이때, Bi = 1이면 토마토 소스, 2이면 크림 소스, 3이면 바질 소스이다. Ai는 모두 다르다.
>
> ## 해설
>
> 처음 문제를 보고 DP를 생각했다. 주어진 소스별로 연속 섭취한 횟수를 다루면서 각각의 일차에 대해 기록하면서 값을 가지고가면 어떨까 생각했다.
>
> 즉 3차원 DP를 이용하는것이다.
>
> \[소스의 종류][해당 소스 연속 섭취횟수]\[현재일자] 와 같은 방식으로 3차원 배열을 선언하였다.
>
> 그리고 만약 주어진 특별하게 먹을 날이 정해진 날짜는, 전날에 해당 소스를 1번 먹은 경우를 2번먹은 경우로 올리고 나머지 다른 소스의 모든 값을 해당 소스를 1번 먹는 경우로 더해주면 된다!
> 
> 만약 특별히 먹을날이 정해지지 않았다면, 모든 소스에 대해서 전날에 해당 소스를 1번 먹은 경우를 2번먹은 경우로 올리고 자신을 제외한 나머지 다른 소스의 전날에 한번먹은 값과 두번 먹은 값을 다 오늘 자신의 한번 먹은 소스 값으로 저장하는 식으로 진행했다.
> 
> 위와 같은 방법으로 진행하니 바로 맞았다!
>
> 문제를 푸는중에 계속해서 값이 이상하게 나오는 상황이 발생해서 확인해보니 소스특정일자의 길이를 K만큼 선언해서 그런거였다 그런데 왜 에러가 나지 않았을까...? K까지 선언한 벡터라면 K를 넘어서는 i의 값이 되었을때 인덱스 에러가 뜰만도 했는데 뜨지 않았다 음... 값을 호출하여 저장하는것이 아닌 true false 의 값을 반환하는데 사용하는 경우라서 에러가 나지 않았던걸까? 흠.. 이것도 알아봐야겠다.

