# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, M, K;

int lets_play()
{
    int play_time = 1;
    int target = M;
    int cnt = N;
    while (true) {
        int go_power;
        if (K <= cnt) {
            go_power = K;
        }
        else {
            go_power = K % cnt;
            if (go_power == 0) {
                go_power = cnt;
            }
        }
        if (go_power == target) {
            return play_time;
        }
        else if (go_power > target) {
            target += (cnt - go_power);
        }
        else {
            target -= go_power;
        }
        cnt--;
        play_time++;
    }
    
    return -1;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> K >> M;
    
    cout << lets_play();

    return 0;
}

```



> ## 문제
>
> 동호와 동호네 반 친구들은 산정호수로 소풍을 갔다. 총 N명이 소풍에 참가했고, KIN 게임을 하려고 한다. 이 게임은 다음과 같이 진행된다.
>
> 무대에 올라간 N명은 1번부터 N번까지 시계방향으로 원형으로 앉았다. 이 게임은 1번부터 시작된다. 그리고 한 명씩 시계방향으로 1, 2, ... , K까지 센다. K를 말하는 사람은 퇴장 당한다. 그 후에는 다음 자리에 앉아있는 사람이 1부터 다시 센다. 동호도 이 게임에 M번 학생으로 참가한다. 동호는 자기가 몇 번째로 퇴장 당하는지 궁금해졌다.
>
> 예를 들어, 5명의 학생이 참가하고 K=2이고, 동호는 3번 학생이라고 하면, 가장 처음에는 1 2 3 4 5와 같이 앉아있다. 1부터 게임을 시작하기 때문에, 1이 1이라고 말하고, 2가 2라고 말한다. 2가 퇴장 당한다. 3이 1이라고 말하고, 4가 2라고 말한다. 4가 퇴장 당한다. 그 다음에는 1이 퇴장 당한다. 그 후에는 5가 퇴장당하고, 마지막으로 3이 퇴장 당한다. 동호는 3번 학생이기 때문에, 5번째로 퇴장 당한다.
>
> N, K, M가 주어졌을 때, 동호가 몇 번째로 퇴장 당하는지 알아내는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 세 정수 N, K, M가 주어진다.
>
> ## 해설
>
> 처음 문제를 보았을 때 연결 리스트와 비슷하게 다음 노드와 이전 노드를 기록해두고, 삭제된 노드는 이전 노드와 다음 노드를 연결해주는 방식으로 구현해보려고 했다. 
>
> 그리고 이동횟수는 현재 남아있는 노드의 개수보다 크다면 1바퀴 이상 돌 수 있으므로 `이동횟수 % 남아있는 노드의 개수 = 진짜 이동횟수`로 연산하여 사용하였고 현재 남아있는 노드의 개수보다 적다면 1바퀴 안에 돌 수 있으므로 해당 횟수만큼 연산하였다.
>
> ```c++
> #include <iostream>
> #include <vector>
> 
> using namespace std;
> 
> int N, M, K;
> int next_node[50000001];
> int before_node[50000001];
> 
> int lets_play()
> {
>     int play_time = 1;
>     int now = 1;
>     int cnt = N;
>     while (true) {
>         int go_power;
>         if (K <= cnt) {
>             go_power = K;
>         }
>         else {
>             go_power = K % cnt;
>             if (go_power == 0) {
>                 go_power = cnt;
>             }
>         }
>         for (int i=1; i<go_power; ++i) {
>             now = next_node[now];
>         }
>         if (now == M) {
>             return play_time;
>         }
>         int before = before_node[now];
>         next_node[before] = next_node[now];
>         before_node[next_node[now]] = before;
>         now = next_node[now];
>         play_time++;
>         cnt--;
>     }
>     
>     return -1;
> }
> 
> int main()
> {
>     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
>     cin >> N >> K >> M;
>     
>     for (int i=1; i<=N; ++i) {
>         next_node[i] = i+1;
>         before_node[i] = i-1;
>     }
>     next_node[N] = 1;
>     before_node[1] = N;
>     
>     cout << lets_play();
> 
>     return 0;
> }
> 
> ```
>
> 위의 코드였으나 아쉽게도 틀렸다 아래의 반례에 당했다
>
> ```
> 99999 11111 3
> ```
>
> 그렇다 보면 알겠지만 11111은 99999보다 작다 그리고 1개씩 제외한다고 생각했을 때, 99999가 11111보다 작아지려면 88888번의 연산이 필요하다 즉
>
> `88888 * 11111`의 연산 + 이후의 연산이 되는 것이다. 위의 반례는 어찌저찌 돌아간다하더라도, 500만이되면 애기가 달라진다.
>
> 처음 시간 복잡도를 계산할때 최악의 경우인 N = 500만, K = 500만 인 경우로 생각했었는데 다른 반례가 존재했던 것이다...
>
> 결국 아무리 생각해도 위의 반례를 잡을 방법이 생각나지 않았다. 그래서 질문게시판에 있는 힌트를 보고 문제를 풀었다.
>
> > 처음 시작했을때 기준으로 정확하게 몇번쨰 애가 죽는지 알 필요가 없으니깐
> >
> > 상대적인 위치만 알면 되서 O(n)으로 풀 수 있어요.
> >
> > 1 2 3 4 5 에서 2가 죽고나면
> >
> > 3 4 5 1 이 될껀데 이거를 다시 1 2 3 4로 생각하고 이런식으로 계속 줄여나갓어요.
>
> 위의 힌트를 보고 이해하니까 문제가 다르게 보였다. 접근방법은 아래와 같다.
>
> > 0.  반드시 숫자는 1부터 진행한다 따라서 처음 주어지는 타겟의 값의 인덱스 값은 M과 같다. `예시) {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 타겟 = 7`
> >
> > 1. 사람들 중에서 K번째 인덱스의 값을 빼버린다. 단, K가 현재 사람들의 수보다 크다면, 사람들의 수만큼 나누어 준다. 
> >
> >    `예시) K = 12, 현재 사람들의 수 = 10, 빼버릴 인덱스 값 = 2`
> >
> > 2. 값을 빼버린 인덱스의 다음 값을 1번 인덱스로 하여 인덱스를 재정립 한다. 이때, 타겟의 값이 정확히 갱신되어야 한다.
> >
> >    `예시) 새로운 시작점이 되는 인덱스 값 = 3, 현재 타겟의 위치 = 7, 재정립한 후 타겟의 위치 = 5`
> >
> >    2- 1. 만약 빼버린 인덱스의 값이 타겟의 값과 같다면 현재 반복횟수를 반환한다.
> >
> >    `예시) K = 12, 현재 사람들의 수 = 10, 빼버릴 인덱스 값 = 2, 타겟 = 2 -> 반복횟수 반환 후 탈출`
> >
> > 3. 사람이 하나 빠졌으니 현재 사람들의 수를 1뺀다.
> >
> > 4. 1~3을 2-1의 경우가 나타날때 까지 반복한다.
>
> 위의 방식으로 문제를 해결하면 굳이 값들의 위치를 움직이거나, 이미 삭제한 값들을 다루지 않아도 된다.
>
> 아주 신기한 방법이다. 2개의 배열을 두고 1개의 배열에는 처음 모든 값이, 반대 배열은 빈 배열로 두어 움직인 값들을 반대편으로 옮기며 한쪽이 다 비면 반대로 똑같이 시행하는 방식으로 해볼까 했으나 옮기는데 드는 시간이 너무 오래걸려서 포기했었는데 위의 방법이라면 굳이 값들을 실제로 옮기지 않고도 빠르게 구현이 가능했다!
>
> 무슨 방식? 인지 따로 정해져있진 않은 것 같고... (분류가 수학이었음) 인덱스 값을 이용한 정리로 생각된다! 엄청나구나...... 하나 배워가는 좋은 시간이었다.
