# 코드

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int N;
vector<vector<int> > board(101, vector<int>(101, 0));
map<int, pair<int, int> > directions = { {0, {0, 1}}, {1, {-1, 0}}, {2, {0, -1}}, {3, {1, 0}} };

void Dragon_Curve(int x, int y, int dir, int gen)
{
    board[y][x] = 1;
    vector<int> dir_lis = {dir};
    int ny = y + directions[dir].first;
    int nx = x + directions[dir].second;
    if (0 <= nx && nx < 101 && 0 <= ny && ny < 101) {
        board[ny][nx] = 1;
    }
    int dir_size = 1;
    
    // cout << y << " " << x << "\n";
    // cout << ny << " " << nx << "\n";
    
    for (int i=0; i<gen; ++i) {
        int tmp_size = 0;
        vector<int> tmp_lis;
        for (int j=dir_size- 1; j>=0; --j) {
            int next_dir = (dir_lis[j] + 1) % 4;
            ny += directions[next_dir].first;
            nx += directions[next_dir].second;
            if (0 <= nx && nx < 101 && 0 <= ny && ny < 101) {
                board[ny][nx] = 1;
            }
            tmp_size++;
            tmp_lis.push_back(next_dir);
            // cout << next_dir << " | " <<  ny << " " << nx << "\n";
        }
        dir_size += tmp_size;
        
        for (int k=0; k<tmp_size; ++k) {
            dir_lis.push_back(tmp_lis[k]);
        }
    }
    
    return;
}

void Check_Square()
{
    int result = 0;
    
    for (int i=0; i<100; ++i) {
        for (int j=0; j<100; ++j) {
            if (board[i][j] == 1 && board[i+1][j] == 1 && board[i][j+1] == 1 && board[i+1][j+1] == 1) {
                result++;
            }
        }
    }
    
    cout << result;
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    
    cin >> N;
    
    int x, y, dir, gen;
    for (int i=0; i<N; ++i) {
        cin >> x >> y >> dir >> gen;
        Dragon_Curve(x, y, dir, gen);
    }
    
    Check_Square();

    return 0;
}

```



> ## 문제
>
> 드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다.
>
> 1. 시작 점
> 2. 시작 방향
> 3. 세대
>
> 0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/1.png)
>
> 1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/2.png)
>
> 2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/3.png)
>
> 3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/4.png)
>
> 즉, K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다.
>
> 크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.
>
> ## 입력
>
> 첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)
>
> 입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.
>
> 방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.
>
> - 0: x좌표가 증가하는 방향 (→)
> - 1: y좌표가 감소하는 방향 (↑)
> - 2: x좌표가 감소하는 방향 (←)
> - 3: y좌표가 증가하는 방향 (↓)
>
> ## 해설
>
> 처음 문제를 보고 음.. 드래곤 커브가 돌아가는 규칙을 좀 찾아보려고 했다 문제에선 이전 세대의 드래곤 커브를 시계방향으로 90도 회전하여 이전 세대의 드래곤 커브 끝점에 그대로 붙인다고했다. 하지만 우리는 그게 불가능하니까 규칙성을 찾아보려고했다 그랬더니 왠걸 반시계반향으로 90도를 돌리는 것과 상당히 유사한 느낌이었다. 계속 살펴보니 제일 나중에 생긴 선부터 차례대로 반시계 방향 90도로 회전하여 차근차근 붙여주면 드래곤 커브 다음 세대가 완성되었다. 이를 이제 구현만 하면 된다고 생각했다.
>
> 주어지는 입력에 맞게 주어진 좌표에서 시작하여 처음 0세대 드래곤 커브를 주어진 방향으로 시작한다. 이 방향을 따로 배열에 저장해둔다. 그 후, 저장된 방향을 뒤에서부터 순회하여 해당 방향을 반시계 방향 90도로 돌려서 이어준다. 그후 방향을 저장하는 배열의 뒤에 추가한다. 이를 주어진 세대 수 만큼 반복하여 드래곤 커브를 기록한다. 드래곤 커브가 지나치는 점으로 이루어진 사각형을 찾아야하기 때문에 각 좌표에 드래곤커브가 지나갔다는 표시를 해주었다.
>
> 그리고 모든 기록이 끝나면 100*100 배열을 순회하여 사각형이 드래곤커브가 표시된 점으로만 이루어지는 경우의 개수를 찾아 출력해주었다. 
>
> 그런데 문제를 보면 `0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.`라는 말이 있다 즉, 드래곤 커브가 주어지는 배열 바깥으로 넘어가도 끝나는게 아니라 커브하다가 다시 100*100으로 들어오면 유효하다는 얘기로 보였다 따라서 현재 좌표를 뜻하는 nx, ny가 유효 범위를 벗어나도 계속해서 주어진 세대만큼 드래곤커브를 반복하게 하였다. 단, 표기는 범위안에일때만 표기했다.
>
> 당차게 제출했는데 인덱스 범위 오류가 났다... 코드를 보니 미흡한 점이 많았다. 범위안일때만 표기해야하는 것도 까먹었었다 그래서 처음 Dragon_Curve함수가 호출되어서 0세대를 표시할때 한번, 매 세대를 순회할때 계속 범위안일때만 표기하게 코드를 작성하였다.
>
> 그렇게 또 당차게 제출했는데 인덱스범위 오류가 났다. 슬슬 멘붕이 왔다 아무리봐도 인덱스 오류가 날게 없는데.... 근데 계속 보다보니까 사각형 여부를 판단하는 함수에서 현재 좌표중 하나가 100일때 문제가 발생했다. 100+1 = 101 즉,  101의 좌표를 보려고 인덱스 호출을 해서 인덱스 범위 에러가 난것이다...
>
> 이런 말도안되는 치명적 실수를 하다니 문제가 많다....... 결국 이걸 고치니까 정답을 받았다.
>
> 구현 문제는 이런 사소한것을 꼭 조심해야했는데 이걸 놓치다니 정말 걱정됬다 구현 문제는 코테에서도 애용하는 문제고 이런 실수는 기본적인 케이스에서도 찾아보기 힘드니 꼭 조심해서 문제를 풀도록하자..!

