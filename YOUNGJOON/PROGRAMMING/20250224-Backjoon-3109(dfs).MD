# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, M;
vector<vector<char> > board; 
vector<vector<bool> > visited;
vector<pair<int, int> > directions = {{-1, 1}, {0, 1}, {1, 1}};
int result = 0;


bool make_pipe(pair<int, int> now)
{
    visited[now.first][now.second] = true;
    
    if (now.second == M - 1) {
        result++;
        return true;
    }
    
    bool is_connect = false;
    
    for (int i=0; i<3; ++i) {
        int nx = now.first + directions[i].first;
        int ny = now.second + directions[i].second;
        if (0 <= nx && nx < N && 0 <= ny && ny < M && board[nx][ny] == '.' && visited[nx][ny] == false) {
            is_connect = make_pipe({nx, ny});
            if (is_connect == true) {
                break;
            }
        }
    }
    
    return is_connect;
    
}


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    
    cin >> N >> M;
    board.resize(N, vector<char>(M));
    visited.resize(N, vector<bool>(M, false));
    string data;
    
    for (int i=0; i<N; ++i) {
        cin >> data;
        for (int j=0; j<M; ++j) {
            board[i][j] = data[j];
        }
    }
    
    for (int i=0; i<N; ++i) {
        make_pipe({i, 0});
    }
    
    cout << result;

    return 0;
}

```



> ## 문제
>
> 유명한 제빵사 김원웅은 빵집을 운영하고 있다. 원웅이의 빵집은 글로벌 재정 위기를 피해가지 못했고, 결국 심각한 재정 위기에 빠졌다.
>
> 원웅이는 지출을 줄이고자 여기저기 지출을 살펴보던 중에, 가스비가 제일 크다는 것을 알게되었다. 따라서 원웅이는 근처 빵집의 가스관에 몰래 파이프를 설치해 훔쳐서 사용하기로 했다.
>
> 빵집이 있는 곳은 R*C 격자로 표현할 수 있다. 첫째 열은 근처 빵집의 가스관이고, 마지막 열은 원웅이의 빵집이다.
>
> 원웅이는 가스관과 빵집을 연결하는 파이프를 설치하려고 한다. 빵집과 가스관 사이에는 건물이 있을 수도 있다. 건물이 있는 경우에는 파이프를 놓을 수 없다.
>
> 가스관과 빵집을 연결하는 모든 파이프라인은 첫째 열에서 시작해야 하고, 마지막 열에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있고, 각 칸의 중심끼리 연결하는 것이다.
>
> 원웅이는 가스를 되도록 많이 훔치려고 한다. 따라서, 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.
>
> 원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 R과 C가 주어진다. (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500)
>
> 다음 R개 줄에는 빵집 근처의 모습이 주어진다. '.'는 빈 칸이고, 'x'는 건물이다. 처음과 마지막 열은 항상 비어있다.
>
> ## 해설
>
> 처음 보았을때 dp 처럼 방문을 기록하고 매 열마다 최대로 만들 수 있는 파이프라인을 기록한다 그리고 그 중 가장 발생할 수 있는 작은 값을 가지고 진행하려고 했다.
>
> 그런데 위의 로직은 반례에 당했다. 계속해서 파생해 나가다보니 파이프라인이 중첩되는 경우가 나왔고 이를 방지하려고 각 파이프라인을 넘버링하여 추적하려고하니 파이프라인이 겹칠때 어디에서 파생된 파이프라인을 쓸것인지를 정하는 방법이 마땅치 않았다. 결국 위의 방법은 실패했고, 계속 고민했지만 해답을 찾기 어려웠다.
>
> 결국 분류를 보았는데 그리디...? 가 나타났다.. 게다가 그래프 순회까지 등장했다
>
> 그래프 순회는 사실 아에 불가능하다고 생각했다... 어느 한 파이프라인을 잇는다고 해도 그게 가장 효율적인 배치가 될거라는 보장이 없다고 생각했기 때문이다.
>
> 그런데 같이 등장한 그리디가 이를 보정해주는건가...? 싶었다 그러나 아무리 생각해도 무슨 방법으로?? 라는 생각이 떠나질 않았고 결국 친구에게 도움을 얻었다.
>
> 그리디 방식은 아래와 같다.
>
> > 1. 첫번째 열 맨위에서 부터 시작한다. 이때 가능한한 파이프라인을 위쪽으로 붙여 설치한다.
> > 2. 1을 맨위부터 맨 아래까지 반복한다. 이때 가장 끝 열에 도달하여 파이프라인을 설치하는 경우가 발생하면 1개의 설치가 완료된 것이다.
>
> 위의 방식은 이동방법이 오른쪽 열로 가면서 위, 중간, 아래로만 움직일 수 있는 경우 때문에 한쪽으로 최대한 밀어넣어 파이프라인을 설치하면 최적의 경우가 된다는 접근으로 실행한 것이다.
>
> 이를 위해 DFS를 이용하여 맨 첫번째 열부터 위, 중간, 아래로 이동하면서 최대한 위쪽으로 붙여 파이프라인을 설치하였다.
>
> 해당 문제를 푸는데 정답이 잘나오다가 제출하니 시간초과가 났었는데
>
> 처음에는 파이프라인이 완성이 되야지만 방문처리를 하여 해당 파이프라인에 접근하지 못하게 하였다. 그렇다면 파이프라인을 만들기까지 중간에 실패하는 라인들도 다시 재방문하여 하나의 파이프라인을 구하는데 너무 많은 시도가 생기는 오류가 발생하였다.
>
> 처음에 파이프라인이 만들어지기 전에는 계속해서 가능성을 열어두기 위해 방문처리를 하지 말아야한다고 생각했으나 다시 생각해보면 어떠한 경우로 다시 들어오던 해당 위치가 파이프라인을 만드는데 실패했다면, 또 다시 실패하기 때문에 굳이 방문처리를 하지 않을 이유가 없었던 것이다.
>
> 이를 수정하여 제출하니 시간초과가 나지 않았고 정답을 받았다.
>
> 호기롭게 시작한 문제인데 분류부터 구상, 심지어 개념을 보고 푼 코드까지 전부 틀렸다... 흑흑... 그리디는 쉽게 어떻게 해야할지 떠오르지 않아서 문제인데... 많이 풀어보면서 그리디한 포인트를 캐치하는 감각을 늘려야겠다..!
