# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, M;

vector<int> weights, DP;

void make_dp()
{
    DP.resize(40001, -1);
    for (int i=0; i<N; ++i) {
        for (int j=1; j<=40000; ++j) {
            if (DP[j] != -1 && DP[j] != i && j + weights[i] <= 40000 && DP[j + weights[i]] == -1) {
                DP[j + weights[i]] = i;
                // cout << j + weights[i] << " ";
            }
        }
        DP[weights[i]] = i;
    }
    // cout << "\n";
    
    for (int i=0; i<N; ++i) {
        for (int j=1; j<=40000; ++j) {
            if (DP[j] != -1 && DP[j] != i + 31 && j - weights[i] > 0 && DP[j - weights[i]] == -1) {
                DP[j - weights[i]] = i + 31;
                // cout << j - weights[i] << " ";
            }
        }
    }
    // cout << "\n";
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    weights.resize(N);
    for (int i=0; i<N; ++i) {
        cin >> weights[i];
    }
    
    make_dp();
    int num;
    cin >> M;
    for (int i=0; i<M; ++i) {
        cin >> num;
        if (DP[num] != -1) cout << "Y ";
        else cout << "N ";
    }
    
    return 0;
}

```

> - ## 문제
>
>   양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.
>
>   무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.
>
>   구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.
>
>   ![img](https://upload.acmicpc.net/ce5b29f5-9e03-473b-97db-ce9fd740fde2/-/preview/)
>
>   <그림 1> 구슬이 3g인지 확인하는 방법 (1$\boxed{1}$은 1g인 추, 4$\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)
> 
>   <그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.
> 
>  추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.
> 
>  ![img](https://upload.acmicpc.net/883fb22a-7516-46e1-937d-2ddc4df94572/-/preview/)
> 
>  <그림 2> 구슬이 5g인지 확인하는 방법
> 
>  ## 입력
> 
>  첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.
> 
>  ## 출력
> 
>  주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.
> 
>## 해설
> 
>처음 문제를 봤을때 단순히 브루트포스로 하면 30개의 추에서 발생할 수 있는 모든 조합을 찾아야하기 때문에 시간초과가 날것 같았다. 
> 
> 고민 중에 이전에 동전을 사용해서 값을 맞추는 문제가 생각났다. 이는 DP로 문제를 풀었으며 순서대로 현재 기록된 동전에 현재 동전의 값을 더한 값을 기록하고 현재 동전의 값을 나중에 기록하였다. 
>
> 위와 같은 방식으로 접근은 하되, 추를 구슬이 있는 곳에 두는 것은 현재 추의 무게를 빼는 것과 다름이 없으므로 빼기 연산까지 동일한 방법으로 한번 더 실행하기로 했다.
>
> > 1. 구슬의 최대 크기가 4만이므로 40001의 크기를 가진 1차원 배열 DP를 선언한다.
>> 2. 주어지는 추들을 순서대로 순회한다.
> >    - 현재 DP에 체크되어 있는 값을 확인하여 만약 만들 수 있는 경우라고 체크되어있다면 해당 값에 현재 추값을 더한다.
> >      - 이때, 현재 추를 더해서 만든 경우는 배제한다. 추는 단 1번밖에 사용할 수 없고, 현재 추를 더해서 만드는 경우를 체크하면 만약 무게가 1인 추가 있을 시 모든 경우의 수가 만들어 진다고 체크한다.
> >      - 이를 위해서 현재 순회중인 추의 인덱스 값을 DP에 기록하여 현재 추의 인덱스 값으로 체크되어있으면 넘어갔다.
> >    - 1~40000까지의 모든 경우를 체크했으면 현재 추의 무게를 현재 추의 인덱스 번호로 체크해둔다.
> > 3. 더하는 연산이 모두 끝나면 해당 DP를 가지고 빼기 연산을 진행한다. 이를 위해 다시 주어지는 추들을 순서대로 순회한다.
> >    - 현재 DP에 체크되어 있는 값을 확인하여 만약 만들 수 있는 경우라고 체크되어있다면 해당 값에 현재 추 값을 뺀다.
> >      - 이때, 위의 덧셈연산과 마찬가지로 현재 추의 무게를 빼서 만든 경우는 배제한다. 이를 위해 현재 추의 인덱스 값에 + 31(추의 최대 개수가 30개 이기 때문)을 하여 해당 값으로 기록해두었다. 만약 현재 추의 인덱스 값 + 31의 값으로 체크되어있다면 해당 경우는 넘어간다.
> >    - 덧셈과 달리 모든 경우를 체크한 후에 추가적인 기록은 하지않는다.
> > 4. 이제 주어지는 구슬의 무게를 순서대로 받아 DP에 해당값이 기록되어 있는지 판단하여 Y 또는 N을 출력해주었다.
> 
> 의외로 금방 구상해서 문제를 풀었다. 아무래도 기존에 비슷한 문제를 풀었던 경험이 크게 도움이 된 것 같다! 역시 다양한 문제를 많이 푸는 것이 알고리즘 실력 향상에 도움이 되는것 같다!

