# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

int N;
long long INF = pow(2, 31);
vector<pair<int, int> > process_size;
// 각 구간 별 곱셈 연산의 최솟값을 저장하기 위한 2차원 DP
vector<vector<long long> > dp(501, vector<long long>(501, INF)); 

long long make_dp(int start, int end)
{
    // 인덱스 값이 똑같으면 구간이 없으므로 0 반환
    if (start == end) {
        return 0;
    }
    
    // 이미 계산된 구간이라면 계산된 값을 반환
    if (dp[start][end] != INF) {
        return dp[start][end];
    }
    
    // 주어진 범위안에서 모든 경우의 범위들을 연산하여 최솟값을 구해 DP에 저장
    for (int i=start; i<end; ++i) {
        dp[start][end] = min(dp[start][end], make_dp(start, i) + make_dp(i+1, end) + (process_size[start].first * process_size[i].second * process_size[end].second));
    }
    
    // 현재 구간의 최솟값을 반환
    return dp[start][end];
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N;
    int s, e;
    
    for (int i=0; i<N; ++i) {
        cin >> s >> e;
        process_size.push_back({s, e});
    }
    
    // 주어진 배열을 저장한 벡터의 첫 인덱스와 끝 인덱스 값을 넣어 해당 구간의 최솟값을 출력한다.
    cout << make_dp(0, N - 1);
    
    return 0;
}

```



# 해설

> ## 문제
>
> 크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.
>
> 예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.
>
> - AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.
> - BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.
>
> 같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.
>
> 행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.
>
> ## 입력
>
> 첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.
>
> 둘째 줄부터 N개 줄에는 행렬의 크기 r과 c가 주어진다. (1 ≤ r, c ≤ 500)
>
> 항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.
>
> ## 해설
>
> 처음 봤을 때는 재귀를 이용해서 현재 위치에서 그냥 더한다, 다음것을 더한다음 현재 위치에 더한다라는 방식으로 풀려고 했는데 이는 시간초과가 났다 (2^500 이라 그런가보다)
>
> 그래서 어떻게 연산을 하던 결국에는 처음 배열의 첫째값과 현재 배열의 뒤값으로 배열의 크기가 저장이 된다고 생각해서 그 사이에 있는 최솟값만 기록해놓고뒤에 수랑 연산 하면 되지않을까? 라는 접근으로 1차원 DP를 이용해 계산하려고 했다
>
> 그러나
>
> ```
> 0((1, 2)(3,4))(5,6)
> ```
>
> 이런 방식으로 연산이 진행되니 1차원 DP에 저장해서 해당 값을 구하는게 너무 어려웠다. 이걸 알아내는 대에도 너무 오랜 시간이 걸렸고 이것 또한 다른 사람의 문제풀이를 보다가 알게된 사실이다.
>
> 따라서 이를 해결하기위해 2차원 DP를 이용하여 각각의 구간에서 발생하는 최솟값을 기록해둔다! `(구간 시작 위치, 구간 끝나는 위치)`
>
> 이렇게 하면 어떤 구간을 구하던, 빠르게 구간안에 최솟값을 구할 수 있고, 괄호 안의 괄호 같은 연산 또한 최솟값이 기록되어 있다는 것은 해당 괄호안의 괄호 또한 연산이 된 상태로 최솟값을 구한다는 이야기이기 때문에 충분히 가능했다!
>
> 처음 접근에 너무 1차원 적으로 생각했다고 느껴졌다. 문제를 좀 더 잘 봤으면... 괄호 안의 괄호 같은 반례를 쉽게 알 수 있었을 텐데 좀 아쉽다! 게다가 혼자 못 푼 문제라서 좀 더 연습이 필요하다고 생각한다!
