# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, a, b, d;

int bugs_life()
{
    vector<int> DP(N+1, 0), born_bug(N+1, 0);
    DP[0] = 1; born_bug[0] = 1;
    for (int i=1; i<=N; ++i) {
        // 태어난지 a일이 됬고 b일이 되지 않은 개체는 번식한다.
        DP[i] = DP[i - 1]; born_bug[i] = born_bug[i - 1];
        if (i - a >= 0) {
            if (i - b < 0) {
                born_bug[i] += born_bug[i - a];
            }
            else {
                int tmp_bug = born_bug[i - a] - born_bug[i - b];
                if (tmp_bug < 0) tmp_bug += 1000;
                born_bug[i] += tmp_bug;
            }
            DP[i] += born_bug[i] - born_bug[i - 1];
            if (DP[i] < 0) DP[i] += 1000;
        }
        
        if (i - d >= 0) {
            if (i - d == 0) {
                DP[i] -= born_bug[0];
            }
            else {
                int tmp_die_bug = born_bug[i - d] - born_bug[i - d - 1];
                if (tmp_die_bug < 0) tmp_die_bug += 1000;
                DP[i] -= tmp_die_bug;
            }
            if (DP[i] < 0) DP[i] += 1000;
        }
        
        born_bug[i] %= 1000;
        DP[i] %= 1000;
    }
    
    return DP[N];
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> a >> b >> d >> N;
    
    cout << bugs_life();
    
    return 0;
}

```

> ## 문제
>
> 한 생물학자가 새로 발견된 짚신벌레 종의 생태에 대해 연구하고 있다. 매우 번식력이 강하다고 알려진 이 종은 아래와 같은 특징을 가지고 있다.
>
> 무성 생식을 한다.
>
> - 태어난 이후 a일째 되는 날 성체가 된다.
> - 성체가 된 날부터 매일 한 마리씩 새로운 개체를 만들어낸다: 성체가 되자마자 첫 개체를 만들어내고, 그 이후로 하루가 지날 때마다 새로운 개체를 하나씩 만들어낸다. 새로운 개체 역시 태어난 이후로 a일째 되는 날부터 성체가 되어 새로운 개체를 만든다.
> - 태어난 이후로 b일째 되는 순간부터는 새로운 개체를 더 이상 만들지 않는다. 태어난 지 a일째 날부터 b일째 되는 날의 전날까지 새로운 개체를 만들어내므로 일생동안 총 b-a 마리의 개체를 만들어낸다.
> - 태어난 이후로 d일째 되는 순간 죽는다.
>
> 아래는 a=2, b=4, d=6일 때 수조에 새로 태어난 짚신벌레 한 마리를 넣고 매일 관찰한 결과를 기록한 것이다. 괄호 안의 숫자들은 수조 안의 짚신벌레들이 각각 태어난 이후 며칠이 되었는지를 나타내는 정수이다.
>
> - 태어난 날: (0) - 새로운 개체를 집어넣음
> - 1일째 되는 날: (1) - 짚신벌레가 자람
> - 2일째 되는 날: (2, 0) - 짚신벌레가 태어난 지 2일째가 되므로 성체가 되고 새 개체를 만들어 냄
> - 3일째 되는 날: (3, 1, 0) - 2일째 성체가 된 짚신벌레가 오늘도 새 개체를 하나 만들어 냄
> - 4일 째 되는 날: (4, 2, 1, 0) - 2일째 되는 날 만들어진 짚신벌레가 새로운 개체를 만들어 냄 (처음에 넣은 짚신벌레는 새 개체를 만들어내지 못함)
> - 5일 째 되는 날: (5, 3, 2, 1, 0, 0)
> - 6일 째 되는 날: (4, 3, 2, 1, 1, 0, 0) - 처음에 넣은 개체는 죽는다.
>
> 6일 째 되는 날 수조안에 살아있는 짚신벌레는 총 7마리가 된다.
>
> 짚신벌레의 번식 정보 a, b, d에 대하여, 새로 태어난 짚신벌레 한 마리를 수조 안에 넣은 이후 N일째 되는 날 살아있는 짚신벌레 수를 1000으로 나눈 나머지를 출력하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 a, b, d, N을 나타내는 네 정수가 빈칸 하나를 사이에 두고 차례로 주어진다. 단, 0＜a＜b＜d ≤ 10,000이고, 1 ≤ N ≤ 1,000,000이다.
>
> ## 출력
>
> 첫째 줄에, 수조에 짚신벌레 한 마리를 넣은 지 N일째 되는 날 수조에 살아 있는 짚신벌레의 수를 1000으로 나눈 나머지를 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을 때 DP를 떠올렸다. 2개의 1차원 DP를 두어 일별의 짚신벌레의 수를 기록할 DP 하나, 일별 새롭게 태어난 짚신벌레의 수를 기록할 DP를 하나 만드려고 했다. 그러나 코드를 작성하다보니 일별 새롭게 태어난 짚신벌레의 수를 알아내려면 `(현재 일수 - 번식이 가능한 일수(a)) - (현재 일수 - 번식이 끝나는 일수(b))`사이의 모든 짚신벌레의 수를 알아야하는데 100만일 동안 a=1, b=10000이라면 그 연산 횟수가 무지막지하게 늘어날 것이라고 생각이 들었다. 이를 해결하기 위해 누적합을 이용하기로 했다.
>
> > 1. 0일차에 반드시 짚신벌레 1마리가 태어난다. DP[0] = 1, born_bug[0] = 1;
> >
> > 2. 1일차부터 N일차까지 순회한다. 
> >
> >    > 1. 먼저 누적합을 하기위해 현재 일차 born_bug[i]에 이전 일차의 born_bug[i-1]를 그대로 가져온다.
> >    >
> >    >    그리고 DP[i]에 DP[i-1]을 가져와 이후 벌레의 갱신을 처리하여 반영한다.
> >    >
> >    > 2. 현재 일차가 만약 번식이 가능한 시간대라면 먼저 현재 일차가 번식이 불가능해지는 일차 이후인지 확인한다.
> >    >
> >    >    - 만약 번식이 불가능해지는 일차(b) 보다 낮은 일차라면 현재까지 태어난지 a일이 넘은 모든 벌레들이 번식하므로 `born_bug[i] += born_bug[i - a];`를 한다.
> >    >
> >    >    - 만약 번식이 불가능해지는 일차(b)를 넘어선 일차라면 현재까지 태어난지 a일이 넘은 모든 벌레들 중 현재부터 b일이 지난 모든 벌레들의 수를 뺀 값만큼 born_bug[i]에 더한다.
> >    >
> >    >      ```c++
> >    >      // born_bug[i - a] = 번식이 가능한 나이를 지난 모든 벌레 수
> >    >      // born_bug[i - b] = 번식이 가능했으나 이제 번식이 불가능해진 벌레의 수
> >    >      born_bug[i - a] - born_bug[i - b];
> >    >      ```
> >    >
> >    >      - 만약 이때 구한 값 `born_bug[i - a] - born_bug[i - b];`이 음수인 경우가 발생할 수 있다. (기록하는 값을 1000으로 나누어 기록하고 있기 때문에 1001 - 850이 1 - 850이 되기 때문) 그렇다면 계산한 값 `born_bug[i - a] - born_bug[i - b];`에 +1000을하여 값을 고친다.
> >    >
> >    > 3. 오늘 태어난 벌레의 수를 DP[i]에 더한다.
> >    >
> >    >    - 오늘 태어난 벌레의 수를 구하는 방법은
> >    >
> >    >      ```c++
> >    >      born_bug[i] - born_bug[i - 1]
> >    >      ```
> >    >
> >    >      이다.
> >    >
> >    >    - 만약 이때 구한 값 `born_bug[i] - born_bug[i - 1];`이 음수인 경우가 발생할 수 있다. (기록하는 값을 1000으로 나누어 기록하고 있기 때문에 1001 - 850이 1 - 850이 되기 때문) 그렇다면 계산한 값 `born_bug[i] - born_bug[i - 1];`에 +1000을하여 값을 고친다.
> >    >
> >    >    - 위에서 구한 값을 DP[i]에 다한다.
> >    >
> >    > 4. 3번이 끝났으면 현재 일자에서 죽는 벌레가 있는지 확인한다.
> >    >
> >    >    - 만약 벌레들의 수명이 다하는 일자 d를 넘어서지 않았다면 넘어간다.
> >    >
> >    >    - 만약 벌레들의 수명이 다하는 일자 d를 넘어서지 않았다면 넘어섰다면 현재 일자로 부터 d일 전에 태어난 벌레들의 수만큼 DP[i]에서 뺀다.
> >    >
> >    >      ```c++
> >    >      // born_bug[i - d] = i - d 일까지 태어난 모든 벌레들의 수
> >    >      // born_bug[i - d - 1] = i - d - 1일까지 태어난 모든 벌레들의 수
> >    >      // born_bug[i - d] - born_bug[i - d - 1] = 현재 일자로 부터 d일 전에 태어난 벌레들의 수
> >    >      born_bug[i - d] - born_bug[i - d - 1];
> >    >      ```
> >    >
> >    >    - 만약 이때 구한 값 `born_bug[i - d] - born_bug[i - d - 1];`이 음수인 경우가 발생할 수 있다. (기록하는 값을 1000으로 나누어 기록하고 있기 때문에 1001 - 850이 1 - 850이 되기 때문) 그렇다면 계산한 값 `born_bug[i - d] - born_bug[i - d - 1];`에 +1000을하여 값을 고친다.
> >    >
> >    > 5. 4번에서 구한 죽은 벌레의 수를 DP[i]에서 뺀다.
> >    >
> >    > 6. 문제의 조건에서 1000으로 나눈 나머지의 값을 구하라 했으므로 모든 작업이 끝나면 DP[i]와 born_bug[i]에 % 1000을 해주고 다음 일자로 넘어간다.
> >
> > 3. 2의 순회가 모두 끝나면 DP[N]에 기록된 값을 반환한다.
>
> 위와 같은 방식으로 문제를 풀었다. 로직은 바로 떠올렸는데, 1000의 나머지를 기록하면서 음수가 나타나는 것을 관리하지 못해 여러번 틀렸다. 누적합에서 해당 위치의 값을 구한다고 뺄셈을 사용하기로 했을때 문제가 발생할 수 있음을 바로 생각했어야 했는데 그러지 못한게 좀 아쉽다 ㅠㅠ 떠올리고 나서도 뺄셈 연산 모두에 +1000의 보정을 넣었어야했는데 하나씩 넣어서 여러번 틀렸다... 음... 로직을 생각하면 어디에 모두 적용해야하는지 명확하게 생각해보고 코드를 수정하면 실수가 줄어들지 않을까... 생각한다... 더 정진하자!
