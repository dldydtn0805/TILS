# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);

    cin >> N;
    int num;
    vector<int> rope;
    
    for (int i=0; i<N; ++i) {
        cin >> num;
        rope.push_back(num);
    }
    
    int result = 0, cnt = 0;
    sort(rope.begin(), rope.end(), greater<int>());
    
    for (int a : rope) {
        cnt++;
        int tmp = cnt * a;
        if (tmp > result) {
            result = tmp;
        }
    }
    
    cout << result;

    return 0;
}

```



> ## 문제
>
> N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.
>
> 하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.
>
> 각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.
>
> ## 입력
>
> 첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.
> 
> ## 해설
> 
> 문제를 처음 보았을때 중량이 모든 로프에 대해 똑같이 나누어서 주어지기 때문에 만약 n개의 로프로 무게가 m인 물체를 들려면 로프들은 최소 m/n의 힘을 버틸 수 있어야한다고 생각했다. 즉, 주어지는 로프의 값을 내림차순으로 정렬한 후, 처음부터 한개씩 집으면서 내려간다 그러면 `현재 집은 로프 수 * 가장 낮은 무게의 로프`가 현재 로프의 구성 중 가장 버틸 수 있는 큰 무게가 된다. 이를 계속해서 전체를 순회할 때까지 반복한다. 그 중 최댓값을 구하여 출력하면 된다고 생각했다. 위와 같은 접근으로 제출하니 정답을 받았다!
> 
> 문제를 제출하고 나니 현재 값 이하로 떨어지는 시점에서 멈추어도 괜찮지 않았나 싶었다. 그렇게 하면 굳이 모든 값을 순회하지 않아도 되니 시간적으로 절약될 것 같았다!
