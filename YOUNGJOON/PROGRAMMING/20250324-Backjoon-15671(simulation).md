# 코드

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int N;
vector<vector<char> > board(6, vector<char>(6, '.'));
int white_cnt = 2, black_cnt = 2;

vector<pair<int, int> > directions = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};

bool change_pawn(int x, int y, int dir, char now_color)
{
    if (board[x][y] == now_color) {
        return true;
    }
    else if (board[x][y] != '.' && board[x][y] != now_color) {
        int nx = x + directions[dir].first; int ny = y + directions[dir].second;
        if (0 <= nx && nx < 6 && 0 <= ny && ny < 6) {
            bool is_paint = change_pawn(nx, ny, dir, now_color);
            if (is_paint == true) {
                board[x][y] = now_color;
                if (now_color == 'W') {
                    white_cnt++;
                    black_cnt--;
                }
                else {
                    white_cnt--;
                    black_cnt++;
                }
                return true;
            }
        }
        return false;
    }
    else {
        return false;
    }
}

void print_answer()
{
    for (int i=0; i<6; ++i) {
        for (int j=0; j<6; ++j) {
            cout << board[i][j];
        }
        cout << "\n";
    }
    
    if (white_cnt > black_cnt) {
        cout << "White";
    }
    else {
        cout << "Black";
    }
}


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    board[2][2] = board[3][3] = 'W';
    board[2][3] = board[3][2] = 'B';
    
    cin >> N;
    int x, y;
    int color = 0;
    char now_color;
    for (int i=0; i<N; ++i) {
        cin >> x >> y;
        if (color == 0) now_color = 'B';
        else now_color = 'W';
        bool is_set = false;
        for (int j=0; j<8; ++j) {
            int nx = x - 1 + directions[j].first;
            int ny = y - 1 + directions[j].second;
            if (0 <= nx && nx < 6 && 0 <= ny && ny < 6) {
                bool is_ok = change_pawn(nx, ny, j, now_color);
                if (is_ok == true && is_set == false) {
                    is_set = true;
                }
            }
        }
        board[x - 1][y - 1] = now_color;
        color = (color + 1) % 2;
    }
    
    print_answer();
    
    return 0;
}
```



> ## 문제
>
> 오델로(Othello)는 검은색, 또는 하얀색 작은 원판을 6x6의 판 위에 늘어놓는 보드 게임이다. 보통 일본에서는 オセロ(오세로), 국내에서는 오델로라 부르고 있다. 어원은 오셀로 희곡으로 오셀로의 '이중성' 또는 오셀로와 데스데모나가 이루는 '흑백'의 대비를 모티브로 삼았다고 한다. 현재 독보적으로 활성화 되어있는 일본을 비롯하여 매년 여러 국가에서 정기 대회가 열리고 있으며 주요 대회로는 세계 오델로 챔피언십(이하 세계대회), 일본 명인전과 전일본 챔피언십, 왕좌전, 유럽 그랑프리 등이 있다. [출처 : 나무위키]
>
> 위는 남규가 교양 수업 과제로 낸 리포트 일부이다. 이 리포트를 받은 교수님은 화가 나서, 남규에게 오델로 대전을 신청했다. 남규는 오델로가 무엇인지 아직 모르기 때문에 규칙을 인터넷에서 찾아보았다.
>
> - 처음에 판 가운데에 사각형으로 엇갈리게 배치된 돌 4개를 놓고 시작한다.
> - 돌은 반드시 상대방 돌을 양쪽에서 포위하여 뒤집을 수 있는 곳에 놓아야 한다.
> - 돌을 뒤집을 곳이 없는 경우에는 차례가 자동적으로 상대방에게 넘어가게 된다.
> - 아래와 같은 조건에 의해 양쪽 모두 더 이상 돌을 놓을 수 없게 되면 게임이 끝나게 된다.
>   - 36개의 돌 모두가 판에 가득 찬 경우 (가장 일반적)
>   - 어느 한 쪽이 돌을 모두 뒤집은 경우
>   - 한 차례에 양 쪽 모두 서로 차례를 넘겨야 하는 경우
> - 게임이 끝났을 때 돌이 많이 있는 플레이어가 승자가 된다. 만일 돌의 개수가 같을 경우는 무승부가 된다.
>
> [출처 : 위키백과]
>
> 그림으로 설명하면 아래와 같다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15671/1.png)
>
> 위와 같은 상태의 게임판에서 시작하여, 검은 돌부터 차례를 이어나간다. 파랗게 표시한 부분은 검은 돌을 놓을 수 있는 영역(최소 하나의 하얀 돌을 검은 돌 두 개 사이에 넣을 수 있는 곳)이며, 빨갛게 표시한 부분은 검은 돌을 놓을 수 없는 영역의 예시이다.
>
> 만약 검은 돌이 좌측 상단의 두 파란 영역 중 하나에 돌을 놓는다면, 위에서 세 번째 줄, 왼쪽에서 세 번째 줄에 놓인 하얀 돌이 검은색 돌에 포위되므로 검은색으로 변하게 되며, 우측 하단의 두 영역 중 하나에 돌을 놓는다면 아래에서 세 번째, 오른쪽에서 세 번째에 놓인 하얀 돌이 검은색으로 변하게 된다.
>
> 이때, 상대 돌을 포위하는 것은 가로, 세로, 대각선 8방향 모두에서 이루어질 수 있으며, 반드시 하나의 돌만을 감싸야 하는 것은 아니다. 예시를 들면 아래와 같다.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15671/2.png)
>
> 만약 검은 돌이 파란 위치에 돌을 놓는다면, 내부에 O 표시가 있는 모든 하얀 돌은 양 끝이 검은 돌로 막혔으므로 검은색으로 변하게 된다. X 표시가 있는 두 하얀 돌은 양 끝이 직접 막히지 않았으므로 변하지 않는다.
>
> 이처럼 검은 돌부터 시작해 차례를 번갈아가며 한 수씩 두게 된다. 그 외의 세부 규칙은 상단에서 보았던 규칙(출처:위키백과)을 참고한다.
>
> 남규는 규칙을 모두 공부한 뒤 교수님과 오델로 대전을 진행하였고, 다행히도 규칙에 맞는 플레이를 하긴 했다. 하지만 모두 패배한 남규는 F학점을 받을 위기에 처했고, 교수님은 며칠 뒤 다시 한 번 기회를 주겠다고 선언하였다.
>
> 남규는 우선 오늘의 플레이 기록을 복기하며 어느 부분이 문제였는지 알아보려 한다. 하지만 남규는 돌을 둔 위치만을 기억할 뿐, 게임판이 어떻게 생겼는지는 기억하지 못한다. 남규를 위해, 게임의 진행 과정에서 돌을 둔 위치가 모두 주어지면, 게임판의 최종 상태와 승자를 찾아보도록 하자.
>
> ## 입력
>
> 첫 줄에 게임 로그의 수 N이 주어진다. (1 ≤ N ≤ 32)
>
> 이어 N줄에 걸쳐, 돌을 둔 위치 R C가 주어진다. 이는 돌을 R행 C열에 놓았다는 의미이다. 행은 위부터 순서대로 1, 2, 3, … 으로 번호를 매기며, 열은 왼쪽부터 순서대로 1, 2, 3, ... 으로 번호를 매긴다. 둘 중 한 명이 돌을 둘 수 없어 턴을 넘기는 경우가 생기는 게임은 입력으로 주어지지 않는다.
>
> 입력으로 주어지는 게임 로그는 항상 올바른 게임 로그임이 보장된다.
>
> 초기 게임판의 형태는 항상 (3,3), (4,4)에 백돌 두 개가, (3,4), (4,3)에 흑돌 두 개가 올려져 있는 상태이며, 흑돌이 선을 잡는다.
>
> ## 출력
>
> 1행 ~ 6행 : 행마다 6글자로, 6*6 격자 형태로 게임판의 최종 상태를 출력한다. 빈 칸은 ‘.’ (ASCII 46), 검은 돌은 ‘B’ (ASCII 66), 하얀 돌은 ‘W’ (ASCII 87) 로 출력한다.
>
> 7행 : 검은 돌을 잡은 플레이어가 승리했다면 Black을, 아니라면 White를 출력한다. 비기는 경우가 없는 입력만 주어진다.
>
> ## 해설
>
> 처음 문제를 봤을 때 주어진 조건을 그대로 구현하면 된다고 생각했다. 문제에서 반드시 올바른 게임 로그임을 보장해준다고 하였고 선턴은 `'B'`가 잡는다고 하였다. 따라서 그냥 주어지는 로그대로 오델로 게임을 진행만 하면 되었다.
>
> > 1. 주어지는 말들의 위치를 'B'부터 차례대로 돌아가며 해당 위치에 돌을 놓는다.
> > 2. 해당 위치에서 8방향으로 순회하여 해당 방향에 오셀로의 조건 (현재 위치에서 반대편 돌들을 지나 같은 색 돌이 있는가)을 확인하고 조건이 맞는 모든 말들을 뒤집고 개수를 갱신한다.
> > 3. 모든 방향을 순회하면 현재 위치에 말을 두고 말의 개수를 갱신한다.
>
> 위와 같이 진행하였는데, 코드에서는 오셀로의 조건이 만족하여 로그에서 주어진 위치에 돌을 둘 수 있는가? 까지 따져서 넣었는데 무조건 에러가 없는 로그만 주어진다고 하였으니 사실상 해당 코드도 필요가 없었을 것이다.
>
> 중간에 모든 색깔이 W 가되는 이상한 경우가 발생해서 코드를 살펴보니 color를 바꾸는 코드가 `color + 1 % 2`였다. 아아.. 그렇다 사칙연산의 순서... 제발 이런 이상한 실수가 줄어야한다.. 코드 하나하나 정성스럽게 적어 내려가는 습관을 기르자....
