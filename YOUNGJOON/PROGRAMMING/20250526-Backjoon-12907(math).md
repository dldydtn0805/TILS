# 코드

```c++
#include <iostream>
#include <vector>
#include <set>
#include <unordered_map>

using namespace std;

int N;
set<int> numbers;
unordered_map<int, int> num_cnt;

int meowmeow()
{
    int cnt = 1, previous = -1;
    num_cnt[-1] = num_cnt[0];
    
    for (int a : numbers) {
        if (a == previous + 1) {
            if (num_cnt[a] > 0 && num_cnt[a] <= 2 && num_cnt[previous] >= num_cnt[a]) {
                cnt *= num_cnt[previous];
            }
            else {
                return 0;
            }
            previous = a;
        }
        else {
            return 0;
        }
    }
    
    if (num_cnt[0] == 1) {
        cnt *= 2;
    }
    
    return cnt;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    int num;
    for (int i=0; i<N; ++i) {
        cin >> num;
        numbers.insert(num);
        num_cnt[num]++;
    }
    
    cout << meowmeow();

    return 0;
}

```

> ## 문제
>
> 동물원에 동물이 N마리 있고, 1번부터 N번가지 번호가 매겨져 있다. 이 동물원에 동물은 토끼나 고양이밖에 없고, 모든 동물의 키는 다 다르다.
>
> 수빈이는 토끼와 고양이를 구분할 수 없지만, 토끼와 고양이와 대화를 할 수 있다!
>
> 수빈이는 모든 동물에게 다음과 같은 질문을 했다.
>
> "너랑 같은 동물 중에서 너보다 키가 큰 동물은 몇 마리야?"
> 
> 모든 토끼는 자신보다 키가 큰 토끼의 수를 말해줬고, 모든 고양이도 자신보다 키가 큰 고양이의 수를 말해줬다.
> 
> 모든 동물의 대답이 주어졌을 때, 각 대답을 어떤 동물이 했는지 알아내려고 한다. 가능한 조합의 수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 동물의 수 N (1 ≤ N ≤ 40)이 주어진다.
>
> 둘째 줄에는 각 동물의 대답이 주어진다. 대답은 0보다 크거나 같고, 40보다 작거나 같은 정수이다.
> 
> ## 출력
> 
> 첫째 줄에 가능한 조합의 수를 출력한다.
> 
>## 해설
> 
>처음 문제를 봤을 때 경우의 수를 떠올렸다.
> 
> 예제를 좀 살펴보니 뭔가 규칙이 느껴졌다.
> 
> > 1. 모든 숫자는 3개 이상 중복되면 안된다 = 동물의 종류가 2종이기 때문
> >
> > 2. 숫자가 1개라면 고양이 or 토끼를 배치할 수 있기 때문에 2가지 경우의 수가 나오고,
>>
> >    숫자가 2개라면 {고양이, 토끼}, {토끼, 고양이} 와 같이 2가지 경우의 수가 나온다고 생각했다. (단, 숫자가 1개인 경우는 앞의 숫자가 몇개인지에 따라 달라질 수 있다 이는 3번 규칙)
>>
> > 3. 현재 숫자가 1개인데 앞의 숫자가 2개 있다면 2가지 중 한 곳에 붙을 수 있다. 만약 1개라면 1개만 붙을 수 있다 즉, 앞의 숫자의 개수에 따라서 경우의 수의 개수가 정해진다.
> >
> > 4. 숫자가 연속되지 않게 나오면 안된다. (키가 모두 다르다는 가정이 있기 때문에 순서대로만 가능)
> 
> 위의 규칙들을 이용하여 코드를 짰다.
> 
>> 1. 주어지는 숫자들을 set에 담는다 (set는 자동으로 오름차순으로 정렬해주고 중복을 없애주어서 채용).
> >
>>    이때 숫자들의 개수는 unordered_map을 통해 기록해둔다.
> >
> > 2. 현재 경우의 수의 개수를 기록하는 cnt를 1로 선언하고, 이전의 숫자를 기록하는 previous를 -1로 선언한다.
> >
> > 3. set에 있는 모든 숫자를 순회한다.
> >
> >    > 1. 현재 숫자가 previous에 적힌 숫자보다 1 높은지 확인한다. 
>>    >    - 만약 아니라면 잘못된 경우로 0을 반환하여 탈출한다.
> >    > 2. 현재 숫자의 개수가 이전 숫자의 개수보다 작거나 같은지 확인한다
>>    >    - 만약 이전 숫자의 개수가 현재 숫자의 개수보다 작으면 1 -> 2의 경우이므로 이는 발생할 수 없는 경우로 0을 반환하여 탈출한다.
> >    > 3. 1, 2를 모두 통과했다면 현재 경우의 수의 개수를 기록하는 cnt에 이전 숫자의 개수만큼 곱해준다
> >    >    - 이전 숫자의 개수에 따라 경우의 수의 개수가 정해진다는 위 3번의 규칙을 적용한 것이다.
> >    > 4. 현재 숫자를 previous에 저장한다.
> >    > 5. set의 모든 숫자를 순회한 후, 만약 처음 0의 개수가 1개 였다면 끝까지 진행되었다는 가정하에 한 종류의 동물만 사용하는 경우로 체크되었을 것이므로 위의 2번 규칙의 고양이 or 토끼를 배치할 수 있는 2가지의 경우의 수가 나온다는 규칙에 따라 cnt에 * 2를 해준다.
> >
> > 4. set를 순회하여 얻은 숫자를 출력한다.
>
> 동물의 종류가 2개라는 점과 예제에서 보이는 몇가지 규칙 때문에 문제를 풀 수 있었다.
>
> 규칙이 있다는 감은 계속 왔지만 의외로 코드로 만들기 까지의 확신은 잘 안와서 여러가지 반례를 직접 손으로 그려서 코드를 구상할 수 있을때까지 생각해보았다... 풀고 나서 알고리즘을 보니 수학, 많은 조건분기, 조합론이었는데 많은 조건 분기를 통해 푼거라고 생각한다! 이렇게 손으로 직접 그려보면서 풀어가는것도 꽤 도움이 많이 되는것 같다!
