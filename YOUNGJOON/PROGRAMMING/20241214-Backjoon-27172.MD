# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

int N;
vector<int> numbers;
vector<int> number_score(1000001, 0);

unordered_map<int, int> check_num;

void run_battle()
{
    for (int a : numbers) {
        int power = 2;
        
        while (a * power <= 1000000) {
            if (check_num.find(a * power) != check_num.end()) {
                number_score[a]++;
                number_score[a * power]--;
            }
            power++;
        }
    }
    
    for (int a : numbers) {
        cout << number_score[a] << " ";
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N;
    cin.ignore();
    
    string data;
    int num;
    
    getline(cin, data);
    istringstream iss(data);
    while (iss >> num) {
        numbers.push_back(num);
        check_num[num] = 1;
    }
    
    run_battle();

    return 0;
}

```



# 해설

> ## 문제
>
> 《보드게임컵》을 준비하다 지친 은하는 보드게임컵 참가자들을 경기장에 몰아넣고 결투를 시키는 게임 **《수 나누기 게임》**을 만들었습니다.
>
> 《수 나누기 게임》의 규칙은 다음과 같습니다.
>
> - 게임을 시작하기 전 각 플레이어는 1$1$부터 1000000$1\,000\,000$ 사이의 수가 적힌 서로 다른 카드를 잘 섞은 뒤 한 장씩 나눠 가집니다.
> - 매 턴마다 플레이어는 다른 플레이어와 한 번씩 결투를 합니다.
> - 결투는 서로의 카드를 보여주는 방식으로 진행되며, 플레이어의 카드에 적힌 수로 다른 플레이어의 카드에 적힌 수를 나눴을 때, 나머지가 0$0$이면 승리합니다. 플레이어의 카드에 적힌 수가 다른 플레이어의 카드에 적힌 수로 나누어 떨어지면 패배합니다. 둘 다 아니라면 무승부입니다.
> - 승리한 플레이어는 1$1$점을 획득하고, 패배한 플레이어는 1$1$점을 잃습니다. 무승부인 경우 점수의 변화가 없습니다.
> - 본인을 제외한 다른 모든 플레이어와 정확히 한 번씩 결투를 하고 나면 게임이 종료됩니다.
>
> 《수 나누기 게임》의 결과를 가지고 한별이와 내기를 하던 은하는 게임이 종료되기 전에 모든 플레이어의 점수를 미리 알 수 있을지 궁금해졌습니다. 은하를 위해 각 플레이어가 가지고 있는 카드에 적힌 수가 주어졌을 때, 게임이 종료된 후의 모든 플레이어의 점수를 구해주세요.
>
> ## 입력
>
> 첫 번째 줄에 플레이어의 수 N$N$이 주어집니다.
>
> 두 번째 줄에 첫 번째 플레이어부터 N$N$번째 플레이어까지 각 플레이어가 가지고 있는 카드에 적힌 정수 x1$x_{1}$, ⋯$\cdots$, xN$x_{N}$이 공백으로 구분되어 주어집니다.
>
> ## 해설
>
> 처음 문제를 봤을때 일단 당장 브루트포스를 하면 안된다고 생각했다. 따라서 수들의 특징을 좀 생각해보려고 했다.  a가 b를 나누어 떨어질 때 b가 c를 나누어 떨어지면 a는 c를 나누어 떨어지게 할 수 있다는 규칙을 생각했다. (나좀 수학에 도가 텄을지도?) 이를 이용해 처음에는 정렬을 해서 낮은 값부터 해결해나가려고 했으나,
>
> ```
> 3
> 3 4 12
> ```
>
> 위의 예제에서 생각한 대로 풀리지 않았다. 나는 맨 처음 수가 나눌 수 있는 수가 나눌때까지 이동하고 나누어지면 그 자리부터 연산하려고 했는데 4를 지나치게 되므로 내 생각에 문제가 있다는걸 깨달았다. 그래서 순서대로 모두 보자니 그렇다면 N * N 브루트포스와 다른게 무엇인가? 하여 다른 방법으로 생각해보기로 했다.
>
> 현재 수의 배수를 구해야하고, 현재 수의 모든 배수 중 주어진 숫자들 중에 해당 숫자가 있다면 현재 수는 +1점 해당 배수는 -1점을 해줄 거라면 그냥 값이 1~100만까지니까 그걸 배열로 만들어서 기록하면 어떨까? 했다. 마치 소수를 구할때 썼던 에라토스테네스의 체처럼 말이다.
>
> 현재 수가 있는지 없는지를 O(1)의 속도로 판단하고 싶었기 때문에 unordered_map을 이용하여 해당 숫자의 여부를 판단했다.
>
> 그리고 있다면 현재 수는 +1점, 해당 배수는 -1점을 했다. 이를 1000001의 크기를 가진 vector에 인덱스 값을 대상으로 저장했다. 그러니까 정답!
>
> 수학문제는 맨날 맞닥뜨릴때마다 못풀곤 했었는데 풀고보니 수학문제여서 기분이가 좋았다! 사실 풀때 에라토스테네스의 체의 방식이라고 생각하고 푼건 아니었는데 풀고나서 방식이 똑같다는걸 알았다. 게다가 한번에 풀다니! 기분이가 좋다~! 앞으로 이렇게만 가자 
