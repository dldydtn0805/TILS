# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, K;
vector<int> weight, value;

void backpack()
{
    vector<vector<int> > dp(N, vector<int>(K+1, 0));
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<=K; ++j) {
            if (i == 0) {
                if (j >= weight[i]) dp[i][j] = value[i];
            }
            else {
                if (j < weight[i]) dp[i][j] = dp[i-1][j];
                else {
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i]);
                }
            }
        }
    }
    
    cout << dp[N-1][K];
    
    return;
}

int main()
{
    cin >> N >> K;
    
    int w, v;
    for (int i=0; i<N; ++i) {
        cin >> w >> v;
        weight.push_back(w);
        value.push_back(v);
    }

    backpack();

    return 0;
}

```



> ## 문제
>
> 이 문제는 아주 평범한 배낭에 관한 문제이다.
>
> 한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.
>
> 준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.
>
> ## 입력
>
> 첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.
>
> 입력으로 주어지는 모든 수는 정수이다.
>
> ## 해설
>
> 문제에서 친절하게 배낭을 언급하고 있기에 배낭 문제로 예상했고 문제를 싹읽어보니 맞는 것 같았다.
>
> 그래서 배낭문제를 복습할겸 풀어보았다.
>
> > 1. 2차원 배열을 선언한다 (배낭의 최대 무게) * (물건의 개수)
> >
> > 2. N개의 물건들에 대해 배낭의 최대 무게 만큼 순회하며 현재 무게에서 발생할 수 있는 최대 가치를 배열에 기록한다.
> >
> >    2-1. 만약 현재 살펴보는 물건이 들어갈 수 없는 배낭의 무게라면 이전 물건에서 기록된 데이터를 가져온다.
> >
> >    2-2. 만약 현재 살펴보는 물건이 들어갈 수 있는 배낭의 무게라면 이전 물건에서 현재 무게에 기록된 값과 이전 물건에서 현재 무게에서 지금 살펴보는 물건의 무게를 뺀 배낭무게에 기록된 값과 현재 물건의 가치를 더한 값을 비교하여 더 큰 값을 기록한다.
> >
> > 3. 최종적으로 마지막 물건의 최대 무게에 기록된 값이 가장 높은 가치의 구성이다.
>
> 예전에 계속 방법을 떠올리지 못해서 몇번씩 틀렸던 문제인데 그래도 이제 바로 떠올려서 푸는 것 보니까 어느정도 숙달을 한것 같아서 기분이 좋다! 더 정진하도록 하자
