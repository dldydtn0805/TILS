# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>

using namespace std;

int N;
vector<int> numbers, my_num;

int binary_check(int left, int right, int target)
{
    int start = left;
    int end = right;
    
    while (start <= end) {
        int mid = (start + end) / 2;
        
        if (my_num[mid] < target) {
            start = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
    
    return start;
    
}

void LIS()
{
    int my_size = 1;
    my_num.push_back(numbers[0]);
    
    for (int i=1; i<N; ++i) {
        int idx = binary_check(0, my_size - 1, numbers[i]);
        if (idx == my_size) {
            my_size++;
            my_num.push_back(numbers[i]);
        }
        else {
            my_num[idx] = numbers[i];
        }
    }
    
    cout << my_size;
    
}

int main()
{
    cin >> N;
    cin.ignore();
    
    string data;
    int num;
    getline(cin, data);
    istringstream iss(data);
    while (iss >> num) {
        numbers.push_back(num);
    }
    
    LIS();
    
    return 0;
}

```



# 해설

> ## 문제
>
> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> ## 입력
>
> 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.
>
> 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)
>
> ## 해설
>
> 문제 이름이 가장 긴 증가하는 부분 수열 이기 때문에 LIS 알고리즘을 사용해야 한다는 것은 알았다.. 그런데 기존에 내가 사용하던 방식은 **O(N²)**의 시간 복잡도를 가지는 방식이었는데 현재 수열의 크기가 100만이라 100만의 제곱은 무조건 시간초과가 날 것이기 때문에 다른 접근방법을 생각해보기 위하여 LIS 알고리즘을 다시 복습하는 겸 나무위키에서 알고리즘 진행 방식을 확인했다가 스포당했다!
>
> 기존의 LIS 알고리즘은 N개의 수에 대하여 N개의 배열을 만든다. 그리고 N개의 수를 순서대로 확인한다. 현재 수에서 이전에 나왔던 수들을 전부 확인하고 자신보다 작은 수에서 가장 이전에 수가 많은 숫자를 선택하여 해당 값에 +1하여 자신에 기록한다. 이러한 방식으로 진행하면, **O(N²)**의 시간으로 LIS를 구할 수 있다.
>
> > 현재 수 : 3 4 5 6 2 1
> >
> > 기록 값 : 1 2 3 4 1 1
>
> 위의 알고리즘이 기존에 내가 알던 LIS 알고리즘 이다. 그러니 이 알고리즘을 좀 더 최적화하여야 이번 문제를 풀 수 있었다.
>
> 최적화하는 방법은 이분 탐색을 이용하는 것이다. 현재 순회 중인 수가 들어갈 자리를 이분 탐색으로 찾아내 해당 위치에 넣어 주는 방식이다.
>
> 그렇다면 모든 수 N과 현재 탐색이 된 수 들의 배열을 이분탐색으로 찾는 시간을 합쳐 **O(n logn)**이 될것이다.
>
> 우선 LIS를 만들 배열 하나를 선언한다. 그리고, 해당 배열에 가장 맨 처음 수를 넣는다. 배열안에 아무 수도 없다면 이분탐색 시 에러가 발생할 수 있다.
>
> 그 다음부터 현재 수를 가지고 LIS를 만들 배열에서 이분탐색을 진행한다. 현재 수가 들어갈 위치는 자신보다 작은 값중에 가장 큰 수와 자신보다 큰 값 중에 가장 작은 수의 위치에 들어가야 한다. 
>
> 이를 조건으로 이분탐색을 진행하면 만약 위의 조건을 만족하는 위치가 있다면 해당 위치를 반환한다. 만약 LIS 배열의 모든 수보다 현재 수가 높다면 현재 수를 LIS 배열에 push_back()하여 추가한다. 이렇게 되면 LIS의 길이가 하나 증가하는 것이다.
>
> 어떻게 최적화해야 할지만 안다면 생각보다 간단하다... LIS를 만들 배열의 길이는 LIS가 증가하지 않는 이상 크기가 커지지 않고, 이는 탐색 시간을 확실히 줄일 수 있다. 만약 1~100만이 순서대로 나와 모두 추가하는 경우라고 할지라도, 이분 탐색이 100만 개의 탐색을 약 20번 정도의 연산으로 위치를 찾을 수 있으니 그리 많은 시간이 걸리지 않을 것이다.
>
> 오늘은 내가 떠올렸다기 보다는 힌트를 보고 풀었으니까.. 다음에 비슷한 문제를 혼자 풀어보는 시간을 가지면 좋겠다...

