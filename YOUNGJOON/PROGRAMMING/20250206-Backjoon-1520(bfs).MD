# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>
#include <queue>

#define pll pair<int, int>

using namespace std;

int N, M;
vector<vector<int> > board;
vector<pll> direction = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

void downroad()
{
    vector<vector<int> > visited(N, vector<int>(M, 0));
    vector<vector<int> > pushed(N, vector<int>(M, 0));
    visited[0][0] = 1;
    priority_queue<pair<int, pll> > que;
    que.push({board[0][0], {0, 0}});
    
    while (!que.empty()) {
        pll now = que.top().second;
        que.pop();
        
        for (int i=0; i<4; ++i) {
            int nx = now.first + direction[i].first;
            int ny = now.second + direction[i].second;
            
            if (0 <= nx && nx < N && 0 <= ny && ny < M && board[now.first][now.second] > board[nx][ny]) {
                visited[nx][ny] += visited[now.first][now.second];
                if (pushed[nx][ny] == 0) {
                    pushed[nx][ny] = 1;
                    que.push({board[nx][ny], {nx, ny}});
                }
            } 
        }
    }
    
    cout << visited[N-1][M-1];
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N >> M;
    cin.ignore();
    
    string data;
    int num;
    for (int i=0; i<N; ++i) {
        getline(cin, data);
        istringstream iss(data);
        vector<int> one_line;
        while (iss >> num) {
            one_line.push_back(num);
        }
        board.push_back(one_line);
    }
    
    downroad();

    return 0;
}

```



> ## 문제
>
> 여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.
>
> ![img](https://upload.acmicpc.net/0e11f3db-35d2-4b01-9aa0-9a39252f05be/-/preview/)
>
> 현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.
>
> ![img](https://upload.acmicpc.net/917d0418-35db-4081-9f62-69a2cc78721e/-/preview/) ![img](https://upload.acmicpc.net/1ed5b78d-a4a1-49c0-8c23-12a12e2937e1/-/preview/) ![img](https://upload.acmicpc.net/e57e7ef0-cc56-4340-ba5f-b22af1789f63/-/preview/)
>
> 지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.
>
> ## 해설
>
> 처음 문제를 봤을 때 단순하게 경로를 판단하는 것이라고 생각하여 DP를 이용하고자 했다. 출발지점에 값을 1두고 N*M으로 순회하면서 해당 지점에 있는 값을 이동 가능한 곳으로 현재 기록된 값을 더해주기로 했다.
>
> 그런데 이러한 방식은 위의 예제에서 바로 틀렸다. 예시의 정답 3번째를 보면 25 -> 20으로 가는 것은 순회의 역방향이기 때문에 20이 25가 주는 값을 받지 않고 이미 이동해버리기 때문이다.
>
> 그래서 다음으로 BFS를 이용하고자 했다. 그랬더니 문제가 생겼다. 32에서 30과 20으로 보낸 후 30 -> 25로 가기 때문에 20이 25의 값을 받지 못한채로 연산하는 것이었다. 이를 해결하기 위해 다양한 방법을 생각했다.
>
> > 1. 받는 족족 que에 넣어서 보내자!
>>
> >    - 이 방법은 30 -> 20이 이동한 이후 25 -> 20이 다시 와도 다시 연산해주기 때문에 문제가 없다. 대신 연산횟수가 너무 많아진다 모든 경로를 연산해야하기 때문, 그렇다면 현재 가능한 경로의 개수를 기록해서 넘겨준다는 의미 자체가 무색해지므로 불가능하다고 판단했다.
> >
> > 2. 현재 위치가 받아야할 경로의 횟수를 기록하고 다 받으면 que에 넣자!
> >
>>    - visited 이외의 새로운 2차원 배열을 선언하여 현재 위치에서 자신에게 값을 줄 수 있는 좌표의 개수를 기록한다. (현재 위치보다 더 값이 높은 주변의 지점 수)
> >
>>    - 이 방법 또한 불가능했는데, 주변에 있는 지점이 경로가 통할 수 있는지 없는지를 판단하지 않고 갯수를 셌기 때문이다.
> >
>>      ```
> >      50 45 37
> >      35 50 40
> >      30 30 25
> >      ```
> >
> >      - 위의 예시를 보자 `45`는 주변의 `50 2개`가 있기 때문에 2개를 받아야한다고 적을 것이다 그러니 아래에 있는 `50`은 어느 곳에서도 경로가 지나지 않기 때문에 `45`로 값을 보내지 않는다. 그럼에도 45에서는 2개의 값을 받을때까지 que에 들어가지 않기 때문에 제대로된 탐색이 불가능했다.
> >
> > 3. 2번 방법에서 모든 노드에 주변에 작은 값이 있는지 없는지 판단하여 없으면 해당 값 주변에 기록된 값을 빼기
> >
> >    - 2번에서 언급한 위치가 받아야할 경로의 횟수를 줄여주는 방법이다.
> >
> >      ```
> >      50 45 37
> >      35 50 40
> >      30 30 25
> >      ```
> >
> >      - 위의 50을 보면 주변에 50보다 큰 값이 하나도 없기 때문에 경로가 절대로 지나지 않는다. 따라서 50 주변에 있는 모든 값들에 저장된 받아야할 경로 수를 1개씩 빼는 것이다. 그렇게 하면 `45`는 {0, 0}에서 시작하는 값을 받으면 순회를 시작할 것이다.
> >
> >    - 그런데 이 방법도 실패했다.
> >
> >      ``` 
>     >      20 19 18 16
> >      30 31 32 15
> >      11 12 13 14
> >      10 33 34 35
> >      9 8 7 6
> >      ```
>         >
> >      - 위의 반례를 보자 `31`을 보면 주변에 `32`가 있어서 더 높은 값이 있기 때문에 경로가 통할 것이라 생각하겠지만 사실 `32`는 주변에 본인보다 큰 값이 하나도 없다  따라서 절대로 경로가 통하지 못한다. 이러한 경우를 체크하지 못하고 `19`에서는 `31`에서 값이 올것이라 판단하고 기다리다가 순회하지 못한다. 
>     >
> >    - 결국 근본부터 틀린 방식이라고 생각했다. 정말로 경로가 통하지 않는지 살펴보려면 결국 경로 탐색을 진행해야 할 것 같아서 이 방법은 포기하기로 했다.
> 
> 위와 같이 여러 방법을 도모하다가 반례를 찾던 중 우선순위 큐를 썼다는 제목을 보고 방법이 하나 떠올랐다.
>     
> > 1. 우선순위 큐를 이용해 순회 순서를 정한다. 우선순위는 길에 적혀있는 값이다.
> > 2. 만약 10에 값이 돌고돌아 3개가 들어온다고 가정해보자. 그런데 10으로 들어오려면 반드시 10에게 값을 주는 값은 10보다 값이 커야한다. 그렇다 10 보다 큰 값들이 연산되면 10의 차례가 왔을때 반드시 10안에 기록된 값은 올 수 있는 모든 값들을 받은 상태인것이다.
> > 3. 이를 이용하여 단순히 BFS를 돌리면 그냥 bfs를 썼을 때 문제였던 한 지점에 다양한 값이 들어오기 전에 순회를 나가버리는 문제가 해결되어서 문제가 풀린다.
> 
>     위의 방법을 사용하니 바로 정답판정을 받았다. 후... 사실 dfs로도 풀 수있는데 이는 DP(백트래킹) + dfs을 이용하는 것이다. 이 경우도 떠오르긴 했지만 왠지 시간초과가 날 것 같은 불안감에 시도하지 않았으나 다른 사람들의 코드를 살펴보니 이와 같은 방법으로 진행했다.
> 
> 한 경로가 목표지점에 도착하면, 해당 DFS에서 지나온 경로에 그 값을 return 해주며 기록해주고 DP가 기록된 지점에 도착하면 해당 값을 리턴하는 것이다.
> 
> 풀고나서 살펴보니 수월하게 풀릴 것 같았다 역시 확실하게 터질것 같은게 아니라면 한번 시도해보는것도 좋은 방법인 것 같다...
> 
> ### 추가
> 
> 해당 문제는 DFS를 이용하길 원한 것 같은데 BFS로도 풀렸다. 그에 대한 의문이 들어 같이 문제를 푼 친구와 찾아보니까
> 
>     **`BFS는 DAG 그래프 일 경우 값을 구할 수 있다`**는 것이었다. 
> 
> **DAG 그래프란 사이클이 없는 단방향 그래프**라고 한다. 이번 문제 또한 반드시 내리막길을 타야하기 때문에 지나왔던 노드를 다시 방문할 방법이 없다(지나온 노드는 현재 노드보다 반드시 값이 크기 때문) 따라서 BFS로도 문제를 풀 수 있었다고 한다. 이를 알고가면 BFS와 DFS사이에서 고민할 필요가 적어질 것 같다! 꼭 알아두자!!
