# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N;
vector<vector<int> > board(55, vector<int>(55, 0));

int make_idx(char a)
{
    if ('A' <= a && a <= 'Z') {
        return a - 65;
    }
    else {
        return a - 71;
    }
}

char make_char(int a) {
    if (0 <= a && a <= 25) {
        return a + 65;
    }
    else {
        return a + 71;
    }
}


void find_relation()
{
    int cnt = 0;
    for (int k=0; k<52; ++k) {
        for (int i=0; i<52; ++i) {
            for (int j=0; j<52; ++j) {
                if (i == j) continue;
                if (board[i][j] == 0) {
                    if (board[i][k] == 1 && board[k][j] == 1) board[i][j] = 1;
                }
            }
        }
    }
    for (int i=0; i<52; ++i) {
        for (int j=0; j<52; ++j) {
            if (i != j && board[i][j] == 1) {
                cnt++;
            }
        }
    }
    
    cout << cnt << "\n";
    
    for (int i=0; i<52; ++i) {
        for (int j=0; j<52; ++j) {
            if (i != j && board[i][j] == 1) {
                cout << make_char(i) << " => " << make_char(j) << "\n";
            }
        }
    }
    
    return;

}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    char s, e;
    for (int i=0; i<N; ++i) {
        cin >> s >> e >> e >> e;
        int s_idx = make_idx(s);
        int e_idx = make_idx(e);
        board[s_idx][e_idx] = 1;
        
    }
    
    find_relation();

    return 0;
}

```

> ## 문제
>
> 수학, 혹은 논리학에서 만약 무엇 이라면 뭣 일 것이다 하는 식의 명제가 널리 쓰인다. 예를 들어 "P이면 Q일 것이다." 라는 명제는 “P => Q” 라는 기호로 표현된다. 이때의 P를 전건, Q를 후건이라고 한다.
>
> 논리학에서 어떤 명제를 증명할 때 가장 널리 쓰이는 방법 중 한 가지가 바로 삼단 논법이다. 만약 두 명제 “P => Q", "Q => R" 가 모두 참이면, 명제 "P => R"이 역시 참이 된다. 이러한 방법을 사용했을 때 명제 ”P => R"이 증명되었다고 한다.
>
> 어떤 참인 명제가 주어졌을 때, 이 명제가 참이므로 이 명제 자체도 증명될 수 있다고 할 수 있다. 하지만 “P => P”와 같은 명제는 항상 참이 되는데, 이런 식으로 전건과 후건이 같은 경우는 출력하지 않기로 한다.
>
> N개의 참인 명제들이 주어졌을 때, 증명될 수 있는 명제를 모두 구해내는 프로그램을 작성하시오. 명제를 증명하는 방법은 여러 가지가 있을 수 있지만, 위에서 언급한 방법만을 사용하기로 한다.
>
> ## 입력
>
> 첫째 줄에 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 참인 명제들이 주어진다. 명제는 "P => Q"의 꼴로 주어지는데, “=>”는 앞뒤가 공백으로 구분되어 있다. P나 Q는 명제를 나타내는 문자인데, 알파벳 대소문자 한 글자를 사용한다. 같은 명제가 여러 번 주어질 수도 있다.
>
> ## 출력
>
> 첫째 줄에 출력할 명제의 개수 X개를 출력한다. 다음 X개의 줄에 증명될 수 있는 명제를 한 줄에 하나씩 출력한다. 명제를 출력할 때에는 전건 순으로 정렬하고, 전건이 같은 경우에는 후건 순으로 정렬한다. 알파벳은 대문자가 소문자에 우선한다. 즉, 정렬했을 때 A, B, …, Z, a, b, …, z 순서로 나와야 한다.
>
> ## 해설
>
> 처음 문제를 봤을 때 그래프 순회로 접근하려고 했다.
>
> 주어지는 A=>B 같은 값을 단방향 그래프로 보고 가장 우선순위가 높은 알파벳 부터 탐색을 시작하여 보내려고 했다.
>
> 그러나 문제에서 명제의 개수를 먼저 출력해주길 바랬고 그래프를 순회하면서 동시에 총개수를 구할 방법이 없었으므로 처음에는 순회하여 알아낸 명제는 queue에 저장해두어 나중에 꺼내 출력하려고 했다. 그러나 queue에다가 저장하니 메모리 초과가 났고 메모리초과를 피하기 위해서 그래프 순회를 2번하려 했으나 이렇게 하면 시간초과가 났다 ㅠㅠㅠ 결국 알고리즘 분류를 봤는데 플루이드 워샬이었다. 분류를 보자마자 어떻게 풀지 생각할 수 있었다.
>
> 결국에는 어떠한 명제를 다리를 거쳐거쳐서 현재 명제까지 이어지느냐를 따지는 거라면 플루이드 워샬의 개념을 이용할 수 있었다. 어떠한 k를 거쳐서 i와 j가 연결되어 있다면 결국 연결이 된것과 다름 없기때문이다.
>
> 따라서 아래와 같이 문제를 풀었다.
>
> > 1. 알파벳 A~Z, a~z를 전부 0~51까지의 인덱스 값으로 판단하여 51*51크기의 2차원 배열을 만든다. 이에대해 플루이드 워샬을 진행한다.
>> 2. 어떠한 노드 k를 기준으로 대하여 i와 j를 확인한다. 만약 i와 j가 이어지지 않았을때 i와 k는 이어지고 k와 j가 이어졌다면 i와 j는 이어진것으로 판단한다.
> > 3. 모든 판단이 끝나면 52\*52크기의 배열을 2번 순회하여 이어져 있는 개수를 확인하여 출력한후 이어져있는 값을 순서대로 출력한다. 단, 사전순으로 빠른 순으로 출력해야 한다고 하여 A, A = 0, 0이므로 0, 0부터 순회하며 확인하고 이어져있다면 출력한다.
>
> 위와 같은 방법으로 정답을 받았다! 그런데 문제의 조건에서  A => A와 같은 전제는 뺀다고 적혀있었으나 당연히 플루이드 워샬에서 걸러지니까 그럴일 없겠지? 했는데 입력으로 A => A같은 값이 들어와서 플루이드 워샬에서 걸러도 값이 체크되어 출력되는 현상이 있어서 문제를 틀렸다... 방심하지말고 제약조건을 꼭 걸러내는 코드를 잘 작성하자...!
