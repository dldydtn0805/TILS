# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int N, M;
vector<long long> DP, numbers;

void set_DP(int depth, long long num)
{
    if (depth == N-1) {
        DP[depth] = 0;
        return;
    }
    
    int tmp = -1;
    for (int i=depth; i<N; ++i) {
        tmp += numbers[i] + 1;
        if (tmp > M) break;
        
        if (i != N-1) {
            long long tmp_power = DP[i+1] + (M - tmp) * (M - tmp);
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << tmp_power << "가 계산값으로 나왔어 \n";
            DP[depth] = min(DP[depth], tmp_power);
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << DP[depth] << "가 최소값이 나왔어 \n";
        }
        else {
            DP[depth] = 0;
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << DP[depth] << "가 최소값이 나왔어 \n";
        }
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    DP.resize(N, 1000*1000*1000);
    numbers.resize(N, 0);
    long long num;
    vector<int> one_line;
    for (int i=0; i<N; ++i) {
        cin >> num;
        numbers[i] = num;
    }
    for (int i=N-1; i>=0; --i) {
        set_DP(i, numbers[i]);
    }

    cout << DP[0];
    
    return 0;
}

```

> ## 문제
>
> 영도는 국방의 의무를 다하기 위해 대한민국 육군에 입대했다. 고된 훈련병 생활과 후반기 교육을 마치고 자대 배치를 받고 나니, 자대에는 먼저 입대한 친구 종현이 있었다.
>
> 영도는 아무리 생각해도 종현이 먼저 전역하는 것이 마음에 들지 않았다. 그래서 아래의 제도와 규정을 활용해서 종현보다 먼저 전역할 계획을 세웠다.
>
> - 조기 전역: 모아놓은 휴가를 말년에 전역일을 앞당기는 데 사용할 수 있다.
> - 군기교육대: 징계를 받아 군기교육대에 가게 되면, 군기교육대에 있던 기간만큼 전역이 늦춰진다.
> - 임기제 부사관: 임기제 부사관에 지원하여 6개월에서 48개월까지 전문하사로 부대에 남아 국가 안보에 조금 더 이바지할 수 있다. 임기제 부사관 지원서에서의 1개월은 30일로 계산된다.
>   - 영도와 종현의 부대는 인력이 부족해서, 임기제 부사관 지원서를 여러 장 중복해서 제출할 수 있다. 이 때, 복무 기간은 기간 제한의 영향을 받지 않고 누적된다. 만약 48개월 전문하사 지원서를 두 장 작성하고 제출한다면 96개월을 복무하게 된다.
>
> 영도는 이 제도와 규정들을 적절하게 활용하여 영도의 전역일을 앞당기거나 종현의 전역일을 늦추려고 한다. 계획을 남에게 들켰다간 오히려 본인의 전역일이 늦춰질 수 있어서, 영도는 계획을 몰래 실행할 수 있는 여유 내에서 계획을 계속하려고 한다.
>
> 모아놓은 휴가를 모두 사용해도 영도의 전역일은 입대일을 역전하지 않는다고 가정한다. 영도는 최대한으로 얻을 수 있는 휴가로 조기 전역을 하더라도, 계획을 세우는 날 이후에 전역한다.
>
> ## 입력
>
> 첫 번째 줄에 종현의 전역 예정일이 Y1년 M1월 D1일 때, 세 수 Y1, M1, D1$이 `YYYY MM DD` 형식으로 주어진다.
>
> 두 번째 줄에 영도의 전역 예정일이 Y2년 M2월 D2일 때, 세 수 Y2, M2, D2가 `YYYY MM DD` 형식으로 주어진다.
>
> 세 번째 줄에 영도가 계획을 실행하는 데 사용할 수 있는 여유 T와 계획을 위해 할 수 있는 행동의 개수 N이 공백으로 구분되어 주어진다.
>
> 네 번째 줄부터 N개의 줄에 걸쳐 계획을 위해 할 수 있는 행동이 아래와 같이 주어진다. 주어지는 각 행동은 최대 한 번 할 수 있다.
>
> -  1 C V— 영도가 C 만큼의 여유를 투자해서 휴가 V일을 받아낸다. 영도가 획득한 휴가는 이후 자신의 조기 전역에 사용한다.
> -  2 C G— 영도가 C 만큼의 여유를 투자해서 거대한 음모를 세운다. 종현은 거대한 음모에 휘말려 징계를 받고 G일 동안 군기교육대에 다녀온다.
> -  3 C M— 영도가 C 만큼의 여유를 투자해서 종현의 M개월 임기제 부사관 지원서를 대신 작성한다.
>
> 두 사람의 전역일은 입력으로 주어진 영도의 행동 외에 다른 요인으로 변화하지 않는다. 주어지는 수는 모두 정수이다.
>
> ## 출력
>
> 영도가 종현보다 앞서 전역할 수 있다면 영도가 종현보다 앞서 전역하게 되는 날의 수의 최댓값을 출력한다.
>
> 영도가 종현보다 앞서 전역할 수 없다면 영도가 종현보다 늦게 전역하게 되는 날의 수의 최솟값을 출력한다.
>
> ## 제한
>
> -  1990≤Y1,Y2≤3000
> -  0≤T≤10000
> -  0≤N≤100$
> -  0≤C≤10000
> -  1≤V≤30
> -  1≤G≤15
> -  6≤M≤48
> - 올바르지 않은 날짜는 주어지지 않는다.
> - 종현의 전역 예정일은 항상 영도의 전역 예정일을 앞선다.
> - 입력으로 주어지는 모든 수는 정수이다.
>
> ## 해설
>
> 처음 문제를 봤을때 배낭문제를 생각했다. 영도의 전역 일자를 땡기던, 종현의 전역 일자를 줄이던 어차피 둘의 전역 일자 자체가 가까워 지는것은 매한가지니 하나의 스코어로 보고 주어지는 여분의 시간에서 만들 수 있는 최대한의 값을 찾아 현재 둘의 전역 일수 차이에서 빼주고 그 값의 절대값이 정답이 될것이라고 생각했다.
>
> 그러나 엄청나게 틀렸다. 분명 로직 자체는 맞아보였는데... 겨우 겨우 오랜시간에 걸려 (약 7시간) 겨우 문제를 찾아냈다.
>
> > 1. 서로의 전역 일차의 차이를 계산하는데 문제가 있었다. 윤년을 2번 연산하는 경우가 생기는 등 너무 불안정한 방식으로 계산했다.
> > 2. 배낭 문제를 이용하는데 이전 단계에서 값을 가져오는 코드를 작성하지 않았다.
>
> 위의 두 문제는 아래와 같이 해결하였다.
>
> > 1. 서로의 전체 일수를 구한 후 그 전체 일수를 서로 뺀 차이를 구했다.
> > 2. 배낭 문제에서 반드시 현재 j에서 이전 값이 존재할 경우 max() 연산을 이용해 기록하고 진행했다.
>
> 계속 맞는데 뭐가 틀린걸까? 하면서 끙끙 싸메다가 알아냈다 역시 뭐 당연한 얘기지만 틀렸었고 그 이유를 찾지 못해 헤매고 있었다... 아아 배낭 문제는 계속해서 뭔가 하나씩 빠지면서 풀고 있고 구현 부분은 너무 빙빙돌아가서 에러가 터지게 구현하고 있다... 구현 문제를 여러분 풀어서 함수형을 이용해 최대한 문제가 없게 만드는 실력을 길러야겠다...
