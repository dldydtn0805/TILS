# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, M;
vector<pair<int, int> > can_money, need_time;

void make_dp()
{
    vector<vector<int> > DP(N, vector<int>(M+1, -1));
    if (need_time[0].first <= M) DP[0][need_time[0].first] = max(DP[0][need_time[0].first], can_money[0].first);
    if (need_time[0].second <= M) DP[0][need_time[0].second] = max(DP[0][need_time[0].second], can_money[0].second);
    int result = 0;
    
    for (int i=1; i<N; ++i) {
        pair<int, int> now_money = can_money[i];
        pair<int, int> now_time = need_time[i];
        
        for (int j=0; j<=M; ++j) {
            if (j - now_time.first >= 0 && DP[i-1][j - now_time.first] != -1) {
                DP[i][j] = max(DP[i][j], DP[i-1][j - now_time.first] + now_money.first);
            }
            if (j - now_time.second >= 0 && DP[i-1][j - now_time.second] != -1) {
                DP[i][j] = max(DP[i][j], DP[i-1][j - now_time.second] + now_money.second);
            }
        }
    }
    
    for (int i=0; i<=M; ++i) {
        result = max(result, DP[N-1][i]);
    }
    
    cout << result;
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    can_money.resize(N + 1); need_time.resize(N + 1);
    int t1, m1, t2, m2;
    
    for (int i=0; i<N; ++i) {
        cin >> t1 >> m1 >> t2 >> m2;
        can_money[i] = {m1, m2};
        need_time[i] = {t1, t2};
    }
    
    make_dp();

    return 0;
}
```



> ## 문제
>
> 배우 한정올 씨는 이번 여름에 서울에서 경산까지 자선 여행을 하면서 모금 활동을 진행할 계획이다. 자선 여행에서 거쳐 가게 될 도시의 개수와 순서는 미리 정해져 있으며, 자선 여행은 서울에서 시작하여 각 도시를 정해진 순서대로 단 한 번씩 방문한 후 경산에서 끝난다. 서울을 제외한 도시의 개수를 N 이라 하자. 이때 서울에서 두 번째 도시까지 가는 구간을 구간 1, 두 번째 도시부터 세 번째 도시까지 가는 구간을 구간 2와 같이 부르기로 하며, 마지막 목적지인 경산에 도착하는 구간을 구간 N 이라 하자. 즉, 구간의 전체 개수는 N이다. 구간 사이의 이동은 도보 혹은 자전거 어느 한 쪽을 이용하게 되는데, 각 구간에는 도보로 이동할 때 걸리는 시간(분), 이때 얻게 되는 모금액(원), 자전거로 이동할 때 걸리는 시간(분), 이때 얻게 되는 모금액(원)이 정해져 있다.
>
> 예를 들어, 서울과 경산 사이에 2개의 도시가 있는 다음과 같은 경우(N = 3)를 생각해 보자.
>
> ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14863/1.png)
>
> 인접한 도시 사이를 도보로 이동하는지 자전거로 이동하는지에 따라 전체 모금액이나 걸리는 시간에 차이가 생기게 된다. 한정올 씨는 전체 모금액을 가능한 많이 얻는 방법을 찾고 싶어 한다. 위의 예에서는 시간이 충분하다면 모든 구간을 도보로 이동하는 것이 모금액을 최대로 하는 방법이며, 모금액은 200+370+250 = 820원, 여행에 걸리는 시간은 500+800+700 = 2,000분이다.
>
> 그러나 한정올 씨는 바쁜 스케줄로 인해 자선 여행을 위해 보낼 수 있는 시간이 K분(K는 자연수)으로 한정되어 있다. 위의 예에서 만약 K = 1,650이라면, 1, 2번 구간은 도보로 이동하고 3번 구간은 자전거로 이동하여 모금액을 660원으로 하는 것이 가장 좋은 방법이며, 이때 걸리는 시간은 1,600분이다.
>
> 위와 같이 각 구간별로 도보 및 자전거로 이동하는 경우 걸리는 시간과 모금액이 주어질 때, 제한시간 이내로 서울에서 경산까지 여행하면서 모금할 수 있는 최대 금액을 찾는 프로그램을 작성하시오. (제한시간 이내에 여행하는 방법은 항상 존재한다.)
>
> ## 입력
>
> 표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 두 자연수 N과 K가 공백으로 분리되어 주어진다(3 ≤ N ≤ 100, 0 < K ≤ 100,000). 두 번째 줄에는 구간 1을 도보로 이동할 때 걸리는 시간(분), 이때 얻게 되는 모금액(원), 자전거로 이동할 때 걸리는 시간(분), 이때 얻게 되는 모금액(원)을 나타내는 네 개의 자연수가 차례로 공백으로 분리되어 주어진다. 세 번째 줄부터 N+1번째 줄도 마찬가지 형식으로 각 줄마다 네 개의 자연수가 주어지며, 입력은 총 N+1줄로 구성된다. 두 번째 줄부터 N+1번째 줄에 주어지는 숫자들 중 시간을 나타내는 숫자(각 줄의 첫 번째, 세 번째 숫자)는 10,000 이하의 자연수, 모금액을 나타내는 숫자(각 줄의 두 번째, 네 번째 숫자)는 1,000,000 이하의 자연수들이다.
>
> ## 출력
>
> 표준 출력으로 K분 이내로 여행하면서 모금할 수 있는 최대 금액을 출력한다. (K분 이내에 여행하는 방법은 항상 존재한다.)
>
> ## 해설
>
> 처음 문제를 봤을때 DFS로 돌릴까했다.. 그러나 음.. K를 넘는 경우의 백트래킹을 제외하면 최적화 할만한 방법이 생각나지 않았고 최악의 경우 2^100까지 가능할 것 같아보였다
>
> 문제를 잘 살펴보니까 음.. 또 배낭 문제? 같아 보였다 M을 가방 사이즈로해서 N개만큼의 주어진 조건들을 대입하는 것이었다.
>
> 그런데 이 문제는 일반적인 배낭 문제랑 다른 조건들이 있었다.
>
> > 1. 한 지점에서 2개의 경우가 주어진다.
>> 2. 반드시 끝(경산)까지 도착해야 성공하는 것이다.
> > 3. 반드시 이전 값에 대해 더 해서만 기록할 수 있다.
> >    - 경로를 지나쳐야하기 때문에 갑자기 중간지점부터 시작할 수 없다 반드시 서울부터 차근히 지나와야한다.
>
> 이 두개의 조건을 제대로 파악하지 않고 냅다 배낭 문제로 풀었더니 틀렸다.
>
> > 1. 한 지점에서 2개의 경우가 주어진다.
> >    - 한 지점에서 2개의 값을 넣는데 똑같은 시간에 다른 돈이 주어지면 더 큰값을 기록해야 했는데 그냥 냅다 기록해서 어긋났다.
>> 2. 반드시 끝(경산)까지 도착해야 성공하는 것이다.
> >    - 중간 지점에서 K값의 이하인 최대값이 등장해도 기록해버려서 결국 발생할 수 없는 값이 기록되어 버렸다.
>> 3. 반드시 이전 값에 대해 더 해서만 기록할 수 있다.
> >    - 갑자기 중간부터 시작해버려서 K == 2일때, 3번째 지점이 2, 99999라면 냅다 99999를 주워버려서 문제가 발생했다.
>
> 위의 배낭 문제와 다른 조건들을 모두 고쳐서 정답을 받을 수 있었다....
>
> 흐음... 사실 그렇기 때문에 이 문제를 배낭 문제가 아닌 단순 DP 문제로 생각하고 푸는게 더 좋았을 것 같다...
>
> 문제를 찾기위해 여러 반례를 지급 받았는데 반례가 어떤 케이스에서 걸리는지 보기좋게 만들어져있어서 사실상 직접 생각한 것도 아니고 보고 푼 수준이 아닌가 싶다... 하아... 최근 DP 문제가 계속 나오는데 너무 자주 틀린다......... 문제도 제대로 안읽는것 같고................... 제발 차근히 천천히 문제를 보고풀도록 하자...
