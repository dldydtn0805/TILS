# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int T, N;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> T;
    for (int t=0; t<T; ++t) {
        cin >> N;
        vector<int> now = {0, 0, 0, 0, 0};
        if (N >= 60) {
            int power = N / 60;
            now[0] += power;
            N %= 60;
        }
        
        if (N > 35) {
            now[0]++;
            int tmp = 60;
            int tmp_N = N;
            
            while (tmp > tmp_N) {
                tmp -= 10;
                now[2]++;
                if (tmp < tmp_N) {
                    if (N % 10 >= 5) {
                        tmp += 10;
                        now[2]--;
                    }
                    break;
                }
            }
            N %= 10;
            
            if (N < 5) {
                now[3] += N;
            }
            else {
                now[4] += 10 - N;
            }
        }
        else {
            now[1] += N / 10;
            N %= 10;
            
            if (N <= 5) {
                now[3] += N;
            }
            else {
                now[1]++;
                now[4] += 10 - N;
            }
        }
        
        for (int a : now) {
            cout << a << " ";
        }
        cout << "\n";
        
    }
    
    return 0;
}

```



# 해설

> ## 문제
>
> 피자를 굽는 전자식 오븐이 있다. 이 오븐에 재료는 넣고 정확히 N$N$분 동안 동작을 시키고자 한다. 그런데 이 오븐에 준비된 버튼은 아래와 같은 동작을 하는 5가지이다. 즉, 각각의 버튼은 동작 시간을 추가시키거나 감소시킨다. 처음에 피자 오븐의 첫 시간은 0분으로 정해져 있다. 시간을 감소시키는 버튼을 눌러서 시간이 0분보다 작아지는 경우에는 0분으로 설정된다. t$t$가 현재 오븐에 세팅된 시간, t′$t'$은 버튼을 누른 뒤의 시간을 의미할 때, 각 버튼은 다음과 같은 기능을 가지고 있다.
>
> - `ADDH`: t′=t+60$t' = t + 60
> - `ADDT`: t′=t+10$t' = t + 10
> - `MINT`: t′=t−10$t' = t - 10
> - `ADDO`: t′=t+1$t' = t + 1
> - `MINO`: t′=t−1$t' = t - 1
>
> 예를 들어, 58분을 설정하고 싶으면, `ADDO` (+1분) 버튼을 58번 눌러도 된다. 하지만, `ADDH` (+60분) 버튼을 한 번 누른 뒤에 `MINO` (-1분) 버튼을 2번 누르면 3번의 작업으로 58분을 만들 수 있다. 42분을 설정하고 싶은 경우에는 버튼을 `ADDH`, `MINT`, `MINT`, `ADDO`, `ADDO` 순서로 5번 눌러서 만들 수 있다. `ADDT`, `ADDT`, `ADDT`, `ADDT`, `ADDO`, `ADDO` 순서로 6번 눌러서 만들 수 있지만, 버튼은 최소 횟수로 누르려고 한다.
>
> 설정해야 할 시간이 주어졌을 때, 그 시간을 만들기 위해 눌러야 하는 버튼의 최소 횟수와 그 방법을 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 입력을 T개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 설정해야 하는 시간 N이 분 단위의 정수로 주어진다.
>
> ## 해설
>
> 처음 봤을때  DP를 생각했다. DP를 이용하여 1000만 개의 모든 경우의 횟수를 {0, 0, 0, 0, 0, 0}의 6개의 벡터를 할당하여 이전 값을 보며 관리하려고 했다.
>
> 근데 이게 DP에 핏하지 않은 문제라고 느꼈다. 사실 상 이렇게 풀어나간다면 BFS랑 다를것이 없고 시간이 0.25초로 주어지는데, 6000만 크기의 배열을 만드는 순간 시간 초과가 나버린다...
>
> 그래서 알고리즘 분류를 봤는데..? 그리디가 있었다... 처음에 DP의 규칙을 찾을게 있나해서 생각해보다가
>
> +1과 -1은 35를 기준으로 35보다 작거나 같을때는 1~5는 +1을 사용하고, 6~9는 -1을 사용했다.
>
> 35보다 크다면 1~4는 +1을 사용하고, 5~9는 -1을 사용했다. 60을 기준으로 했을때, 40은 60에서 -20을 하는것이 더 빠르기 때문에, 35를 기준으로 보았다.
>
> 어차피 60보다 큰 수는 60을 최대한 써서 60 미만의 수로 줄이는 것이 가장 최적의 횟수를 사용하는 것이므로, 우선적으로 60으로 나누어 60 미만의 수로 만들고 이때 35를 기준으로 나누어 계산하였다
>
> +10, -10을 계산하는 것을 따지면 40 이상일 때는 60에서 -10하는 것이 더 횟수를 적게 사용하므로 이를 염두하여 사용한다.
>
> 그런데 잘 보면 35일때 30 +5와 40 - 5의 사용 횟수는 똑같다. 그래서 35를 기준으로 나눈 것인데, 문제의 조건을 보면 같은 개수를 사용한다면 +60, +10, -10, +1, -1 순으로 더 작게 사용하는 순을 원한다. 40-5는 60을 하나 사용해야 하기 때문에, 60을 사용하지 않는 30쪽이 더 우선순위를 갖는 것이다. 이 때문에 35를 기준으로 나누어 연산하였다. 36부터는 횟수 자체가 40 - 4가 유리하기 때문에 60을 사용하게된다.
>
> 처음에는 DP로 잘 구현해서 돌렸는데 시간이 3초 넘게 나와서 멘붕이 왔다.. 결국 알고리즘 유형을 보고 풀었으니 순수하게 내실력으로 푼건 아니라 좀 아쉽다... 그리디는... 딱 그리디라는 느낌을 바로 캐치하고 접근하는게 중요한데... 역시 이런 느낌은 그리디를 많이 풀어봐야 알 수 있을것 같다. 화이팅!

