# 코드

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int N, M;
vector<vector<char> > board(1000, vector<char>(1000, ' '));
vector<vector<int> > visited(1000, vector<int>(1000, 0));
unordered_map<char, pair<int, int> > directions = {{'N', {-1, 0}}, {'S', {1, 0}}, {'W', {0, -1}}, {'E', {0, 1}}};

int coloring = 0;

int lets_move(int color, int x, int y)
{
    visited[x][y] = color;
    pair<int, int> next_loca = directions[board[x][y]];
    int nx = x + next_loca.first;
    int ny = y + next_loca.second;

    if (visited[nx][ny] == 0) {
        visited[nx][ny] = color;
        int tmp_color = lets_move(color, nx, ny);
        visited[x][y] = tmp_color;
        return tmp_color;
    }
    else {
        visited[x][y] = visited[nx][ny];
        return visited[x][y];
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<M; ++j) {
            cin >> board[i][j];
        }
    }
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<M; ++j) {
            if (visited[i][j] == 0) {
                int tmp = lets_move(coloring + 1, i, j);
                if (tmp == coloring + 1) coloring++;
            }
        }
    }
    
    cout << coloring;
    
    return 0;
}

```

> ## 문제
>
> 욱제는 구사과의 열렬한 팬이다. 오늘 욱제는 구사과에게 선물(![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15559/1.png))을 전달해주려고 한다. 지난 며칠간의 관찰 끝에 욱제는 구사과의 이동 패턴을 모두 파악했다.
>
> 구사과가 있는 곳은 N×M 크기의 직사각형 지도로 나타낼 수 있으며, 1×1크기의 정사각형으로 나누어져 있다. 구사과의 위치는 (i, j)로 나타낼 수 있으며, (i, j)는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸을 의미한다.
>
> 지도의 각 칸에는 N, W, E, S 중의 한 문자가 쓰여져 있는데, 구사과는 이 문자를 이용해서 이동한다. 구사과의 위치가 (i, j)인 경우에 N이 쓰여져 있는 칸에 서 있었다면, (i-1, j)로, S의 경우에는 (i+1, j)로, W의 경우에는 (i, j-1), E의 경우에는 (i, j+1)로 순간이동한다. 구사과는 지치지 않기 때문에, 계속해서 이동한다.
>
> 욱제는 구사과의 위치를 모르기 때문에, 구사과가 이동을 시작하는 위치와 관계없이 선물을 주는 방법을 알아내려고 한다. 최소 몇 개의 칸 위에 선물을 놓으면, 구사과가 항상 선물을 가져가는지 구하는 프로그램을 작성하시오. 선물이 놓여진 칸에 구사과가 이동하면, 구사과는 항상 선물을 가져간다.
>
> ## 입력
>
> 첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 1,000, 1 < N×M ≤ 1,000,000)
>
> 둘째 줄부터 N개의 줄에는 구사과가 있는 곳의 지도가 주어진다. 
>
> 지도에 쓰여 있는대로 이동했을 때, 지도를 벗어나는 경우는 없다.
>
> ## 출력
>
> 첫째 줄에 최소 몇 개의 칸에 선물을 놓아야 하는지 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을 때 분리 집합을 떠올렸다. 음... 문제의 조건에서 주어지는 격자 바깥으로 나가는 경우가 없다고 하였고 그렇다면 반드시 싸이클이 돈다는 얘기로 이해했다.
>
> 그렇다면 싸이클의 개수가 정답이 되지 않을까 했다
>
> > 1. 어떠한 지점의 방문 기록이 되어 있지 않다면 현재 색깔의 값을 1 올려 해당 값으로 DFS로 이동가능한 모든 경로에 색깔의 값을 기록한다.
> > 2. 기록된 색의 수가 필요한 선물의 수이다.
>
> 그러나 처음 문제를 제출했더니 문제가 생겼다.
>
> ```
> 3 4
> SWWW
> SEWN
> EEEN
> ```
>
> 위의 반례를 보면 겉 테두리는 사이클이지만 안의 EW는 싸이클이 아니고, 겉 테두리 사이클에 참가하게 되는 외부 가지 같은 느낌이었다. 하지만 처음에 방문 되지 않은 경우 현재 색깔의 개수를 올려버렸으니 제대로된 정답이 나올 수 없었다. 따라서 아래와 같이 변경하기로 했다.
>
> > 1. 어떠한 지점의 방문 기록이 되어 있지 않다면 현재 색깔의 값을 1 올려 해당 값으로 DFS로 이동가능한 모든 경로에 색깔의 값을 기록한다.
> > 2. 이동하던 중 현재 색깔과 다른 색깔을 마주했다면 해당 색깔을 반환하여 지나온 경로 모두 해당 색깔로 변경한다. 경로의 색깔을 모두 변경했다면 해당 색깔을 반환한다.
> > 3. 이동하던 중 현재 색깔과 같은 색깔을 마주했다면 싸이클 이므로 현재 색깔을 반환하며 탈출한다.
> > 4. 2번과 3번 둘 중 하나에서 값을 받았을때 현재 인자로 주었던 현재 색깔의 값이 반환되었다면 현재 색깔의 값을 올리고 다른 색이 나왔다면 다른 싸이클에 존속되었다는 뜻이므로 색깔의 값에 변화를 주지 않는다.
>
> 위와 같은 방식으로 진행하니 정답을 받았다.
>
> 생각보다 애먹은 문제였다 문제의 알고리즘 구상 및 로직 접근은 상당히 정답에 가까웠는데 사소한 실수들 때문에 문제가 발생했다.
>
> 위의 4번 절차에서 반환되는 값을 확인하지 않고 그냥 색깔의 값을 올려버렸더니 문제가 발생했다. 이걸 캐치를 못해서 오랫동안 고민했다 아아.. 생각한 로직을 꼭 끝까지 점검하고 구현하도록 하자... 안그러면 빈 로직을 찾는데 너무 오래걸리고 디버깅하는데 상당히 오래걸린다...
