# 코드

```c++
#include <iostream>
#include <vector>

#define pll pair<int, int>

using namespace std;

int N, S, E;
vector<vector<pll> > graph;

void dfs()
{
    vector<int> stacker, passed_length;
    stacker.push_back(S);
    vector<int> visited(N+1, 0);
    visited[S] = 1;
    while (stacker.back() != E) {
        int now = stacker.back();
        for (pll p : graph[now]) {
            if (visited[p.first] == 0) {
                visited[p.first] = 1;
                stacker.push_back(p.first);
                passed_length.push_back(p.second);
                break;
            }
        }
        if (stacker.back() == now) {
            stacker.pop_back();
            passed_length.pop_back();
        }
    }
    
    int max_length = 0;
    int total = 0;
    for (int a : passed_length) {
        total += a;
        max_length = max(max_length, a);
    }
    
    cout << total - max_length;
    
    return;
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    cin >> N >> S >> E;
    graph.resize(N+1);
    int s, e, dist;
    for (int i=0; i<N - 1; ++i) {
        cin >> s >> e >> dist;
        graph[s].push_back({e, dist});
        graph[e].push_back({s, dist});
    }
    if (N > 1) {
        dfs();    
    }
    else {
        cout << 0;
    }

    return 0;
}

```



> ## 문제
>
> 2018년 강원도에서 새로운 동굴이 발견되었다. 이 동굴에는 총 *N*개의 넓은 방이 존재하며 좁은 통로로 서로 연결되어 있는 것으로 밝혀졌다. *N*개의 방은 1번부터 *N*번까지의 번호를 붙여 1번 방, 2번 방, …, *N*번 방으로 부른다. 통로는 정확히 *N*-1개가 발견되었는데, 각각 서로 다른 두 방 사이를 연결시켜 주며 중간에 다른 통로와 이어지는 경우는 없다고 한다. 또한 이 통로들을 이용하여 임의의 두 방 사이를 이동하는 것이 가능하며, 임의의 두 방 사이를 이동할 때 같은 통로를 두 번 이상 지나지 않는 경로는 유일한 것으로 밝혀졌다.
>
> 새로 발견된 동굴을 조사하기 위해 동굴 탐사 로봇 두 대를 이용하기로 하였다. 두 로봇은 어떤 시점이 되면 각자가 획득한 정보를 공유하기 위해 통신을 해야 한다. 두 로봇이 서로 통신을 하기 위해서는 동굴 내의 같은 통로 위에 위치해야만 한다. 참고로 임의의 통로의 양 끝에 위치한 두 방들도 그 통로 위에 위치해 있다고 간주한다.
>
> ![img](https://upload.acmicpc.net/869fb1ce-7817-43c3-8a8a-f7b5bcadc911/-/preview/)
> <그림 1> 동굴 내부를 간략히 표현한 그림
>
> <그림 1>은 방이 9개인 동굴 내부를 간략하게 나타낸 예이다. <그림 1>에서 방은 원으로 표현되어 있으며 원 안의 수는 방 번호이다. 8개의 통로는 두 원 사이의 선분으로 표시되어 있으며 그 위의 정수 값이 통로의 길이이다. 예를 들어, 5번 방과 9번 방 사이에 길이가 6 인 통로가 있음을 알 수 있다. 만약 두 로봇이 1번 방과 9번 방에 위치해 있다면, 각각 2번 방과 5번 방으로 이동한 후 통신할 수 있으며 이때 이동한 거리의 합은 14로 최소이다.
>
> 동굴 내의 통로에 대한 정보와 두 로봇의 현재 위치가 입력으로 주어질 때, 서로 통신하기 위해 이동해야 하는 거리의 합의 최솟값을 계산하는 프로그램을 작성하시오.
>
> 동굴의 각 통로는 양 끝에 위치한 두 방의 번호와 그 길이로 주어진다. 두 로봇의 위치는 방 번호로 주어진다.
>
> ## 입력
>
> 표준 입력으로 동굴의 방의 개수 *N*과 두 로봇이 위치한 방의 번호가 세 개의 양의 정수로 공백으로 분리되어 첫 줄에 주어진다. 이후 동굴의 통로 *N*-1개가 한 줄에 하나씩 주어진다. 각 통로는 세 개의 양의 정수로 공백으로 분리되어 한 줄에 주어지며, 앞 두 정수는 통로의 양 끝에 위치한 방의 번호를, 세 번째 정수는 그 통로의 길이를 의미한다.
>
> ## 출력
>
> 표준 출력으로 두 로봇이 서로 통신하기 위해 현재 위치에서 이동해야 하는 거리의 합의 최솟값을 정수로 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을때 그래프 순회를 통하여 출발지부터 목적지까지의 경로를 구하고 해당 경로중 비용이 높은 통로 하나만 빼서 값을 구하면 될 것이라고 생각했다. 경로를 구하는데에는 DFS가 적합할 것으로 생각하여 DFS로 풀기로 했다. 방식은 아래와 같다.
>
> > 1. 스택에 시작 지점을 넣는다. 방문 처리할 vector를 선언한 후 시작 지점을 방문 처리한다. 그리고 경로에 따른 거리를 저장할 vector를 선언한다.
> >
> > 2. 스택의 가장 뒤에 있는 값을 기준으로 그래프 순회를 한다. 
> >
> >    2-1. 연결된 곳이 방문 처리 되어있다면 이동하지 않는다. 만약 아무곳도 이동하지 못했다면 스택의 가장 뒤쪽 값과 거리를 저장한 vector의 뒤쪽 값을 뺀다.
> >
> >    2-2. 연결된 곳이 방문 처리 되어 있지 않다면 이동하고, 방문처리를 한다. 해당 위치와 경로값을 각각 맞는 vector 뒤에 추가한다.
> >
> > 3. 만약 스택의 가장 뒤에 있는 값이 목적지라면 그 순간 탐색을 종료하고 거리를 저장한 vector안에 있는 값들을 모두 더한다.
> >
> > 4. 그 중에서 가장 긴 경로를 구해 모든 경로의 합에서 가장 긴 경로의 값을 뺀다.
>
> 위와 같이 제출했는데 99%에서 Segment fault 에러가 발생했다. 음... 끝자락에서 나온 에러라 엣지케이스일 것 같아서 문제를 다시 잘 보니 **N이 1인 경우가 있었다.** 그리고 입력도 N-1개만 받아야 하는데 N개를 받고 있어서 문제가 발생했다... N이 1일때 아무것도 받으면 안되는데 입력이 없는데 받으려고 했기 때문에 문제가 생겼다... 로직은 잘 생각했는데 이런 사소한 실수때문에 틀리면 곤란하다... 좀 더 꼼꼼하게 푸는 습관을 들이도록 하자...
