# 코드

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int N, M;

vector<bool> used;
vector<bool> is_print;
vector<unordered_map<int, int> > graph;

void dfs(int now)
{
    if (is_print[now] == false) {
        
        is_print[now] = true;
        
        for (auto a : graph[now]) {
            dfs(a.first);
        }
        cout << now << " ";
        
    }

    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N >> M;
    int s, e;
    
    used.resize(N+1, false);
    is_print.resize(N+1, false);
    graph.resize(N+1);
    
    for (int i=0; i<M; ++i) {
        cin >> s >> e;
        
        used[s] = true;
        graph[e][s] = 1;
        
    }
    
    for (int i=1; i<=N; ++i) {
        if (used[i] == false) {
            used[i] = true;
            dfs(i);
        }
    }

    return 0;
}

```



# 해설

> ## 문제
>
> N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.
>
> 일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 횟수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.
>
> 학생들의 번호는 1번부터 N번이다.
>
> ## 해설
>
> 처음에 생각했던건 위상 정렬이라고 한다는데 순서를 정해서 먼저하는 것을 이용했다. (예전에 건물을 짓는데 테크트리가 필요하다는 문제와 상당히 접근법이 비슷해보였다.) 그런데 좀 다르게 푼점은 역방향으로 봤다는 점이다. 정방향으로 봤을때 내 생각에는 좀 풀기 어려워보이는 문제가 있었다.
>
> ```
> 4 3
> 1 3
> 2 3
> 4 1
> ```
>
> 위의 예시를 봤을때, 4부터 진행하면 `4 - 1 - 3` 순서가 된다 그러나 2는 3앞에 와야 한다. 그런데 이걸 이제와서 만들어진 순서 사이에 끼워 넣는게 너무 까다롭다는 생각이 들었다. 그러나 제일 뒤에 존재하는 3부터 리프노드까지 들어가 순서대로 출력한다면 `4 - 1 - 2 - 3` 혹은 `2 - 4 - 1 - 3` 이 된다.
>
> 2가지의 경우가 모두 만족하므로 뒤에서 부터 역방향으로 보는것이 더 이득일것이라고 생각했다.
>
> 그래서 신나게 작성해서 제출했으나, 출력 초과라는 이상한 의외의 에러가 났다. 출력 조건이라하면 당연히 N개만큼 출력할 것이기 때문에 출력초과가 났다면 그 이상으로 출력하고 있다는 얘기가 될텐데 처음에 어디가 문제인지 찾아보는데 애먹었다. 
>
> 나는 used를 이용해서 중복되는 출력을 제어하려고 했던건데 이게 내가 의도했던대로 돌아가지 않는다는 뜻이었다.
>
> 그러다가 반례 하나를 봤는데,
>
> ```   
> 4 4
> 1 3
> 2 3
> 4 1
> 4 2
> ```
>
> 이거 였다. 내가 여태 봤던 반례들은 전부 하나의 노드에 하나의 간선으로만 이어져있었으나, 위에서 보면 4에 대해서 1과 2가 동시에 관여한다.
>
> 그러나 3에서부터 출발했을 때, 1을 통해서 4를 가고 4를 출력 후, 다시 1로 돌아와 1을 출력하고 다음 노드인 2로 갔는데, 2 또한 4로 가기 때문에 문제가 발생했던 것이다. 기존 코드에서는 `4-1-4-2-3`과 같은 순서로 출력을하고 말았고, 따라서 주어진 N개보다 더 많은 수를 출력하기 때문에 출력초과가 발생한 것이다.
>
> 이를 관리하기 위해 is_print라는 bool값을 이용하여 이미 한번 출력된 적 있는 노드라면, 더 이상 볼 필요가 없다! 라는 방법으로 처리하였더니 맞았다!
>
> 접근법은 처음 생각했던 것이 맞았다. 이는 좋은 현상이다! 하지만 마무리가 아쉽다 주어진 반례가 전부 맞았었기 때문에 코테를 봤었다면 이건 틀리는 거였다. 이를 잘 주의해서 풀도록하자!

