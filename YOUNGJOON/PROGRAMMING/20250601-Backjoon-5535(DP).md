# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

#define pll pair<int, int>

using namespace std;

int D, N;
vector<int> days_temperature(201, 0);
vector<pair<int, pll> > clothes(201);

int get_best_p()
{
    int result = 0;
    vector<vector<int> > DP(D, vector<int>(101, -1));
    for (int j=0; j<N; ++j) {
        if (days_temperature[0] >= clothes[j].second.first && days_temperature[0] <= clothes[j].second.second) {
            DP[0][clothes[j].first] = 0;
        }
    }
    
    for (int i=1; i<D; ++i) {
        for (int j=0; j<N; ++j) {
            if (days_temperature[i] >= clothes[j].second.first && days_temperature[i] <= clothes[j].second.second) {
                for (int k=0; k<=100; ++k) {
                    if (DP[i-1][k] != -1) {
                        DP[i][clothes[j].first] = max(DP[i][clothes[j].first], DP[i-1][k] + abs(k - clothes[j].first));
                    }
                }
            }
        }
    }
    
    for (int i=0; i<=100; ++i) {
        result = max(result, DP[D-1][i]);
    }
    
    return result;
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> D >> N;
    int s, e, p;
    for (int i=0; i<D; ++i) {
        cin >> days_temperature[i];
    }
    
    for (int i=0; i<N; ++i) {
        cin >> s >> e >> p;
        clothes[i] = {p, {s, e}};
    }
    
    cout << get_best_p();
    
    return 0;
}

```

> ## 문제
>
> 상근이는 학교에 관심있는 사람이 생겼기 때문에, D일동안(1일~D일) 입을 옷을 계획하기로 했다. 옷의 스타일과 최고 기온은 매우 밀접한 관계가 있기 때문에, 상근이는 D일 동안 일기 예보를 바탕으로 계획을 세우려고 한다. i일의 최고 기온은 Ti이다.
>
> 상근이는 총 N가지 옷을 가지고 있고, 이 옷은 모두 1번에서 N까지 번호가 붙여져 있다. 옷 j(1 ≤ j ≤ N)는 최고 기온이 Aj 이상 Bj 이하인 날에만 입을 수 있다. 또, 각 옷의 화려한 정도는 Cj이다.
>
> 상근이는 일기예보를 참고해 어느 날 어떤 옷을 입을지 결정하려고 한다. 같은 옷을 여러 번 입어도 되고, 한 번도 입지 않은 옷이 있어도 상관 없다.
> 
> 비슷한 옷을 연속해서 입는다면, 그 사람이 상근이에게 호감을 느끼지 않을 수 있다. 따라서, 옷의 화려함의 차이의 합이 최대가 되도록 옷을 입으려고 한다. 즉, i일에 옷 xi을 입었다면, |Cx1 - Cx2| + |Cx2 - Cx3| + ... + |CxD-1 - CxD|를 최대로 하려고 한다.
> 
>화려함의 차이의 합의 최댓값을 구하는 프로그램을 작성하시오.
> 
>## 입력
> 
> 첫째 줄에 D와 N이 주어진다. (2 ≤ D, N ≤ 200) 다음 D개 줄에는 i일의 의 최고 기온 Ti가 주어진다. (0 ≤ Ti ≤ 60) 다음 N개 줄에는 상근이가 가지고 있는 옷의 정보가 주어진다. (0 ≤ Aj ≤ Bj ≤ 60, 0 ≤ Cj ≤ 100)
> 
> 상근이가 입을 수 있는 옷이 없는 날은 없다.
> 
> ## 출력
> 
>첫째 줄에 상근이가 입는 옷의 화려함의 차이의 합의 최댓값을 출력한다.
> 
>## 해설
> 
>처음 문제를 봤을 때 그리디한 방법으로 생각했다. 격차값이 크게 만들어야하니 해당 일자에 발생하는 최소의 가치와 최대의 가치를 기록하여 번갈아가며 차이값을 기록하면 좋은값이 나올것이라 생각했으나, 틀렸다... 그 이유는 이 방식이 반드시 최적의 값을 만든다는 보장이 없었다. 최댓값이 잘 나가다가 마지막에 최대와 최소가 같은 값을 가지게 될 경우 어느 한 부분에서 가치가 0이 되고 이 때문에 꼬일 수도 있기 때문이다
> 
>```
> 최대 값 - 60 50 60 60
>최소 값 - 50 10 20 60 << 이전 최댓값과 최솟값이 같아 값이 크던 루트에서 값이 작아져 버린다.
> 이때 만약 중간값 25가 존재 했다면 더 큰 이득을 볼 수 있었을 것이다.
>```
> 
>따라서 모든 발생할 수 있는 경우를 보아야만 했고, 이를 브루트 포스하기에는 시간이 넉넉해보이진 않았다.
> 
>그래서 모든 경우를 고려하여 살펴볼 수 있는 배낭문제 방식을 채택하기로 했다.
> 
>> 1. 입고갈 일자의 수 * 최대 화려함의 값(100)의 크기를 가지는 2차원 배열을 DP로 -1로 선언한다.
> >
> > 2. 첫날에 입고 갈수 있는 모든 옷의 화려함에 대해 점수를 0으로 기록한다.
> >
> > 3. 둘째 날부터 마지막 날까지 순회한다.
> >
> >    - 현재 순회 중인 날에 입을 수 있는 옷을 모두 순회한다.
> >
> >      - 이전 날에 값을 가지는 화려함에 대해 현재 순회 중인 옷의 화려함의 차이 값을 골라 이전 날의 화려함이 가진 값에 더한다.
> >
> >        만약, 그 값이 현재 날의 현재 순회 중인 옷의 화려함에 기록된 값보다 크다면 그 값을 기록한다.
> >
> > 4. 마지막 날에 기록된 값중 가장 큰 값을 출력한다.
> 
> 위와 같은 방식으로 DP를 이용하여 문제를 풀 수 있었다. 일반적인 배낭 문제와는 다르게 이전 값을 끌어올 필요는 없었다. (이전 날에 입은 옷에서 부터 화려함을 찾아야 하기 때문에...) 그래서 조금 차이가 느껴졌다.
> 
> 처음에 구상한 방법이 바로 틀려서 어찌저찌 대안을 찾긴 했지만... 역시 그리디는 확실하게 보장되었다고 느껴지지 않으면 사용하기 위험한 알고리즘 인 것 같다... 좀 더 문제를 많이 풀어서 이를 구분할 줄 아는 능력을 기르자!

