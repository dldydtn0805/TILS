# 코드

```c++
#include <iostream>
#include <vector>
#include <set>

using namespace std;

int N;
vector<vector<int> > graph;

int get_num()
{
    int K = 0;
    set<int> now_loca;
    now_loca.insert(1);
    while (K < 100) {
        if (K >= 10) {
            if (now_loca.find(1) == now_loca.end()) return K;
        }
        set<int> next_loca;
        for (int a : now_loca) {
            for (int b : graph[a]) {
                next_loca.insert(b);
            }
        }
        
        now_loca = next_loca;
        K++;
    }
    
    return -1;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    graph.resize(N+1);
    int l, r;
    
    for (int i=1; i<=N; i++) {
        cin >> l >> r;
        graph[i].push_back(l); graph[i].push_back(r);
    }
    
    cout << get_num();

    return 0;
}

```



> ## 문제
>
> **이 문제는 "게임 오브 데쓰 (Hard)" 문제와 볼드체로 적혀 있는 부분의 조건이 다르다.**
>
> (아싸~) 신난다 (아싸~) 재미난다 더 게임 오브 데쓰! (빠밤)
>
> 인트로 구호 마지막의 데'쓰', 또는 빠'밤'과 동시에 참가자들은 아무나 손가락으로 가리킨다. 이후 주최자가 아무 수를 부르면 주최자의 손가락부터 시작되어 가리켜진 사람에게 넘어가면서 수를 하나씩 카운트하며 이 과정이 계속 반복된다. - 나무위키
>
> 형진이는 본인을 포함하여 N명과 함께 술 게임을 하게 됐다! 게임이 시작되면 모든 참가자는 1번부터 N번까지의 번호를 부여받고 왼손과 오른손으로 자신을 제외한 다른 사람을 지목해야 한다. 같은 사람을 두 번 지목할 수도 있다.
>
> 지목이 끝나면 1번 참가자가 10≤K≤99 범위의 양의 정수 K를 정해 말한 후, K의 값을 1 줄인 뒤 본인이 지목한 사람 중 한 명에게 차례를 넘긴다. 차례를 넘겨받은 사람은 다시 K의 값을 1 줄인 뒤 지목한 사람 중 한 명에게 차례를 넘기고, 이 과정을 계속 반복해 K의 값이 0이 됨과 동시에 차례를 넘겨받은 사람이 패배하며 술을 마시게 된다.
>
> 형진이를 포함한 N명은 모두 만취했기에, 자신의 차례가 되면 자신이 지목한 둘 (같은 사람을 지목한 경우 하나) 중 무작위로 한 명에게 차례를 넘겨준다. 즉, **형진이를 포함한 모든 사람은 본인이** **어떠한 상대에게 차례를 넘겨줄지 알 수 없다**.
>
> 이번에 형진이가 1번을 부여받아 K의 값을 정하게 되었다. 각 사람이 누구를 지목했는지가 모두 주어졌을 때, 형진이가 패배하는 일이 없도록 적당한 K를 정해보자. 만약 어떠한 K를 고르더라도 형진이가 패배할 가능성이 있다면 `-1`을 출력한다.
>
> ## 입력
>
> 첫 번째 줄에 참여하는 사람 수 N이 주어진다. (2≤N≤1000)
>
> 다음 N개의 줄에는 각 참가자가 지목한 사람의 정보가 주어진다. 그중 i번째 줄에는 i번 참가자가 지목한 사람의 번호인 Li, Ri가 공백을 사이에 두고 주어진다. (1≤Li,Ri≤N, Li≠i, Ri≠i)
>
> ## 출력
>
> 문제의 조건을 만족하는 K (10≤K≤99)를 출력한다. 만약 그러한 K가 존재하지 않다면 `-1`을 출력한다.
>
> ## 해설
>
> 처음 문제를 보았을 때 그래프 순회처럼 한 노드에 최대 2개의 간선이 나가서 다른 노드에 연결되는 방식으로 문제를 보고 BFS를 돌리려고 했다
>
> 음 그러나 그냥 BFS를 돌리면 계속해서 모든 횟수마다 2배씩 늘어나 턴이 늘어남에따라 개수가 엄청나게 불어날 것이라고 생각했다... 이를 해결할 수 있는 방법으로 set를 이용하기로 했다. set에서 중복을 걸러주어 진행하면 최악의 경우라도 set안에는 순회할 노드가 최대 1000개 밖에 들어가지않고 매 턴의 연산마다 2 * 1000 씩 최대 100회 까지 진행하면 되는 것이었다. 따라서 이렇게하면 시간초과가 나지 않을 것이라고 생각했다.
>
> > 1. 주어진 입력을 받아 간선의 관계를 기록한다.
>>
> > 2. 턴의 개수를 세어줄 변수 K를 선언한다.
>>
> > 3. 현재 순회해야할 노드의 목록을 담을 set now_loca를 선언한다 그 후 가장 먼저 시작하는 1을 넣는다.
>>
> > 4. K가 100보다 작은 동안 순회한다. 
>>
> >    4-1. 현재 now_loca에 있는 모든 노드들을 순회하여 도착할 수 있는 노드를 set next_loca에 insert 한다.
>>
> >    4-2. 4-1이 끝나면 now_loca를 next_loca로 바꾸고 K의 값을 하나 늘린다.
>>
> > 5. 만약 반복 중에 K가 10 이상일때 현재 now_loca에 1이 들어가 있지 않다면 1이 걸리지 않는 순간이므로 즉시 현재 K 값을 반환한다.
>>
> > 6. 만약 K가 100이 될때까지 5번의 경우가 발생하지 않는다면 -1을 반환한다.
> 
> 의외로 수월하게 풀려서 만족스러운 문제였다.. 그런데 알고리즘을 분류를 보니 DP?가 있었다
> 
> 풀이방법을 보아하니 `최대 턴의 개수 100 * 최대인원수 1000`의 사이즈를 가지는 2차원 DP를 선언해 모든 턴에 대하여 계산을 하고 10부터 100까지 기록되어 있는지 확인하는 방식인것 같았다.
> 
> 흠... 나는 K가 발견되자마자 했는데 왜 내가 더 느릴까 했는데 아무래도 unordered_set를 하지 않아서 그런것 같다. set도 찾는 연산은 결국 log2n 이기 때문에 그런것 같다! 이것도 바꿔서 하면 좋을 듯 하다!
