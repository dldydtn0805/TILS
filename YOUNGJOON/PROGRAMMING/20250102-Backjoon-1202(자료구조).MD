# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;


int N, K;
vector<int> backpack;
vector<pair<int, int> > jewelry;

void pick_up()
{
    long long result = 0;
    int idx = 0;
    priority_queue<int, vector<int>, less<int> > que;
    
    for (int i=0; i<K; ++i) {
        while (backpack[i] >= jewelry[idx].first && idx != N) {
            que.push(jewelry[idx].second);
            idx++;
        }
        if (!que.empty()) {
            result += que.top();
            que.pop();
        }
    }
    
    cout << result;
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N >> K;
    int price, weight;
    
    for (int i=0; i<N; ++i) {
        cin >> weight >> price;
        
        jewelry.push_back({weight, price});
    }
    
    for (int i=0; i<K; ++i) {
        cin >> weight;
        backpack.push_back(weight);
    }
    
    sort(backpack.begin(), backpack.end());
    sort(jewelry.begin(), jewelry.end());
    
    pick_up();

    return 0;
}

```



# 해설

> ## 문제
>
> 세계적인 도둑 상덕이는 보석점을 털기로 결심했다.
>
> 상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.
>
> 상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)
>
> 다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)
>
> 다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)
>
> 모든 숫자는 양의 정수이다.
>
> ## 해설
>
> 처음 문제를 봤을 때 떠올린 것은 배낭 문제 였다 그런데... 조금 더 문제를 보면서 살펴보니까 가방에는 어차피 보석 단 1개 밖에 못넣는데 제일 좋은걸 넣으면 되는거 아닌가? 라는 생각이 들었다.
>
> 따라서 그리디 알고리즘과 이분 탐색으로 노선을 틀었다. 
>
> 이분 탐색을 채택하면  이분탐색을 이용해서 30만개를 탐색하면 약 18번 만에 탐색을 끝낼 수 있다.. 그렇다면 30만 * 18 정도면 충분하다고 생각했는데 이분 탐색을 사용했을 때 문제가 떠올랐다.
>
> > 1. 무게를 기준으로 탐색한다면 동일한 무게 중에 가치가 가장 좋은 보석은 어떻게 찾을 것 인가?
> > 2. 이미 가방에 넣은 보석이 다시 최적의 보석으로 채택 되었을때, 이를 어떻게 패스하고 다른 최적의 보석으로 연결 해 줄 것인가?
> > 3. 무게를 기준으로 채택했을 때, 가방의 무게와 가장 가까운 무게가 과연 가장 좋은 보석일까?
> > 4. 그렇다고 가치를 기준으로 이분 탐색을 하려니 기준이 존재하지 않는다. 
>
> 위와 같이 문제가 계속 떠올라서 이분 탐색은 아니라고 생각하였다. 
>
> 그런데 그리디로 하자니... 어떤 기준으로 하여야 그리디를 구현할 수 있을지가 문제였다.
>
> 주어지는 보석의 정보는 가치와 무게인데... 
>
> 가치를 기준으로 정렬을 하면? 해당 가치의 보석을 넣을 가방을 찾아야하고 **모든 보석이 모든 가방에 들어가지 않는  `최악의 경우 N * K` **의 횟수가 발생해 시간초과가 날것이 분명했다.
>
> 그렇다고 무게를 기준으로 정렬을 하니까 가방에 넣을 수 있는 동일한 기준의 무게들을 전부 보고 그 중에서 가장 좋은 보석을 넣어야했는데... 그럼 나머지 후보에서 탈락한 보석들을 다시 보석들을 담은 자료구조에 넣어주어야 한다고 생각해서 이것 또한 **모든 보석이 모든 가방에 들어가는 무게인 `최악의 경우  N * K를 초과`**할 것이라고 생각했다. 
>
> 계속해서 여러 방면으로 생각해봤는데 계속해서 반례가 떠올라서 결국에는 다른 사람의 풀이에서 힌트를 얻었다.
>
> 그랬더니 무게를 기준으로 정렬한 방식에서 생각의 전환을 하면 되는 것이었다.
>
> 가방과 보석을 무게 기준으로 오름차순으로 정렬한다.
>
> 그 후 모든 가방을 순회하며 우선순위 큐를 내림차순으로 선언해 현재 가방에 들어갈 수 있는 모든 보석들을 우선순위 큐에 가치만 넣는다.
>
> 이렇게 되면 아까 위에서 내가 생각한 무게를 기준으로 정렬하는 경우와 비슷해지는데, 여기서 해당 우선순위 큐를 다시 보석을 담는 자료구조에 집어 넣는것이 아니라, 그냥 둔다.
>
> 가방을 오름차순으로 정렬 했을때 자신의 이전에 넣을 수 있는 보석은 반드시 자신도 넣을 수 있게된다. 따라서 현재 우선순위 큐에 들어있는 모든 보석들은 현재 가방에 넣을 수 있게 되는 것이다. 따라서 현재 우선순위 큐에서 가장 가치가 높은 보석을 가방안에 넣고 다음 가방을 살펴보며 해당 가방이 넣을 수 있는 모든 보석을 우선순위 큐에 추가한다.
>
> 이와 같이 진행하면 아까전에 반례로 생각했던 **`모든 보석이 모든 가방에 들어가는 무게인 최악의 경우`**는 첫번째 가방에서 모든 보석이 우선순위 큐 안으로 들어가게 되고, 이후 부터는 그냥 우선순위 큐에서 보석을 꺼내 가방안에 넣어주기만 하면 되는 것이므로 아주 간단하게 연산이 끝난다!
>
> 발상의 전환이 필요한 문제?였던 느낌이다.. 사실 처음 풀이에서 보석은 굳이 우선순위 큐에 저장하고 했었는데 이것도 굳이 필요없었던 일이었다...
>
> 조금 아쉽다 그냥 반례 하나 생각난다고 이 방법이 아니야! 하고 바로 버리기 보다는... 좀 더 디벨롭해서 하면 될 수 도 있지 않을까하는 생각도 좀 가져봤으면 좋겠다... 다음에는 꼭 혼자 풀 수 있기를...

 
