# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

#define pll pair<int, int>

using namespace std;

int N;
vector<int> board(15, 0);
int result = 0;

bool checking(int low)
{
    for (int i=0; i<low; ++i) {
        int one = abs(i - low);
        int two = abs(board[i] - board[low]);
        if (board[i] == board[low] || one == two) return true;
    }

    return false;
}

void set_queen(int x)
{
    if (x == N) {
        result++;
        return;
    }
    
    for (int j=0; j<N; ++j) {
        
        board[x] = j;
        
        if (!checking(x)) {
            set_queen(x+1);
        }
    }
    
    return;
}

int main()
{
    cin >> N;
    
    set_queen(0);
    
    cout << result;

    return 0;
}

```



> ## 문제
>
> 어떤 수열이 다른 수열의 부분 수열이라는 것은 다음을 의미합니다.
>
> - 해당 수열의 원소들이 다른 수열 내에서 순서대로 등장합니다.
> - 예를 들어, {1,1,5}는 {3,1,4,1,5,9}의 부분 수열이지만, {1,5,1}의 부분 수열은 아닙니다.
>
> 또한, 어떤 수열이 다른 수열보다 사전 순으로 나중이라는 것은 다음을 의미합니다.
>
> - 두 수열 중 첫 번째 수가 큰 쪽은 사전 순으로 나중입니다.
> - 두 수열의 첫 번째 수가 같다면, 첫 번째 수를 빼고 두 수열을 다시 비교했을 때 사전 순으로 나중인 쪽이 사전 순으로 나중입니다.
> - 길이가 0$0$인 수열과 다른 수열을 비교하면, 다른 수열이 사전 순으로 나중입니다.
>
> 양의 정수로 이루어진 길이가 N인 수열 {A1,⋯,AN}이 주어집니다. 마찬가지로 양의 정수로 이루어진 길이가 M인 수열 {B1,⋯,BM}이 주어집니다.
>
> 수열 A와 수열 B가 공통으로 갖는 부분 수열들 중 사전 순으로 가장 나중인 것을 구하세요.
>
> ## 입력
>
> 첫 줄에 수열 A의 길이 N이 주어집니다. (1≤N≤100)
>
> 둘째 줄에 N개의 양의 정수 A1,A2,⋯,AN이 주어집니다. (1≤Ai≤100)
>
> 셋째 줄에 수열 B의 길이 M이 주어집니다. (1≤M≤100)
>
> 넷째 줄에 M개의 양의 정수 B1,B2,⋯,BM이 주어집니다. (1≤Bi≤100)
>
> ## 해설
>
> 문제를 처음 봤을 때 LCS를 구하면 LCS가 최대 길이의 공통 부분 수열이기 때문에, 그 안에서 사전 순으로 가장 앞서는 부분 수열을 추가로 구하면 된다고 생각했다.
>
> 처음 2차원 DP를 선언해 LCS를 구하고, 해당 LCS를 추적하여 LCS를 이루는 숫자들의 배열을 만든 다음 해당 숫자들에서 그리디를 이용해 사전 순으로 가장 앞서는 부분 수열을 만들었다.
>
> 그런데 왠걸? 바로 틀려버렸다.
>
> 그 반례는 아래와 같다.
>
> ```
> 5
> 4 3 3 4 4
> 5
> 4 4 3 3 4
> ```
>
> - 위의 반례에서 LCS는 {4,  3, 3, 4}가 된다. 그러나 사전 순으로 가장 앞서는 부분 수열은 {4, 4, 4}이다...
> - 즉, LCS안에 반드시 사전 순으로 가장 앞서는 부분 수열이 존재한다는 보장이 없던 것이다!
>
> 음.. 그래서 결국 LCS를 구할때 길이를 우선순위로 두지 않고 현재 부분 수열의 사전 적 우선 순위를 두고 저장을 하였다
>
> 그러기 위해서 각 2차원 DP에 현재 길이와, 부분 수열을 페어로 묶어 저장하고, LCS에서 대각선 위치에 있는 값을 가져올 때 현재 숫자를 해당 배열의 사전 우선 순위에 맞게 수정하고 저장하였다.
>
> 또한 현재 위치의 값이 다르면 위와 왼쪽의 값을 가져올때 가지는 우선순위를 부분 수열의 사전적 우선 순위를 두고 가져왔다.
>
> 상당히 비효율적이라고 생각해서.... 걱정이 많았는데 역시나 틀렸다.
>
> LCS에서 대각선 위치에 있는 값을 가져올 때 현재 숫자를 해당 배열의 사전 우선 순위에 맞게 수정하고 저장하는 부분에서 현재 위치의 숫자가 부분 수열의 중간에 들어가면 그 이후의 값들을 전부 잘라내야한다는 걸 까먹어버렸다.
>
> 해당 기능을 추가하고 제출했더니 의외로 빠르게 맞았다. 하지만... 비효율적이여 보이는건 다른게 없어서 다른 사람의 코드를 봤고 역시나 평균적으로 봤을때도 메모리나 시간적으로도 성능이 뒤쳐졌다.
>
> 다른 사람은 LCS를 이용하지않고 순수하게 그리디로 풀어냈다.
>
> ```
> a = {1, 2, 3, 7, 5, 6, 6}
> b = {2, 7, 4, 5, 3, 2}
> ```
>
> 
>
> > 1. 배열 a, b를 두고 두 배열의 최댓값을 찾는다. 만약 최댓값이 같다면 각 배열에서 해당 값까지 이동하며 값들을 제외한다.
> >
> >    ```
> >    a와 b의 최댓값 = 7으로 같으므로 7까지 이전 값들을 제외
> >    a = {7, 5, 6, 6}
> >    b = {7, 4, 5, 3, 2}
> >    ```
> >
> > 2. 이제 두 값의 최댓 값을 빼서 배열 c에 저장한다.
> >
> >    ```
> >    a = {5, 6, 6}
> >    b = {4, 5, 3, 2}
> >    c = {7}
> >    ```
> >
> > 3. 1을 반복한다. 단, 둘의 최댓값이 다르다면 더 높은 최댓값을 가진 배열에서 해당 값들을 전부 뺀다.
> >
> >    ```
> >    a의 최댓값 6, b의 최댓값 5로
> >    a에서 6을 모두 뺀다.
> >    a = {5}
> >    b = {4, 5, 3, 2}
> >    c = {7}
> >    ```
> >
> > 4. 위의 과정을 반복하다보면 아래와 같이 된다.
> >
> >    ```
> >    a = {}
> >    b = {4, 3, 2}
> >    c = {7, 5}
> >    ```
> >
> > 5. 이제 c에서 사전순으로 앞서는 부분 수열을 만든다.
> >
> >    c에서 최댓값을 꺼내고 최댓값 앞에 있는 모든 수는 버린다. 이를 c가 남아있을때까지 반복한다. 그러면 사전 순으로 앞서는 부분 수열 완성!
>
> 위와 같이 그리디로 풀면 굳이 LCS를 안써도 되고, 배열에 일일이 현재 부분 수열을 저장할 필요도 없어서 상당히 효율적이다!
>
> LCS를 연습할겸 써본건 나쁘지 않지만 이렇게 푸는게 효율적이라는 걸 기억해두자!

