# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

long long A, B;

vector<long long> dp(54, 0);

long long check_one(long long num)
{
    if (num == 0) {
        return 0;
    }
    
    long long now_ones = 1;
    int power = 0;
    long long now = 1;
    dp[0] = 1;
    while (true) {
        long long next = now * 2;
        if (next == 2) {
            now = next;
            now_ones++;
            power++;
            dp[1] = 2;
        }
        else if (next <= num) {
            now_ones *= 2;
            now_ones += now - 1;
            power++;
            now = next;
            if (dp[power] == 0) {
                dp[power] = now_ones;
            }
        }
        else {
            long long gap = num - now;
            long long gap_now = 0;
            int depth = 0;
            while (gap >= 1) {
                long long compare = 1;
                int gap_power = 0;
                while ((compare * 2) <= gap) {
                    gap_power++;
                    compare *= 2;
                }
                gap -= compare;
                gap_now += dp[gap_power];
                gap_now += compare * depth;
                depth++;
            }
            
            now_ones += gap_now + (num - now); 
            break;
        }
    }
    
    return now_ones;
    
}

int main()
{
    cin >> A >> B;
    long long result = 0;
    
    long long target = 0;
    target += check_one(B) - check_one(A - 1);

    cout << target;

    return 0;
}

```



# 해설

> ## 문제
>
> 두 자연수 A, B가 주어졌을 때, A ≤ x ≤ B를 만족하는 모든 x에 대해 x를 이진수로 표현했을 때 1의 개수의 합을 구하는 프로그램을 작성하시오.
>
> 즉, f(x) = x를 이진수로 표현 했을 때 1의 개수라고 정의하고, 아래 식의 결과를 구하자.
>
>  ∑x=ABf(x)\[\sum_{x=A}^{B}{f(x)}\] 
>
> 
>
> ## 입력
>
> 첫 줄에 두 자연수 A, B가 주어진다. (1 ≤ A ≤ B ≤ 10^16)
>
> ## 해설
>
> 처음 봤을때, DP가 편해보였지만 10^16만큼의 배열을 만드는 것은 불가능하므로, 바로 포기했다. 이어서 이진수들을 적고 그 특징을 보려고 했다.
>
> > 1 -1 - 1개
> > 10 -2 - 2개
> > 11 -3
> > 100 -4 -5개
> > 101 -5
> > 110 -6
> > 111 -7
> > 1000 -8 - 13개
> > 1001 -9
> > 1010 -10
> > 1011 -11
> > 1100 -12
> > 1101 -13
> > 1110 -14
> > 1111 -15
> > 10000 - 16 - 33개
> > 10001 -17
> > 10010 -18
> > 10011 -19
> > 10100 -20
> > 10101 -21
> > 10110 -22
> > 10111 -23
> > 11000 -24
> > 11001 -25
> > 11010 -26
> > 11011 -27
> > 11100 -28
> > 11101 -29
> > 11110 -30
> > 11111 -31
> > 100000 -32 - 81개
>
> 위의 이진수들의 특징을 보니, 2의 제곱 수는 무조건 개수가 1의 개수가 1이며 가장 앞의  수가 1, 나머지 수는 0이 된다.
>
> 그리고 그 이전에 있던 숫자들이 그 안에 자리를 잡아, 모든 빈칸이 1이 된 후 다음 숫자가 2의 제곱 수가 되어 다시 맨 앞의 수가 1, 나머지 수는 0이 되는 규칙을 찾았다.
>
> 이를 이용한다면 10^16의 크기의 배열을 만들지 않고도 문제를 풀 수 있다고 생각했다.
>
> 따라서 2개의 숫자를 입력 받은 후 A-1까지의 1의 개수를 구해, B까지의 1의 개수를 빼주면 답이 나온다고 생각했다.
>
> 1의 개수를 구하는법은 2^0부터 시작해서, 1의 개수를 누적하여 더했다. 그리고 각 제곱근에 위치한 숫자들을 지수의 값을 dp의 인덱스 값으로 하여 해당 지점의 값들을 저장하였다.
>
> 문제를 풀다보니까 또 특별한 특징을 찾아내었는데 1과 2만 있으면 모든 숫자를 만들 수 있다. 즉, 1 = 2^0, 2 = 2^1 이기 때문에 만약 2의 제곱수가 아닌 값이 A와 B에 들어오더라도,  계속해서 끝없이 나누어주면 결국에는 해당 숫자까지의 1의 숫자를 구할 수 있다는 것이었다!
>
> 1의 개수를 구하는 로직은 다음과 같다.
>
> > 1. 현재 주어진  숫자 N에 대하여 해당 숫자보다 작거나 같은 최대의 2의 제곱수까지 2.의 규칙을 이용해 1의 개수를 구한다.
> >
> > 2. 현재 구하는 2의 제곱수 2^m 는 (2^(m-1) 까지의 1의 개수) * 2 + 2^(m-1) - 1 를 만족한다.
> >
> >    - 예시를 들어보자 현재 구하는 수가 4라고 해보자 그렇다면 2^(m-1) = 2가 된다. 2까지의 1의 개수는 2이다. 위의 수를 적을 것을 확인해보면 아래와 같은 규칙을 찾을 수 있다.
> >
> >      > 1 -1 - 1개
> >      > 10 -2 - 2개
> >      > 11 -3
> >      > 100 -4 -5개
> >      >
> >      > ----
> >      >
> >      > 101 -5
> >      > 110 -6
> >      > 111 -7
> >      > 1000 -8 - 13개
> >
> >      - 보면 4에서 1~3까지의 이진수를 더한 값이 5, 6, 7이 된다.. 즉, 1, 10, 11이 다시 반복되므로 1의 숫자는 당연히 2배가 된다. 단, 4와 8은 2의 제곱수로 숫자가 1개이다!
> >      - 위에서 4에서 1~3까지의 이진수를 더한다고 하였고 4는 3번째 자리의 1이 있는 것이다. 그렇다면 추가하는 1~3까지의 모든 숫자에 1이 1개씩추가되는 것이다. 단, 8은 4에서 1을 추가한 값이 아니고 반드시 1이 한개라는 특성 때문에 여기서 `1~4까지의 숫자의 개수 - 1` 개의 갯수를 1의 개수의 추가한다.
> >      - 이때 각 지수에 해당하는 값을 인덱스로 하여 dp에 미리 저장해 놓는다.
> >
> > 3. 이렇게 하면 현재 숫자보다 작거나 같은 최대의 2의 제곱수의 1의 갯수를 구할 수 있다.
> >
> > 4. 만약, 현재 숫자가 2의 제곱수에 딱 떨어지지 않는다면 나머지 숫자에 대한 1의 제곱 수를 구해야 한다. N - 2^m (단, N > 0일때의 m은 이를 만족하는 최대값) 만큼의 값에 대해서 1의 개수를 찾는다. 이는 5. 의 규칙을 따른다.
> >
> > 5. 간단한 예시와 함께 살펴보자
> >
> >    > 나머지가 23이라면?
> >    > 23에서 16을 뺀다(dp\[4] = 33) 나머지 7이 된다.
> >    > 7에서 4를 뺀다 이때 깊이인 1을 4만큼 추가로 더한다(5(dp\[2]) + 4 = 9)
> >    > 3에서 2를 뺀다. 이때 깊이인 2를 2만큼 추가로 더한다 (2(dp]\[1]) + 2*2 = 6)
> >    > 1에 깊이 3을 추가로 더한다. (1(dp[0]) + 3 = 4)
> >    > 나머지는 즉 33 + 9 + 6 + 4 = 52
> >
> >    - 위의 예제에서 볼 수 있듯이 나머지에서도 마찬가지로 나머지 K보다 작은 가장 큰 2의 제곱수 만큼을 빼고 해당 제곱수에 기록된 1의 개수를 dp에서 찾는다. 이 과정을 K가 0이 될때까지 반복한다.
> >    - 단, 특이한 점을 볼 수 있는데 깊이에 따라서 1의 개수가 추가되고 있다. 이는 아래의 예제를 보면 알 수 있다.
> >
> >    > 1 -1 - 1개
> >    > 10 -2 - 2개
> >    > 11 -3
> >    > 100 -4 -5개
> >    > 101 -5
> >    > 110 -6
> >    > 111 -7
> >    > 1000 -8 - 13개
> >    > 1001 -9
> >    > 1010 -10
> >    > 1011 -11
> >    > 1100 -12
> >    > 1101 -13
> >    > 1110 -14
> >    > 1111 -15
> >    > 10000 - 16 - 33개
> >    > 10001 -17
> >    > 10010 -18
> >    > 10011 -19
> >    > 10100 -20
> >    > 10101 -21
> >    > 10110 -22
> >    > 10111 -23
> >
> >    - 16까지를 빼고난다면 우리는 17~23까지의 숫자들의 개수를 구해야한다. 그러나 나머지는 7을 뜻하고 있다. 하지만 위에서 알아본 규칙성에 따르면 결국 2진수에서 17은 1에서 16을 더한것이고, 18은 2에서 16을 더 한 것이다. 따라서 4까지 뺀다면 16의 이후의 숫자처럼 1개씩 더해주어야한다.
> >    - 그런데 3부터는 왜 2개씩 더할까? 현재 나머지는 21~23의 숫자를 구해야한다. 그런데 21은 16 + 5이다 그리고 5는 4 + 1이다. 그렇다면 현재 우리가 2를 뺄것이기 때문에 1과 2는 각각 4에서의 1추가와, 16에서의 1추가를 모두 겪은 값이 21과 22이가 되는것이다 따라서 제곱근을 덜어낸 횟수만큼 1의 개수가 추가되어야 하는것이다. 
> >    - 따라서 3-2 = 1이며 1은 2^0이므로 dp[0] = 1이다. 그러나 현재 그냥 1이 아닌 23을 보려고 하는 것이고 23 = 16 + 7이자, 4 + 3 이자, 2 + 1이므로, 총 3번의 1을 더해주어야 한다.
> >
> > 6. 다음과 같은 규칙으로 나머지 값에서의 1의 개수를 구하여 2. 에서 구한 값과 5. 에서 구한 값을 더해주면 해당 숫자까지의 1의 개수가 된다.
>
> 위와 같은 로직을 구현하여 문제를 풀었다. 그런데 호기롭게 제출했더니 틀렸고, 극단적인 반례를 하나 사용해서 확인해보았다.
>
> ```
> 10000000000000000 10000000000000000
> 답 : 20
> ```
>
> 그런데 나는 36이 나왔다.. 아무리 생각해도 뭔가 이상했다.. 값이 작을 때는 문제없이 로직이 수행이 됬기 때문이다.. 그래서 아래의 반례를 추가로 얻어서 돌려보았다.
>
> ```
> 999999999999999 9999999999999999
> 답 : 239502115812196386
> ```
>
> 위의 반례에서 답이 239502115812196391 이 나왔다. 상당히 숫자가 비슷해보여서 무언가 문제일까 고민하다가 cmath.pow가 double의 자료형을 반환하여 실수형으로 내놓기때문에, 소수점에 의한 문제로 정확한 값이 나오지 않을 수 있다는 것 이었다. 따라서 비교연산을 pow를 이용해서 하면 값이 커질 때 정확도가 떨어져 문제가 생길 수 있다고 하였다. 따라서 어차피 long long을 사용하면 2^64까지의 수는 커버가 가능하고 10^16보다 작은 최대의 2의 제곱수는 2^53이어서 2^54까지 가도 문제가 발생하지 않을 것이라 생각하여, 그냥 순수하게 2를 곱해주어 해당 제곱수를 구하여 비교하는 등의 연산을 진행하였다.
>
> 이렇게 바꿔주니 바로 맞았다!
>
> 수학 문제라고 하면 상당히 못풀었는데... 이번엔 특이하게 빠르게 규칙을 찾아서 풀 수 있었다... 기분이 좋다.. 그리고 pow가 double형을 반환한다는 것을 알았으니 이를 꼭 가져가서 다음에 문제 풀때 활용할때 유의하도록 하자!

