# 코드

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

int N;

int check_money(int total_money, vector<int>& coins, unordered_map<int, int>& coins_cnt)
{
    int half_money = total_money / 2;
    vector<vector<int> > dp(N, vector<int>(50001, 0));
    
    for (int i=0; i<N; ++i) {
        int repeat = coins_cnt[coins[i]];
        if (i == 0) {
            dp[i][0] = 1;
            for (int j=1; j<=repeat; ++j) {
                int tmp = coins[i] * j;
                if (tmp <= 50000) {
                    dp[i][tmp] = 1;
                    if (tmp == half_money) {
                        return 1;
                    }
                }
            }
        }
        else {
            for (int j=0; j<=50000; ++j) {
                if (dp[i-1][j] == 1) {
                    dp[i][j] = 1;
                }
                else {
                    for (int k=1; k<=repeat; ++k) {
                        int tmp = coins[i] * k;
                        if (j - tmp >= 0) {
                            if (dp[i-1][j - tmp] == 1) {
                                dp[i][j] = 1;
                                if (j == half_money) {
                                    return 1;
                                }
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        }
    }
    
    return 0;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    for (int t=0; t<3; ++t) {
        cin >> N;
        int total_money = 0;
        vector<int> coins;
        unordered_map<int, int> coins_cnt;
        int coin, cnt;
        for (int i=0; i<N; ++i) {
            cin >> coin >> cnt;
            total_money += (coin * cnt);
            coins.push_back(coin);
            coins_cnt[coin] = cnt;
        }
        
        if (total_money % 2 == 0) {
            cout << check_money(total_money, coins, coins_cnt) << "\n";
        }
        else {
            cout << 0 << "\n";
        }
    }

    return 0;
}
```



> ## 문제
>
> 윤화와 준희는 솔선수범하여 쓰레기를 줍는 착한 일을 하였다. 원장선생님께서는 윤화와 준희를 칭찬하시고 과자나 사 먹으라고 하시며 동전 몇 개를 윤화와 준희에게 건네 주었다.
>
> 그런데 돈을 받은 윤화와 준희는 좋아하기보다 고민에 빠지고 말았다. 원장선생님께 받은 이 돈을 어떻게 나누어 할지 고민에 빠진 것이다. 두 사람 모두 상대방이 자기보다 1원이라도 더 받는 것은 도저히 인정할 수 없어 한다. 따라서 돈을 똑같이 둘로 나누어 가져야 두 사람이 모두 만족할 수 있게 된다.
>
> 하지만 두 사람에게 돈을 똑같이 나누는 것이 불가능한 경우도 있다. 예를 들어 500원짜리 1개와 50원짜리 1개를 받았다면, 이 돈을 두 사람이 똑같이 나누어 가질 수는 없다. 물론 동전을 반으로 잘라서 나누어 가질 수도 있겠지만 그러면 돈으로서의 가치를 잃기 때문에 그렇게 할 수는 없다.
>
> 이제 우리가 할 일은 다음과 같다. 원장 선생님께서 N가지 종류의 동전을 각각 몇 개씩 주셨을 때, 그 돈을 반으로 나눌 수 있는지 없는지 판단하는 것이다.
>
> ## 입력
>
> 세 개의 입력이 주어진다. 각 입력의 첫째 줄에 동전의 종류 N(1 ≤ N ≤ 100)이 주어진다. 각 입력의 둘째 줄부터 N+1째 줄까지 각각의 동전의 금액과 개수가 빈 칸을 사이에 두고 주어진다. 단, 원장선생님께서 주신 금액의 총 합은 100,000원을 넘지 않는다. 동전의 금액과 개수는 자연수이고, 같은 금액을 가진 동전이 두 번 이상 주어지는 경우는 없다.
>
> ## 해설
>
> 처음 문제를 봤을 때는 어떠한 조합이 주어지는 값의 절반 값을 만들 수 있을지 알 수없으므로 어떻게든 다봐야한다고 생각했고 이를 보기위해 모든 동전의 조합을 짜기로 했다. 하지만 이렇게하니 시간초과가 나버려서 실패했다. 결국 알고리즘 분류를 봤더니 배낭 문제였다!
>
> 배낭 문제로 푼다고 생각하니 방법이 바로 떠올랐다. 모든 동전에 대해서 최대 값의 절반인 50000까지에 대해 해당 동전들을 썼을때 만들 수 있는 경우를 기록해 나가면 된다고 생각했다. 2차원 DP에 기록하는 값은 최소값일 필요 없이 T/F만 기록하면 된다고 생각했다. 진행 방식은 아래와 같다.
>
> > 0. 2차원 DP를 N*50001 사이즈로 선언한다. 그리고 DP\[0]\[0] = 1을 선언하여 단순히 현재 코인으로만 만들 수 있는 경우는 모두 체크할 수 있게 하였다.
> >
> > 1. N개의 코인을 순회한다. 현재 코인의 개수를 확인한다.
> >
> > 2. 만약 현재 코인이 첫 번째 코인이라면 현재 코인으로 만들 수 있는 모든 값을 1로 체크한다.
> >
> >    > DP\[0][만들 수 있는 코인 값] = 1 로 체크한다.
> >
> > 3. 만약 현재 코인이 첫 번째 코인이 아니라면 0~50000까지 순회한다.
> >
> >    3-1. 만약 이전 코인에서 현재 순회중인 값이 1로 체크되어있다면 `DP[i-1][j] == 1`  현재 순회중인 값도 1로 체크한다. `DP[i][j] = 1`
> >
> >    `단순히 만들 수 있는 경우를 체크해야하기 때문`
> >
> >    3-2. 만약 이전 코인에서 현재 순회중인 값이 0이라면 현재 순회중인 값에서 만들 수 있는 코인 값을 뺀 값이 이전 코인에서 1로 체크되어 있다면 1로 체크한다. 이 때 만들 수 있는 코인의 값이란 현재 코인에서 코인의 개수를 사용해서 만들 수 있는 값들이다.
> >
> >    `ex) 코인 값 = 2, 코인의 개수 = 2, 만들 수 있는 값 = {2, 4}` 
> >
> >    `DP[i-1][j - 현재 코인으로 만들 수 있는 값] == 1`  -> `DP[i][j] = 1`
> >
> > 4. 만약 2 or 3번을 실행중에 현재 주어진 동전의 값들의 절반에 해당하는 값이 1이 체크가 된다면 그 즉시 1을 반환한다.
> >
> > 5. 만약 2~3번을 모두 실행해도 절반에 해당하는 값에 1이 체크되지 않았다면 0을 반환한다.
>
> 위의 방법으로 풀었더니 가능했다! 문제의 조건에서 최대값이 10만, 주어지는 동전의 개수가 100개 이하라는 점을 고려해서 배낭 문제로 풀 수 있었던 것 같다.
>
> 생각보다 다른 코드에 비해 오래걸려서 왜인가 해서 봤더니 굳이 순회를 5만까지 할 필요없이 주어지는 값의 절반 값에 해당하는 값까지만 순회하면 더 편했을 것 같다! 그렇게 하면 2차원 배열의 사이즈도 줄어들어서 선언하는 비용도 줄어들고, N개가 순회할 개수도 줄어드니 시간도 더 절약할 수 있었을 것이다! 
