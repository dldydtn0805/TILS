# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    int N;
    cin >> N;
    vector<int> numbers, checking;
    numbers.resize(N);
    int now_length = 0;
    int result = 0;
    for (int i=0; i<N; ++i) {
        cin >> numbers[i];
        if (i != 0 && numbers[i - 1] == numbers[i]) {
            checking.push_back(now_length);
            now_length = 1;
        }
        else {
            now_length++;
            result = max(result, now_length);
        }
    }
    checking.push_back(now_length);
    
    int now_size = checking.size();
    if (now_size >= 3) {
        for (int i=0; i<now_size - 2; ++i) {
            int tmp = checking[i] + checking[i + 1] + checking[i + 2];
            result = max(result, tmp);
        }
    }
    else if (now_size == 2) {
        result = max(result, checking[0] + checking[1]);
    }
    
    cout << result;

    return 0;
}
```



> ## 문제
>
> 서강대학교의 축제 기간에 상근이는 매년 AS관 복도에 화려한 장식을 꾸민다. 장식은 전구 N개로 이루어져 있고, 전구는 왼쪽에서 오른쪽으로 일렬로 배열되어 있다. 각 전구는 불이 켜있을 수 있고, 꺼져있을 수도 있다.
>
> 상근이는 이 전구를 조작하기 위해서, 집에서 전구를 조작하는 기계를 가지고 왔다. 이 기계는 어떤 구간의 전구를 지정하면, 불이 켜있는 전구의 불을 끄고, 꺼져있는 전구의 불을 켜는 기능이 있다. 하지만, 이 기계는 상당히 오래된 기계로, 한 번 사용하면 다음 해까지 더 이상 사용할 수 없다.
>
> 서강대학교 학생들은 불이 켜있는 전구와 꺼져있는 전구가 번갈아가면서 나타나는 패턴을 좋아한다. 이러한 패턴을 교대 패턴이라고 한다. 따라서, 상근이는 이 기계를 1번만 사용해서 가장 긴 교대 패턴을 만들기로 했다.
>
> 예를 들어, 전구가 아래와 같이 배열되어 있다고 하자. (○는 불이 들어와 있는 전구, ●는 꺼져있는 전구)
>
> ○ ○ ● ● ○ ● ○ ○ ○ ●
>
> 4번째부터 7번째까지 4개 전구에 기계를 사용하면 아래와 같이 된다.
>
> ○ ○ ● ○ ● ○ ● ○ ○ ●
>
> 위의 경우에는 2번째부터 8번째까지 전구가 길이가 7인 교대 패턴을 이룬다.
>
> 또, 8번째 전구에만 기계를 조작하면 아래와 같이 된다.
>
> ○ ○ ● ● ○ ● ○ ● ○ ●
>
> 이렇게 되면, 4번째부터 10번째까지 전구가 길이가 7인 교대 패턴을 만든다.
>
> 즉, 기계를 최대 한 번만 사용해서 길이가 8 이상인 교대 패턴을 만들 수 없다.
>
> 전구의 정보가 주어졌을 때, 기계를 최대 한 번 사용해서 얻을 수 있는 가장 긴 교대 패턴의 길이를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 전구의 개수 N이 주어진다. (2 ≤ N ≤ 100,000)
>
> 두 번째 줄에는 전구의 상태가 왼쪽 전구부터 순서대로 주어진다. 전구의 상태는 1 또는 0이며, 1은 불이 켜져있는 상태, 0은 불이 꺼져있는 상태이다.
>
> ## 출력
>
> 첫째 줄에 상근이가 기계를 최대 한 번 사용해서 얻을 수 있는 가장 긴 교대 패턴의 길이를 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을때 2차원 DP를 이용해 구간을 나누어 각각 구간에 대한 연속된 개수를 구하고 변환 했을 때와 변환 하지 않았을 때 2개의 2차원 DP로 구현하려고 했으나... 구간을 나누는 것은 결국 10만 * 10만의 연산이 필요해보였고 이미 바꿨을 때와 바꾸지 않았을 때의 경계가 명확히 나누는게 어려워 보였다...
>
> 결국 모든 인덱스에서 규칙에 어긋나는 것을 만날때까지 진행하면서 해보려고 했으나... 음 계속 바꿀때마다 개수를 새로 새어주어야했고, 이는 연산 한번에 10만번의 연산이 필요해지는 것이므로 더 안좋다고 생각했다...
>
> 결국 고민만 계속하다가 알고리즘 유형을 봤는데 `DP 및 애드혹`이었다. 흠 그런데 애드혹은 특별한 알고리즘 없이 규칙을 찾으면 풀 수있다는 유형이었다... 그걸 알고 봐도 흠 규칙이 영 보이지 않았다... 그래서 결국 다른 사람의 코드를 봤는데 방식이 상당히 흥미로웠다.
>
> > 1. 주어지는 입력을 받을 때 규칙이 연속되는 구간의 길이들을 구한다.
> >
> >    ex) 1 0 0 1 0 1 0 1 일 때, {1, 0}, {0, 1, 0, 1, 0, 1}이렇게 나뉘는 것이다.
> >
> > 2. 주어지는 구간들의 특징이 있는데,  구간 A, B, C가 있을때 B를 반대로 뒤집으면 A B C는 이어진다.
> >
> >    - ex) {1, 0} {0, 1, 0} {0, 1} 이 있을때 B에 해당하는 {0, 1, 0}을 뒤집으면 {1, 0, 1, 0, 1, 0 ,1} 이 된다. 값이 0 or 1밖에 없고, 뒤 구간이 나뉘는 이유는 각각 구간의 양 끝이 서로 같기 때문인데 가운데를 바꾸면 두 접점이 달라지게 되므로 합쳐지는 것이다.
> >
> > 3. 따라서 규칙이 연속되는 구간들의 길이를 받아 어떠한 한 구간을 바꿨을 때 길이가 최소가 되는 구간을 찾는 것이다.
> >
> >    3-1. 구간이 1개일 떄
> >
> >    - 해당 구간이 가장 긴 구간으로 해당 구간을 출력한다.
> >
> >    3-2. 구간이 2개일 때
> >
> >    - 둘 중 어느 구간을 뒤집어도 두 개의 구간이 합쳐지므로 두 구간의 합을 출력한다.
> >
> >    3-3. 구간이 3개 이상 일 때
> >
> >    - 임의의 연속된 구간 3개를 골라 가운데 구간을 뒤집으면 해당 3개의 구간이 합쳐진다. 즉 연속된 3개의 구간의 합중 가장 큰 값을 출력한다.
>
> 위의 방법을 이용해 문제를 풀 수 있었다. 흠... 애드혹 문제라 그런가 상당히 규칙을 찾는게 중요했던 것이다.. 아이고... 이런 문제는 흠.. 손으로 그려보면서 푸는게 좀 더 규칙파악에 도움이 될 것 같다... 애드 혹 문제도 좀 풀어볼 필요가 있겠다..!
