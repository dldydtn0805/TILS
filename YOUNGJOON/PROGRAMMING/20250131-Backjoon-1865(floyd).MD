# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int T, N, M, W;
vector<vector<int> > graph;

void floyd()
{
    for (int k=1; k<=N; ++k) {
        for (int i=1; i<=N; ++i) {
            for (int j=1; j<=N; ++j) {
                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
            }
        }
    }
    
    for (int i=1; i<=N; ++i) {
        if (graph[i][i] < 0) {
            cout << "YES" << "\n";
            return;
        }
    }
    cout << "NO" << "\n";
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> T;
    
    for (int t=0; t<T; ++t) {
        cin >> N >> M >> W;
        int s, e, dist;
        graph.clear();
        graph.resize(N+1, vector<int>(N+1, 10001));
        
        for (int i=0; i<M; ++i) {
            cin >> s >> e >> dist;
            if (graph[s][e] > dist) graph[s][e] = dist;
            if (graph[e][s] > dist) graph[e][s] = dist;
        }
        
        for (int i=0; i<W; ++i) {
            cin >> s >> e >> dist;
            if (graph[s][e] > dist * -1) {
                graph[s][e] = dist * -1;
            } 
        }
        
        floyd();
        
    }

    return 0;
}

```



> ## 문제
>
> 때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단 도로는 방향이 없으며 웜홀은 방향이 있다.) 웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데, 특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다. 웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.
>
> 시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다. 한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다. 여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.
> 
>## 입력
> 
>첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다. 그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데 각 테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500), 도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다. 그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다. S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다. 그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점, E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.
> 
> 두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.
> 
>## 해설
> 
>문제를 처음 봤을 때 플루이드 워샬이 떠올랐다. T 가 5개이고 지점의 개수가 500개 이므로 500^3은 약 1.45억 이게 5개면 최악의 경우 7.25억 정도인데... 음 이게 가능할까 싶었지만 플루이드 워샬은 참조의 지역성 덕분에 단순히 계산한 최악의 경우보다는 빠르게 돌아간다고 들어서 한번 시도해보기로 했다.
> 
>문제의 조건에 같은 지점을 잇는 도로가 여러개 주어진다고 했으므로 최적의 도로를 찾을 필요가 있었다. 어차피 플루이드 워샬을 이용할 예정이니 2차원 배열을 선언하여 해당 배열에 간선 정보를 저장해두기로 했다.
> 
>주어지는 M개의 도로는 양방향 도로이기 때문에 주어질 때 \[s]\[e] , \[e]\[s] 둘 다 기록해준다. 어차피 시간이 줄어드는 경우를 따져야하니까 결국엔 최단거리로 가는것이 유리할 것이다 그래서 여러개의 같은 지점을 잇는 도로 중 가장 시간이 적게드는 도로를 채택하여 기록한다.
> 
>주어지는 W개의 웜홀은 단방향이기 때문에 주어질때 \[s][e]만 기록해준다. 주어지는 숫자를 음수로 봐야하기 때문에 -1을 곱해서 판단했다.
> 
>웜홀이 있으면 굳이 도로를 이용할 이유가 없다. 그래서 즉 도로를 기록한 2차원 배열에 같이 기록해주면 됬다. 단, 단방향임을 꼭 기억해둬야했다.
> 
>이제 플루이드 워샬을 돌려 다시 자신으로 돌아오는 가중치가 음수인지 확인한다.
> 
>기존 플루이드 워샬은 본인으로 돌아오는 값을 0으로 두고 계산하였지만, 이번에는 해당 값이 음수가 되는지 확인해야되었기 때문에 처음 초기화한 값인 10001로 기록해두었다.
> 
>플루이드 워샬이 끝나면 모든 노드에 대해서 자신으로 돌아오는 값이 음수라면 어느 한 지점에서 다시 자신으로 시간이 줄어든 채 돌아오는 것이 가능하다는 것이므로 YES를 출력했다.
> 
>모든 노드에 기록된 값이 양수라면 시간이 줄어든 채 돌아오지 못하므로 NO를 출력한다.
> 
>처음에 예상했던것과 달리 의외로 실행시간이 빨랐다... 엄청나게 최악의 케이스는 없었던 것 같다.
> 
>문제를 살펴보다 보니 이 문제는 `벨만-포드 알고리즘`을 이용하길 바란 문제였다.
> 
>예전에 수업에서 한번 들어본적 있는데 기억이 가물가물해서 한번 복습해야겠다.
> 
> ### 벨만-포드 알고리즘
> 
> - 다익스트라 알고리즘은 최단 거리를 찾을 수 있으나 이는 모든 간선이 양수의 가중치를 가질때만 가능하다. 만약 음수의 가중치를 가진 간선이 있다면 불가능하다.
> 
> - 음수의 가중치를 가진 간선이 있는 경우의 최단 거리를 구해나갈 수 있는 방법이 벨만-포드 알고리즘이다.
>
>   단, 다익스트라 알고리즘은 시간 복잡도가 O(ElogV)인 반면 벨만 포드는 O(VE)이다.
> 
>- 벨만 포드 알고리즘은 한 노드에서 다른 노드까지의 최단 경로를 많아야 V-1개의 간선을 지난다는 가정으로 진행하기 때문에 최단 경로가 V-1보다 많은 간선을 지난다면 음의 싸이클이 존재한다는 뜻이다.
> 
>#### 진행방식
> 
>> 1. 출발 노드를 설정한다.
> >
>> 2. 최단 거리 테이블을 초기화 한다.
> >
>> 3. 아래의 과정을 (V - 1)[V는 정점의 개수]번 반복한다.
> >
>>    3-1. 모든 간선 E개를 하나씩 확인한다.
> >
>>    3-2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
> >
>> 4. 만약 음수 간선 싸이클이 발생하는지 체크하고 싶다면 3번 과정을 한번 더 수행했을 때 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재하는 것이다.
> 
> - 위처럼 음수 간선 순환이 있다면 시간이 줄어든채로 되돌아오는 방법이 있다는 얘기가 된다.
> 
> 다음에 한번 벨만 포드 알고리즘으로 풀어보면 좋겠다!
>
> 
