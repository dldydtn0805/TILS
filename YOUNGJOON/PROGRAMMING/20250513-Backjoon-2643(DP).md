# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

#define pll pair<int, int>

using namespace std;

struct Compare {
    bool operator()(const pll& a, const pll& b) {
        if (a.first == b.first) {
            return a.second > b.second;
        }
        return a.first > b.first;
    }
};

int N;
vector<pll> papers;

void set_paper()
{
    int result = 0;
    vector<int> DP(N, 1);
    for (int i=1; i<N; ++i) {
        for (int j=0; j<i; ++j) {
            if (papers[j].first >= papers[i].first && papers[j].second >= papers[i].second) {
                DP[i] = max(DP[i], DP[j] + 1);
            }
        }
    }

    for (int i=0; i<N; ++i) {
        result = max(result, DP[i]);
    }
    
    cout << result;
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    int s, e;
    for (int i=0; i<N; ++i) {
        cin >> s >> e;
        if (s > e) swap(s, e);
        papers.push_back({s, e});
    }
    
    sort(papers.begin(), papers.end(), Compare());

    set_paper();

    return 0;
}
```

> ## 문제
>
> 크기가 모두 다른 직사각형 모양의 색종이가 여러 장 있다. 색종이를 하나씩 올려 놓아, 되도록 많은 장수의 색종이들을 쌓으려고 한다.
>
> 새로 한 장의 색종이를 올려 놓을 때는 지금까지 쌓아 놓은 색종이들 중 맨 위의 색종이 위에 올려놓아야 하며 아래의 두 조건을 모두 만족해야 한다.
>
> - 조건 1 : 새로 올려 놓는 색종이는 맨 위의 색종이보다 크지 않아야 한다. 즉, 맨 위의 색종이 밖으로 나가지 않아야 한다.
> - 조건 2 : 새로 올려 놓는 색종이와 맨 위의 색종이의 변들은 서로 평행해야 한다.(색종이를 90˚돌려 놓을 수 있다.)
>
> 예를 들어, 아래의 그림 중에서 위의 두 조건을 모두 만족하는 경우는 (나)뿐이다.
>
> | ![img](https://upload.acmicpc.net/830e691c-1989-4613-8dc9-0257d20214fc/-/crop/216x156/0,0/-/preview/) | ![img](https://upload.acmicpc.net/830e691c-1989-4613-8dc9-0257d20214fc/-/crop/188x156/246,0/-/preview/) | ![img](https://upload.acmicpc.net/aded1664-9f0a-4026-bd52-37b978453881/-/preview/) | ![img](https://upload.acmicpc.net/f18e7a59-08a6-4156-9690-e9ff061a9d1f/-/preview/) |
> | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | (가)                                                         | (나)                                                         | (다)                                                         | (라)                                                         |
>
> 색종이는 두 변의 길이로 표현된다. (3, 5)는 두 변의 길이가 각각 3과 5인 색종이를 나타낸다. 예를 들어, 다음과 같이 7장의 색종이가 주어졌다고 하자 : (1, 2), (8, 7), (20, 10), (20, 20), (15, 12), (12, 14), (11, 12) 위의 조건을 만족하면서 가장 많이 쌓을 수 있는 색종이들의 순서는 (20, 20), (15, 12), (12, 14), (11, 12), (8, 7), (1, 2)이다.
>
> 입력으로 색종이들이 주어졌을 때, 위의 조건 1과 조건 2를 만족하면서 쌓을 수 있는 최대 색종이 장수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫 번째 줄에는 색종이의 장수가 주어진다. 다음 줄부터 각 줄에 색종이의 두 변의 길이가 주어진다. 두 변의 길이는 한 칸 띄어 주어진다. 색종이의 최대 장수는 100이고, 각 변의 길이는 1000보다 작은 자연수이다.
>
> ## 출력
>
> 쌓을 수 있는 최대 색종이 장수를 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을 때 우선순위 큐를 이용하면 되겠다고 생각했다. 주어지는 가로 세로 길이의 값 중 낮은 값을 앞에 두고 앞의 값이 가장 큰 값을, 앞의 값이 같다면 뒤의 값이 큰 값에 우선순위를 주어 순서대로 꺼내 합칠 수 있는 경우를 그리디하게 만들려고 했다 그러나 아래의 반례에 막혔다.
>
> ```
> 5
> 20 20
> 10 20
> 11 12
> 10 19
> 10 18
> ```
>
> 위의 로직대로하면 (20 20) 과 (11 12) 만 집어 2개를 만들지만 정답은 4개로 (11 12)를 제외한 나머지 모두를 고를 수 있다. 이 과정에서 상당히 배낭 문제와 비슷한 느낌을 받았고 DP를 이용해 풀기로 했다.
>
> > 1. 주어지는 색종이의 두 변의 길이중 앞에 값이 낮은 값이 오게하고 앞의 값이 가장 큰 값을, 앞의 값이 같다면 뒤의 값이 큰 값에 우선순위를 주어 정렬한다.
> >    - 가장 큰 종이가 먼저 놓여야 유리하기 때문이다!
> > 2.  이제 색종이들을 순회한다. 현재 색종이 이전의 모든 색종이들이 맨 위로 갔을때 쌓을 수 있는 최대 개수를 기록한 값을 찾아본다. 그리고 그 중 가장 큰 값에 1을 더하여 현재 값에 기록한다.
> > 3. 최종적으로 모든 색종이가 마지막으로 쓰였을 때 만들 수 있는 최댓값들을 순회하여 그 중 가장 큰 값을 정답으로 한다.
>
> 해당 문제는 우선순위 큐를 사용하기 전에 꼼꼼히 검토했다면 안틀리고 풀 수 있었을 것 같은데 너무 아쉽다 ㅠㅠ 다음에는 문제를 더 잘 살펴보며 풀도록 하자!
