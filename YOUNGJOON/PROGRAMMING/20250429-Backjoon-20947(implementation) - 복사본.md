# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N;
vector<vector<char> > board(2000, vector<char>(2000));
vector<vector<int> > visited(2000, vector<int>(2000, 0));

vector<pair<int, int> > directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

void cant_boom()
{
    for (int i=0; i<N; ++i) {
        for (int j=0; j<N; ++j) {
            if (board[i][j] == 'O') {
                for (int k=0; k<4; ++k) {
                    int nx = i, ny = j;
                    while (true) {
                        nx += directions[k].first;
                        ny += directions[k].second;
                        if (0 <= nx && nx < N && 0 <= ny && ny < N && board[nx][ny] == '.') {
                            visited[nx][ny] = -1;
                        }
                        else break;
                    }
                }
            }
        }
    }
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<N; ++j) {
            if (board[i][j] == '.' && visited[i][j] != -1) {
                cout << 'B';
            }
            else {
                cout << board[i][j];
            }
        }
        cout << "\n";
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    for (int i=0; i<N; ++i) {
        for (int j=0; j<N; ++j) {
            cin >> board[i][j];
        }
    }

    cant_boom();
    
    return 0;
}

```

> ## 문제
>
> 극악무도한 테러리스트 주현이가 도시를 습격했다. 습격받은 도시는 세로 N칸, 가로 N칸으로 이뤄진 격자 모양이며, 각 칸은 빈칸이거나 건물이 존재한다. 주현이는 자신이 만든 수제 폭탄을 건물이 없는 곳에 설치한다. 폭탄은 터질 때 상하좌우 각 방향에 대해 충격파가 퍼져나가는데, 충격파가 닿은 건물은 파괴되어 건물 잔해가 된다. 충격파는 건물 또는 건물 잔해에 닿고 난 뒤 소멸한다.
>
> ![img](https://upload.acmicpc.net/497021c4-a031-4ab6-ab73-6b3d546a7863/-/preview/)
>
> 이번 테러 사건 수사를 맡은 향빈이는 현장을 재구성하는 중이다. 건물 잔해의 위치를 통해 어떤 위치에서 폭탄이 터졌는지 알아내고자 한다. 아무리 생각해도 폭탄의 위치를 알아낼 수 없는 향빈이는 문제 해결의 대가인 당신을 찾아왔다. 습격받은 도시의 정보가 주어졌을 때, 주현이가 설치한 폭탄의 위치를 구해주자.
>
> ## 입력
>
> 다음과 같이 입력이 주어진다.
>
> ## 출력
>
>  N개의 줄에 도시의 정보를 출력한다. 각 줄은 N개의 문자를 포함하며 i번째 줄 j번째 문자는 도시의 세로 i번째 가로 j번째 칸에 대한 정보이다. 빈칸일 경우 `.`, 건물일 경우 `O`, 건물 잔해일 경우 `X`, 폭탄이 설치된 칸인 경우 `B`이다. 답이 여러 가지인 경우, 아무거나 출력한다.
>
> ## 제한
>
> -  N은 도시의 크기이다. (1≤N≤2000)
> -  ai,j=`.`또는 ai,j=`O` 또는 ai,j=`X`
>   -  ai,j= `.` 면, 도시의 세로 i번째 가로 j번째 칸은 빈칸이다.
>   -  ai,j= `O` 면, 도시의 세로 i번째 가로 j번째 칸은 건물이다.
>   -  ai,j= `X` 면, 도시의 세로 i번째 가로 j번째 칸은 건물 잔해이다.
> - 항상 답이 존재하는 경우만 주어진다.
>
> ## 해설
>
> 처음 문제를 봤을 때 폭탄 개수에 대한 언급이 없으니 폭탄이 터진 후 잔해가 만들어지는 경우만 만족하면 된다고 생각했다. 그래서 O가 있는 4방향으로는 반드시 폭탄이 없어야하니 O가 닿지 않는 모든 곳에 폭탄을 두면 괜찮을 것이라고 생각했다.
>
> > 1. O를 기준으로 4방향으로 끝까지 가며 이동한 좌표에 visited에 -1을 기록한다. 단, 주어진 격자 밖으로 나가거나, X를 만나거나, O를 만나면 즉시 이동을 중단한다.
> > 2. 이후 모든 격자의 내용을 출력한다. 단, visited가 -1이면서 '.'인 위치는 'B'를 대신하여 출력한다.
>
> 혹시나해서 트라이 해봤는데 맞았다..! 그런데 처음에는 시간초과가 났다. 그 이유는 `1.`에서 O를 만나면 이동을 중단하지 않고 그냥 그대로 보내버리니 중복으로 계속해서 체크하는 경우가 생겼고 이 때문에 시간초과가 난 것이었다. 그래서 O를 방문하면 더이상 순회하지 않기로 하니 시간초과가 해결되었다.
>
> 음... 문제가 생각한거보다 간단하게 풀려서 놀랐다. 단, 최적의 폭탄개수로 만들라고 했으면...? 음... 꽤나 어려웠을 것 같다... 그리고 시간초과가 잘 안나게 잘 생각해서 문제를 풀자!! 시간초과가 아니더라도 최적화적인 면으로도 O에 닿으면 탐색을 중단하는 것이 맞았다!

