# 코드

```c++
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

#define pll pair<int, int>

using namespace std;

int N, M;
map<int, long long> loca_score;
vector<pll> my_nodes(200001);

long long get_best()
{
    long long result = 0;
    long long tmp = 0;

    for (auto p : loca_score) {
        tmp += p.second;
        result = max(result, tmp);
    }
    
    return result;
    
}


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    for (int i=0; i<N; ++i) {
        cin >> my_nodes[i].first >> my_nodes[i].second;
    }
    int s, e;
    long long dist;
    for (int i=0; i<M; ++i) {
        cin >> s >> e >> dist;
        int s_y = my_nodes[s - 1].second;
        int e_y = my_nodes[e - 1].second;
        
        if (s_y > e_y) swap(s_y, e_y);
        loca_score[s_y] += dist;
        loca_score[e_y + 1] -= dist;
        
    }
    
    cout << get_best();

    return 0;
}

```

> ## 문제
>
> 이 사실은 대회에 참가하고 있는 여러분들만 알고 있는 사실이다. 방금 외계인들이 지구를 정복했고 서울시청과 서울시의회를 장악했다. 이들은 인간들이 통근과 통학으로 고통받게 하려고 대규모 토목공사를 기획하고 있는데, 바로 지상에 서울 지하철 10호선을 짓는 것이다.
>
> ‘10호선을 만들어 준다니 좋은 거 아닌가?’라고 생각할지도 모르겠지만, 이들의 목적은 따로 있다. 바로 도로들을 철도노선으로 전부 가로막아 버리는 것이다. 이렇게 되면 서울의 남북을 가로지르는 버스 노선은 전부 사라지게 된다.
>
> 좋은 소식은 여러분들이 이 계획을 알고 있다는 것이다.
>
> 외계인들은 뛰어난 건축 기술을 갖고 있지만 *x*축에 평행하도록 철길을 놓을 때 가장 빠르게 철길을 완성할 수 있으므로 그렇게 할 것이다. 철길의 시점과 종점은 서울 바깥에 있으며, 철길과 도로가 만나면 도로는 전부 철거된다. 도로의 시점이나 종점이 철길과 만나는 경우에도 도로가 철거된다.
>
> 외계인들은 철거될 도로들의 통행량의 합이 가장 큰 곳에 철길을 놓으려 한다.
> 
> 서울시내 주요 장소 *N*개의 직교좌표계상의 좌표와, 이를 잇는 도로 총 *M*개의 정보가 주어지면 외계인들이 어디에 10호선을 지을지 예상하는 프로그램을 작성하자.
> 
> ## 입력
> 
> 첫째 줄에는 *N*과 *M*이 주어진다. (2 ≤ *N* ≤ 2 × 105, 1 ≤ *M* ≤ 2 × 105)
> 
> 이후 *N*줄에 걸쳐 한 줄에 하나씩 서울시내 주요 장소들의 *x*좌표와 *y*좌표가 공백으로 구분되어 주어진다. 좌표는 정수이며 그 절댓값은 109를 넘지 않는다.
>   
> 이후 *M*줄에 걸쳐 한 줄에 하나씩 세 정수 *ui*, *vi*, *ci*가 주어진다. (1 ≤ *ui*, *vi* ≤ *N*, *ui* ≠ *vi*, 0 ≤ *ci* ≤ 109) 이는 *ui*번째 장소와 *vi*번째 장소를 잇는 통행량 *ci*의 도로가 있음을 의미한다. 각 도로는 직선형으로 *ui*번째 장소와 *vi*번째 장소를 최단 거리로 연결해 준다. 도로는 교차할 수는 있으나, 한 도로로 주행 중 다른 도로로 진입할 수는 없다. 같은 장소를 잇는 도로가 여러 개 존재할 수 있다.
>
> ## 출력
>
> 외계인들이 철도노선을 지었을 때 최대로 파괴되는 통행량을 출력한다.
>
> ##  해설
>
> 처음 문제를 봤을 때 우선순위 큐를 이용한 스위핑을 생각했다.
> 
> 주어지는 노드들의 좌표들과 해당 노드들을 연결하는 도로의 교통량을 y축을 기준으로 기록한다. x축은 어차피 무한대로 긴 x 축으로 도로를 막을 것이기 때문에 굳이 따질 필요는 없었다.
>
> 그리고 각 도로의 도착 지점의 값이 낮은 순으로 우선순위를 주고 만약 도착 지점의 값이 같다면 시작 지점의 값이 가장 낮은 순으로 우선순위를 준 후, 순서대로 꺼내어 현재 도로의 가중치를 기록하고, 도착 지점과 가중치를 묶어 도착 지점의 값이 낮을수록 우선순위를 갖는 또다른 우선순위 큐에 넣었다. 그 다음 판단한 도로가 있을 때, 판단한 도로를 담는 우선순위 큐의 가장 우선순위가 높은 값의 도착지점 보다 현재 도로의 시작 지점의 값이 크다면 해당 도로들을 빼는 방식으로 진행했다.
>
> 그런데 어떻게 하더라도 이 방식은 값을 구하지 못하고 계속 틀렸습니다를 받았다... 아무리 생각해도 정말 잘 될 것같다고 생각한 방식이었는데... 정말 오랜 시간 한 5시간..? 붙잡고 끙끙거리다가 도저히 안될 것 같아서 힌트를 보았다.
>
> 누적합을 이용한 스위핑을 통해 문제를 풀 수 있다고 하였다.
>
> > 1. 주어지는 모든 값들을 받아 노드들을 연결하는 도로의 경우로 만든다. 그 후, map에 시작 좌표에 현재 교통량의 값을 더하고, 끝 좌표 + 1의 값에 현재 교통량의 값을 뺐다.
>>
> >    ```c++
>>    // 시작 지점에 현재 교통량을 더함
> >    loca_score[s_y] += dist;
>>    // 끝 지점 + 1 에 현재 교통량을 뺌
> >    loca_score[e_y + 1] -= dist;
>>    ```
> >
> > 2. 현재 교통량을 담을 tmp를 0으로 선언하고, 이후 가장 앞에 있는 y값부터 순회한다. (map은 자동으로 정렬해주기 때문에 굳이 정렬을 거칠 필요는 없다!) 해당 좌표에 기록된 값을 tmp에 더한다.
> >
> >    - 이때, 매번 result와 비교하며 발생하는 경우의 최댓값을 기록한다.
> >
> >    > **이게 무슨 방식이지???**
> >    >
> >    > - 예시를 들어보자, 현재 {1, 5}의 시작과 끝의 좌표를 가지는 도로가 있다 해당 도로는 5의 가중치를 갖는다. {2, 4}의 시작과 끝의 좌표를 가지는 도로가 있다 해당 도로는 3의 가중치를 갖는다. 
> >    >
> >    > - 위의 방식을 통해 진행해보면 아래와 같이 값이 저장된다.
> >    >
> >    >   ```
> >    >   1 = 5, 2 = 3, 5 = -3, 6 = - 5
> >    >   ```
> >    >
> >    >   낮은 좌표 부터 순서대로 진행하면 `5, 8, 5, 0` 순으로 값이 더해진다. 이때 8의 경우가 y = 2 or 3 or 4인 경우로 볼 수 있다. 이렇게 누적합을 이용해서 순서대로 값을 다루면 의외로 복잡하지 않고 쉽게 최댓값을 구할 수 있다는 것이다.
> >
>>    > **주의할 점!!**
> >    >
>>    > - 현재 문제의 조건에서 좌표 값이 절대값이 10^9를 넘지않는 정수로 만들어진다고 했다. 20억개의 배열을 만들어 관리하는 것은 힘들기 때문에 반드시 map을 이용하여 좌표 압축을 진행해야만 했다!
> 
>위와 같은 방식으로 문제를 풀면 됬었다!!
> 
>초기에 시도한 방식은 우선순위를 2개로 두는 바람에 완벽하게 정리가 안될 수 도 있었다. 그렇기 때문에 틀린게 아닐까 짐작하고 있었고, 의도하는 방식이 누적합을 이용한 방식이 좀 더 깔끔해보였기 때문에 오히려 더 좋은 방법을 알아간다고 생각한다...
> 
>꽤 어려운 문제였다.. 스위핑은 뜸하게 안쓰던 알고리즘이었는데... 다양한 알고리즘을 풀어보도록 하자...
