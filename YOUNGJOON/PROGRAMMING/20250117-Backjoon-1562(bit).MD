# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N;
int INF = 1000000000;
vector<vector<vector<int> > > dp(10, vector<vector<int> >(101, vector<int>(1024)));

// 인자로 현재 자리에 들어갈 수와, 현재 자리수, 0~9의 숫자가 들어갔는지 판단할 bit를 받는다.
int make_dp(int now_num, int depth, int bitbit)
{
    // 만약 이전에 계산된 적 있는 경우라면 기록된 값을 반환한다.
    if (dp[now_num][depth][bitbit] != 0) return dp[now_num][depth][bitbit];
    
    // 만약 현재 자리가 주어진 N의 자리와 같다면 더 이상 자릿수를 늘릴 필요가 없으므로, 현재 0~9의 모든 숫자가 쓰였는지
    // 확인하고 다 쓰였다면 1을 반환 아니라면 0을 반환한다.
    if (depth == N) {
        if (bitbit == 1023) return 1;
        else return 0;
    }
    
    // 현재 경우에서 파생되는 모든 경우의 수를 저장하기 위한 tmp를 선언
    int tmp = 0;
    // 현재 수에서 +1 과 -1 할 수 있는 경우 자리수를 늘리고 해당 숫자를 bit or 연산을 이용해 기록하여 재귀한다
    // 재귀에서 돌아왔을 때 가지고 온 파생된 경우의 수의 계단 수 개수를 tmp에 더한다.
    if (now_num + 1 <= 9) {
        tmp += make_dp(now_num + 1, depth + 1, bitbit | 1 << (now_num + 1));
    }
    if (now_num - 1 >= 0) {
        tmp += make_dp(now_num - 1, depth + 1, bitbit | 1 << (now_num - 1));
    }
    
    // 주어진 조건에 맞게 나눈다.
    tmp %= INF;

    // dp에 기록하면서 반환
    return dp[now_num][depth][bitbit] = tmp;
    
}

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    
    cin >> N;
    int result = 0;
    // 가장 첫번째 자리 수를 선정해 인자로 넣는다.(0으로 시작하는 수는 없으니까 1부터 시작)
    // bitmask를 이용해 0~9까지의 숫자의 여부를 판단한다. 이는 10개의 비트(2^10)를 이용하여 각 비트값을 bool처럼 사용해 판단한다.
    // 모든 숫자가 있다면 1111111111(=1023) 이 될것이다.
    // 해당 첫째자리 수에서 발생하는 모든 경우의 계단 수를 result에 더한다.
    for (int i=1; i<=9; ++i) {
        result += make_dp(i, 1, 1<<i);
        result %= INF;
    }
    
    cout << result;

    return 0;
}

```



# 해설

> ## 문제
>
> 45656이란 수를 보자.
>
> 이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.
>
> N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.
>
> ## 입력
>
> 첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
>
> ## 해설
>
> 처음에 문제를 봤을때는 2차원 DP를 이용해서 10에서의 (987654321) 부터 맨 뒤의 숫자에 대해 +1,  -1을 하며 그 개수를 새주려고 했다.
>
> 그러나 반드시 앞이 9여야 한다는 법칙도 없거니와, 중간 중간에 수가 껴지는 경우 (98987654321)가 있기 때문에 문제가 생겼다.
>
> 그래서 앞자리를 동시에 보게 3차원 DP로 할까? 했지만 아무리 생각해도 비효율의 극치를 달리는 느낌이 확들어서 시도도 안했다. 결국 계속 고민해봐도 해답이 나오질않아서 오늘도 블로그를 참고했다...
>
> 알고리즘은 비트마스킹을 이용한 DP였다.
>
> 우선 3차원 DP를 선언한다. DP\[10]\[101]\[1024] 로 선언하며 각각 다음과 같은 특성을 가진다. 
>
> > [10] = 현재 위치의 해당하는 숫자 (0~9), 
> >
> > [101] = N의 최대 범위 100까지의 배열, 
> >
> > [1024] = 비트마스킹을 위한 비트 10개를 마련하기 위해 2^10으로 값을 선언
>
> 비트마스킹을 이용하여 0~9까지의 숫자들이 모두 존재하는지를 판별한다. 만약 2^n위치의 값이 1이라면 (0 <= n <= 9)  해당 숫자가 존재한다고 볼 수 있다.
>
> 비트를 마치 bool 배열을 선언한 것처럼 사용할 수 있는데, 이는 int 자료형만 선언해서 사용하여 최대 2^30 정도까지 커버가 가능하다 (int 자료형의 범위 때문에 30개 정도를 4바이트에 bool처리 할 수 있는 것이다.) 만약 더 큰 것을 원한다면 long long을 이용해도 되겠지만 일단 long long 또한 2^64 - 1정도 까지기 때문에 2^63을 넘어가는 개수는 비트로 처리하기 힘들다.
>
> 그리고 첫째 자리 수를 정하고 그 다음부터 현재 자리 수를 기준으로 다음 숫자를 정한다.
>
> 따라서 첫째 자리 수는 모두 1~9까지 모두 해본다 (0은 0으로 시작하는 수가 없으므로 제외)
>
> 재귀 함수를 이용하여 첫 번째 자리 위치에서 N번째 자리 위치까지 내려간다. 현재 수에서 +1, -1을 하여 재귀를 보낸다. 이때 0 ~ 9 의 범위를 넘어가는 수가 될 경우 해당 경우는 재귀를 보내지 않는다. 해당 함수는 자신에서 파생되는 모든 계단 수의 개수를 반환하게 된다. 즉, 첫 번째 재귀 함수에서 각각의 1~9가 첫 번째 자리 수인 모든 계단 수들을 반환하게 된다.
>
> 비트 마스킹을 이용할 생각 조차도 해보지 못했는데.... 2차원 DP를 이용하여 모든 계단 수를 손쉽게 만들 수 있다는 것도 구상하지 못한 것 같다. (단, 0~9의 모든 수가 들어가 있다는 보장이 없는 계단 수)  아직 이 정도 수준 문제가 버거운걸까 계속해서 참고해서 풀고 있는데... 그래도 알아야 풀 수도 있는거고.. 비트마스킹을 이용해 배열의 인덱스 값으로 사용한다는 방식은 정말 접해보지도 못한거라 얻어가는 것도 많은 문제라고 생각한다...
>
> 비트마스킹 문제를 좀 풀어볼 필요가 있겠다..!

