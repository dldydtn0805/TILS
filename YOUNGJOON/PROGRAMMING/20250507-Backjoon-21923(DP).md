# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

#define pll pair<int, int>

using namespace std;

int N, M;
vector<vector<int> > board(1000, vector<int>(1000, 0));
vector<vector<pll> > directions = {{{-1, 0}, {0, 1}}, {{1, 0}, {0, 1}}};

void lets_fly()
{
    vector<vector<int> > up_fly(N, vector<int>(M, -20000001));
    vector<vector<int> > down_fly(N, vector<int>(M, -20000001));
    
    up_fly[N-1][0] = board[N-1][0];
    for (int i=N-1; i>=0; --i) {
        for (int j=0; j<M; ++j) {
            for (int k=0; k<2; ++k) {
                int ni = i + directions[0][k].first;
                int nj = j + directions[0][k].second;
                
                if (0 <= ni && ni < N && 0 <= nj && nj < M) {
                    up_fly[ni][nj] = max(up_fly[ni][nj], up_fly[i][j] + board[ni][nj]);
                }
            }
        }
    }
    
    down_fly[0][0] = up_fly[0][0] + board[0][0];
    for (int i=0; i<N; ++i) {
        for (int j=0; j<M; ++j) {
            for (int k=0; k<2; ++k) {
                int ni = i + directions[1][k].first;
                int nj = j + directions[1][k].second;
                                
                if (0 <= ni && ni < N && 0 <= nj && nj < M) {
                    down_fly[ni][nj] = max({down_fly[ni][nj], up_fly[ni][nj] + board[ni][nj], down_fly[i][j] + board[ni][nj]});
                }
            }
        }
    }
    
    cout << down_fly[N-1][M-1];
    
    return;
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<M; ++j) {
            cin >> board[i][j];
        }
    }
    
    lets_fly();

    return 0;
}

```

> ## 문제
>
> 동헌이는 모형 비행기 조종 대회에 참가하였다. 이 대회에서는 격자 모양의 공간에서 모형 비행기를 조종하여 얻는 **비행 점수**로 순위를 매긴다. 격자의 각 칸에는 점수가 부여되어 있고, 비행 점수는 "**상승 비행**을 할 때 지나간 칸에 부여된 점수의 총합"과 "**하강 비행**을 할 때 지나간 칸에 부여된 점수의 총합"을 더한 값이다. 출발한 칸과 도착한 칸도 지나간 칸으로 간주한다.
>
> ![img](https://upload.acmicpc.net/6babc434-88bc-4083-b78d-6b99dff6b9ca/-/crop/1639x573/156,401/-/preview/)
>
> <그림 1> 시작과 끝 칸 및 가능한 이동 방향
>
> 모형 비행기는 맨 왼쪽 아래 칸에서 상승 비행으로 비행을 시작해야 하고, 중간에 상승 비행에서 하강 비행으로 변경한 후, 맨 오른쪽 아래 칸에서 하강 비행으로 비행을 종료해야 한다. 상승 비행에서 하강 비행으로 변경할 때에는 다른 칸으로 이동할 수 없다. **즉, 상승 비행이 끝난 칸에서 하강 비행을 시작해야 한다.**
>
> 모형 비행기는 상승 비행 중에는 앞 또는 위로만 이동할 수 있고, 하강 비행 중에는 앞 또는 아래로만 이동할 수 있다.
>
> ![img](https://upload.acmicpc.net/17063436-6675-4c21-9044-018a8476c5ae/-/crop/1642x512/157,461/-/preview/)
>
> <그림 2> 모형 비행기의 이동 경로
>
> 위의 예시에서, 각 칸에 적힌 수는 그 칸에 부여된 점수이고, 수가 적혀 있지 않은 칸의 점수는 0이라고 가정하자. 그리고 모형 비행기가 1, 2, ..., 15의 순서대로 비행을 했다고 가정하자.
>
> ![img](https://upload.acmicpc.net/ce6860ed-a632-4cf4-951f-cd7912f83796/-/crop/1652x525/149,453/-/preview/)
>
> <그림 3> 상승 비행의 이동 경로
>
> ![img](https://upload.acmicpc.net/c2108165-cc33-4c13-9231-988ee14ecd2e/-/crop/1642x512/152,461/-/preview/)
>
> <그림 4> 하강 비행의 이동 경로
>
> 이 경우, 상승 비행은 1이 적힌 칸에서 시작하고 8이 적힌 칸에서 끝난다. 하강 비행은 8이 적힌 칸에서 시작하고 15가 적힌 칸에서 끝난다. 이와 같이 비행을 하였을 때 얻는 점수는 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8) + (8 + 9 + 10 + 11 + 12 + 13 + 14 + 15) = 128 이다.
>
> 동헌이는 이 대회에서 얻을 수 있는 최대 비행 점수가 궁금하다. 동헌이를 위해 얻을 수 있는 최대 비행 점수를 구해주자.
>
> ## 입력
>
> 첫째 줄에 심사위원들이 나눠놓은 구역(격자)의 세로 길이 N, 가로 길이 M이 공백과 함께 주어진다.
>
> 두 번째 줄부터 N+1번째 줄까지, 각 칸에 해당하는 점수가 한 줄에 한 행씩 공백과 함께 주어진다.
>
> ## 출력
>
> 동헌이가 얻을 수 있는 최대 점수를 출력하라.
>
> ## 제한
>
> -  1 ≤ N,M ≤ 1,000
> -  −10,000 ≤ -10,000
>
> ## 해설
>
> 처음 문제를 봤을 때 bfs로 접근하려 했으나 문제를 계속 살펴보니 DP 같았다.
>
> 상승 비행은 바닥에서부터 시작하는 DP로, 하강 비행은 위에서 아래로 가는 DP로 진행하면 될것이라고 생각했다.
>
> > 1. 상승 비행과 하강 비행을 기록할 2차원 DP를 각각 선언한다 이때 초기화 값은 발생할 수 있는 값보다 훨씬 작게 -20000001로 선언한다.
> >
> > 2. N-1번째 열부터 시작하여 0번째 열까지 탐색한다. `즉, {N-1, 0} 부터 진행한다.` 현재 좌표에서 상승 비행이 갈 수 있는 위치인 위, 오른쪽에 대해 현재 값에 이동할 위치에 값을 더한 값과, 이동할 위치에 기록된 값 중 최댓 값을 기록한다.
> >
> > 3. 상승 비행으로 이루어질 수 있는 모든 값을 구하면 이제 하강 비행으로 발생할 수 있는 값을 연산한다.
> >
> >    0번째 열부터 시작하여 N-1번째 열까지 탐색한다. `즉 {0, 0} 부터 진행한다.` 현재 좌표에서 하강 비행이 갈 수 있는 위치인 아래, 오른쪽에 대해 이동하며 아래의 3가지 값중 최댓 값을 기록한다.
> >
> >    > - 현재 위치의 값 + 이동할 위치에 적힌 점수 값
> >    > - 이동할 위치에 하강 비행에 기록되어 있는 값
> >    > - 이동할 위치에 상승 비행에 기록되어 있는 값 + 이동할 위치에 적힌 점수 값
> >
> > 4. 3번까지 모두 마쳤다면 하강 비행을 기록하는 DP에서 {N-1, M-1}에 적힌 값이 결과 값이 된다.
>
> 처음에 BFS로 하려다가 DP로 바꾼 것은 참 잘했는데 초기 값 선언이 잘못되어서 틀렸습니다를 받았다.
>
> 처음에는 -10000 * 1000을 생각해서 -10000001로 선언했는데 이는 잘못된 판단이었다. 왜냐하면 상승 비행에서 하강 비행으로 전환할때 한번 더 해당 위치의 값을 더하기 때문에 발생할 수 있는 가장 낮은 값은 -10001000이었기 때문이다. 그걸 생각해서 그냥 넉넉하게 -20000001로 선언하였다.
>
> 꼭 음수가 들어가면 초기화 값을 제대로 선언을 못해서 틀리는 경우가 많은데... 꼭 잘 계산한 후 선언해서 문제를 풀어보자
