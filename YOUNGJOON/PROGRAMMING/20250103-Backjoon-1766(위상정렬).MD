# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int N, M;

vector<vector<int> > graph;
vector<int> visited;
priority_queue<int, vector<int>, greater<int> > que;

void bfs()
{
    while (!que.empty()) {
        int now = que.top();
        que.pop();
        cout << now << " ";
        
        for (int a : graph[now]) {
            visited[a]--;
            if (visited[a] == 0) {
                que.push(a);
            }
        }
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> N >> M;
    
    int s, e;
    graph.resize(N+1);
    visited.resize(N+1, 0);
    
    for (int i=0; i<M; ++i) {
        cin >> s >> e;
        graph[s].push_back(e);
        visited[e]++;
    }
    
    for (int i=1; i<=N; ++i) {
        if (visited[i] == 0) {
            que.push(i);
        }
    }
    
    bfs();
    
    return 0;
}

```



# 해설

> ## 문제
>
> 민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.
>
> 어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.
>
> 1. N개의 문제는 모두 풀어야 한다.
> 2. 먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다.
> 3. 가능하면 쉬운 문제부터 풀어야 한다.
>
> 예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.
>
> 문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.
>
> 항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.
>
> ## 해설
>
> 처음 보자마자 든 생각은 먼저 순서를 지켜야하므로 위상 정렬을 이용해야겠다고 생각했다. 그런데 문제를 읽다보니까 가장 난이도가 낮은 문제가 있다면 이를 먼저 풀어야한다는 조건이 있었다. 그렇다면 우선순위 큐를 이용하여 bfs를 돌릴때, 현재 풀이가 가능한 모든 문제 중 가장 난이도가 낮은 문제 풀게해야겠다고 생각했다.
>
> 이를 구현하기위해 먼저 우선적으로 풀어야하는 문제를 받을때 s, e에 값들을 받고 graph[s]에 e를 넣고, visited[e]에 +1을 하여 현재 문제를 풀려면 문제를 1개 풀어야한다는 것을 나타냈다 이렇게 한다면 e를 풀기위해 필요한 문제가 5문제일때는 값이 5이기때문에 문제를 다 풀지 않았는데 문제를 풀려고 시도하는 일이 발생하지 않는다.
>
> 그 후, visited 를 순회하여 값이 0인 문제들을 전부 우선순위 큐에 넣는다. 값이 0이라는것은 선행 문제가 없다는 뜻이므로 당장 풀 수 있는 문제가 된다.
>
> 이제 우선순위 큐가 모두 빌때까지 bfs를 순회하는데, 현재 가장 낮은 난이도의 문제를 꺼내고 출력한 후, 해당 문제가 선행 문제인 문제들의 visited를 -1 해준다. 만약 -1했을때,  0이 된다면, 모든 선행 문제가 풀린 것이므로, 해당 문제를 우선순위 큐에 넣는다.
>
> 이를 반복하면 원하는 문제의 순서를 얻어낼 수 있다!
>
> 최근 위상정렬 문제를 많이 풀어서 빠르게 풀었고, 한 번에 맞았다! 역시 문제를 푸는 것은 노력이 중요한 것 같다!

 
