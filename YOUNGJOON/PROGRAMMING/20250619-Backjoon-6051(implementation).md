# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N;
vector<int> last_number(80001, -1), idx_loca(80001, 0);

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;

    char command; int num;
    for (int i=1; i<=N; ++i) {
        cin >> command;
        if (command == 'a') {
            cin >> num;
            last_number[i] = num;
            idx_loca[i] = i;
        }
        
        else if (command == 't') {
            cin >> num;
            last_number[i] = last_number[idx_loca[max(0, num - 1)]];
            idx_loca[i] = max(0, idx_loca[max(0, num - 1)]);
        }
        
        else {
            last_number[i] = last_number[max(0, idx_loca[max(0, i - 1)] - 1)];
            idx_loca[i] = idx_loca[max(0, idx_loca[max(0, i - 1)] - 1)];
        }
        
        cout << last_number[idx_loca[i]] << "\n";
    }
    

    return 0;
}
```

> ## 문제
>
> 모범생 현수는 코딩하는 시간을 늘리기 위해 타임 머신을 구매 했다. 현수는 정상적으로 문제를 코딩하거나 (타임 머신을 사용하지 않고), 과거의 임의의 지점으로 시간여행 할 수 있다. 미래로 시간 여행 할 수 없으며, 과거로 가면 새로운 미래가 진행된다.
>
> 현수는 자유롭게 문제를 풀거나 과거로 돌아가면서 자신이 푼 문제 목록을 기록한다. 과거로 돌아가면 과거 이전까지 풀었던 문제 목록만 남는다.
>
> 현수는 기록 되어 있는 문제 목록 중 가장 최근에 푼 문제 번호를 알고 싶다. (가장 최근에 푼 문제가 없다면 -1을 출력)
>
> 매 쿼리마다 문제 목록에 기록되어 있는 가장 최근에 푼 문제를 출력하는 프로그램을 작성하시오.
>
> 현수는 개인의 타임라인 관점에서 연속적인 업데이트를 나타내는  N (1 <= N <= 80,000) 개의 쿼리 Qi(1...N) 를 제공한다.
>
> 각 쿼리는 한 줄의 입력이다. 각 줄은 하나의 문자 c ( 'a', 's', 't' 중 하나)로 시작한다. c가 'a'또는 't' 이면 c 다음에 공백과 정수 K가 주어진다. (1 <= K <= 1,000,000)
>
> c가 'a' 이면 현수는 문제 번호가 K인 문제를 풀고 문제 목록에 기록 한다.
>
> c가 's' 이면 현수는 가장 최근에 작성한 문제 목록을 삭제한다.
>
> c가 't'이면, 현수는 K 번째 쿼리 직전까지 시간을 거슬러 올라 간다. 즉, 현수는 K-1번째 쿼리와 K번째 쿼리 사이로 시간 여행한다. (입력을 위해 예제 입력 참조). K 쿼리 바로 전에 있던 푼 문제 목록으로 되돌아 간다.
>
> 이해를 돕기 위해 아래에 푼 문제 목록과 12개의 쿼리, 각 쿼리에 대한 출력결과가 주어진다. 
>
> ```
> Q#   쿼리     문제목록      출력         참조
>  1   a 5  -> [5]         => 5        5번 문제를 목록에 기록
>  2   a 3  -> [5,3]       => 3        3번 문제를  목록에 기록
>  3   a 7  -> [5,3,7]     => 7        7번 문제를 목록에 기록
>  4   s    -> [5,3]       => 3        가장 최근 기록한 7를 목록에서 삭제
>  5   t 2  -> [5]         => 5        2번째 쿼리 직전으로 되돌아감
>  6   a 2  -> [5,2]       => 2        2번 문제를 목록에 기록
>  7   t 4  -> [5,3,7]     => 7        4번째 쿼리 직전으로 되돌아감
>  8   a 4  -> [5,3,7,4]   => 4        4번 문제를 목록에 기록
>  9   s    -> [5,3,7]     => 7        가장 최근 기록한 4를 목록에서 삭제
> 10   t 7  -> [5,2]       => 2        7번째 쿼리 직전으로 되돌아감
> 11   s    -> [5]         => 5        가장 최근 기록한 2를 목록에서 삭제
> 12   s    -> []          => -1       가장 최근 기록한 5를 목록에서 삭제
> ```
>
> ## 입력
>
> 첫 번째 줄 : 하나의 정수 N
>
> 두 번째 줄 부터 N+1번째 줄까지: 쿼리 Qi 
>
> ## 출력
>
> 1부터 N번째 줄 : Qi 처리 후 목록에 기록 되어 있는 가장 최근에 푼 문제를 출력하시오 (가장 최근에 푼 문제가 없으면 -1).
>
> ##  해설
>
> 처음 문제를 봤을 때 인덱싱을 이용한 구현을 생각했다. 아래와 같은 방법으로 구현하면 연속되는 시간 역행이나 삭제연산을 해결할 수 있다고 생각했다.
>
> 1. 해당 시점의 가장 뒤에 있는 숫자만 출력한다
>
> 2. 그러기 위해서 해당 시점마다 가장 뒤에있는 숫자를 기록한다.
>
> 3. 시간역행을 하면 해당 시점으로 이동한다 이를 위해 각 시점마다 idx 값을 둔다.
>
>    - 현재 위치와 idx 의 값이 같다면 이는 역행의 시점이 아니다.
>
>    - 만약 현재 위치와 idx 값이 다르다면 이는 역행한 경우로 기록된 idx 위치에 대해서 값을 관리한다.
>
>    - ```
>      ex)   1 2 3 4 5 6 1로역행 7 8 9
>      idx)  1 2 3 4 5 6 1      8 9 10
>      ```
>
>      이런식으로 진행해야한다. 중간에 값들을 지워서도 안된다 후에 호출 할 수도 있으니까...
>
> 4. 여기서 이 문제의 key 카드는 s 이다
>   삭제 연산을 어떻게 할것인가?? 지금 우리는 가장 뒤쪽의 값만 작성하고 있다 그렇기 때문에 삭제 연산 또한 idx를 조절해주는 식으로 진행해야한다!
>
>   ```
>   Ex)  1 2 3 4 5 s s s s s
>   idx  1 2 3 4 5 4 3 2 1 x
>   ```
>
> > 1. 현재에 가장 뒤에 존재하는 값을 기록할 배열 last_number와 현재 순서가 참조하는 idx 값을 기록할 배열 idx_loca를 선언한다.
> > 2. 주어지는 입력을 받는다. 받는 커멘드에 따라서 행동이 다르다.
> >    - `'a'` 일때
> >      - 연속해서 입력되는 숫자를 받아 현재 순회중인 순서의 last_number에 기록한다. 이때 idx는 현재 순회중인 순서와 같다.
> >    - `'t'`일때
> >      - 연속해서 입력되는 숫자를 받아 `해당 숫자 - 1`를 **인덱스**로 하여 idx_loca에서 시간역행한 위치의 idx 값을 찾는다. 그 후 현재 순회중인 순서의 idx_loca에 기록한다.
> >      - 위에서 찾은 idx 값을 이용해 last_number에 기록되어있는 값을 찾아 현재 순회중인 순서의 last_number에 기록한다.
> >      - 이때 시간역행이 지점이 0이라면 - 1하면 음수가 되기 때문에 max(0, num - 1)을 이용하여 idx을 찾는다.
> >    - `'s'`일때
> >      - `현재 순회중인 순서 - 1`에 기록된 idx를 구해 해당 idx를 현재 순회중인 순서의 idx_loca에 기록한다.
> >      - 위에서 찾은 idx 값을 이용해 last_number에 기록되어있는 값을 찾아 현재 순회중인 순서의 last_number에 기록한다.
> >      - 이때 이전지점이 0이라면 - 1하면 음수가 되기 때문에 max(0, num - 1)을 이용하여 idx을 찾는다.
> > 3. 2번의 작업 이후 현재 순회중인 순서의 last_number에 적힌 값을 출력한다.
>
> 위와 같은 방법으로 문제를 풀었다. 문제를 보고 구상한 방법으로 바로 문제를 풀 수 있었다! 약간 연결리스트 처럼 문제를 풀어보려고 했는데 바로 맞아서 기분이 좋았다! 다음에도 이렇게 잘 풀어보자!

