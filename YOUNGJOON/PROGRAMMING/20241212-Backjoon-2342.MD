# 코드

```c++
#include <iostream>
#include <sstream>
#include <vector>
#include <cmath>

using namespace std;

vector<int> commands;
vector<vector<vector<int> > > dp(100001, vector<vector<int> >(5, vector<int>(5, 400001)));
int N;

void Dance_Dance_Revolution()
{
    dp[0][0][commands[0]] = 2;
    
    for (int i=1; i<N-1; ++i) {
        int command = commands[i];
        for (int j=0; j<5; ++j) {
            int front_cost;
            
            if (j == 0) {
                front_cost = 2;
            }
            else if (j == command) {
                front_cost = 1;
            }
            else if (abs(j - command) == 2) {
                front_cost = 4;
            }
            else {
                front_cost = 3;
            }
            
            for (int k=0; k<5; ++k) {
                dp[i][command][k] = min(dp[i][command][k], dp[i-1][j][k] + front_cost);
                
                int end_cost;
                
                if (k == 0) {
                    end_cost = 2;
                }
                else if (k == command) {
                    end_cost = 1;
                }
                else if (abs(k - command) == 2) {
                    end_cost = 4;
                }
                else {
                    end_cost = 3;
                }
                
                dp[i][j][command] = min(dp[i][j][command], dp[i-1][j][k] + end_cost);
            }
        }
    }
    
    int result = 400001;
    
    for (int i=0; i<5; ++i) {
        for (int j=0; j<5; ++j) {
            if (dp[N-2][i][j] < result) {
                result = dp[N-2][i][j];
            }
        }
    }
    
    cout << result;
    
    return;
    
}

int main()
{
    string data;
    getline(cin, data);
    
    istringstream iss(data);
    int num;
    while (iss >> num) {
        commands.push_back(num);
    }
    
    N = commands.size();
    
    Dance_Dance_Revolution();
    

    return 0;
}

```



# 해설

> ## 문제
>
> 승환이는 요즘 "Dance Dance Revolution"이라는 게임에 빠져 살고 있다. 하지만 그의 춤 솜씨를 보면 알 수 있듯이, 그는 DDR을 잘 하지 못한다. 그럼에도 불구하고 그는 살을 뺄 수 있다는 일념으로 DDR을 즐긴다.
>
> DDR은 아래의 그림과 같은 모양의 발판이 있고, 주어진 스텝에 맞춰 나가는 게임이다. 발판은 하나의 중점을 기준으로 위, 아래, 왼쪽, 오른쪽으로 연결되어 있다. 편의상 중점을 0, 위를 1, 왼쪽을 2, 아래를 3, 오른쪽을 4라고 정하자.
>
> ![img](https://www.acmicpc.net/JudgeOnline/upload/201011/ddr.PNG)
>
> 처음에 게이머는 두 발을 중앙에 모으고 있다.(그림에서 0의 위치) 그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. 하지만 그의 두 발이 동시에 움직이지는 않는다.
>
> 이 게임에는 이상한 규칙이 더 있다. 두 발이 같은 지점에 있는 것이 허락되지 않는 것이다. (물론 게임 시작시에는 예외이다) 만약, 한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다는 것이다.
>
> 오랫동안 DDR을 해 온 백승환은 발이 움직이는 위치에 따라서 드는 힘이 다르다는 것을 알게 되었다. 만약, 중앙에 있던 발이 다른 지점으로 움직일 때, 2의 힘을 사용하게 된다. 그리고 다른 지점에서 인접한 지점으로 움직일 때는 3의 힘을 사용하게 된다. (예를 들면 왼쪽에서 위나 아래로 이동할 때의 이야기이다.) 그리고 반대편으로 움직일때는 4의 힘을 사용하게 된다. (위쪽에서 아래쪽으로, 또는 오른쪽에서 왼쪽으로). 만약 같은 지점을 한번 더 누른다면, 그때는 1의 힘을 사용하게 된다.
>
> 만약 1 → 2 → 2 → 4를 눌러야 한다고 가정해 보자. 당신의 두 발은 처음에 (point 0, point 0)에 위치하여 있을 것이다. 그리고 (0, 0) → (0, 1) → (2, 1) → (2, 1) → (2, 4)로 이동하면, 당신은 8의 힘을 사용하게 된다. 다른 방법으로 발을 움직이려고 해도, 당신은 8의 힘보다 더 적게 힘을 사용해서 1 → 2 → 2 → 4를 누를 수는 없을 것이다.
>
> ## 입력
>
> 입력은 지시 사항으로 이루어진다. 각각의 지시 사항은 하나의 수열로 이루어진다. 각각의 수열은 1, 2, 3, 4의 숫자들로 이루어지고, 이 숫자들은 각각의 방향을 나타낸다. 그리고 0은 수열의 마지막을 의미한다. 즉, 입력 파일의 마지막에는 0이 입력된다. 입력되는 수열의 길이는 100,000을 넘지 않는다.
>
> ## 해설
>
> 처음에는 그냥 백트래킹 문제라고 생각했다. 우선 모든 발을 0에서 때고 시작하는게 꼭 빠르지만은 않다고 생각했다. 그렇기 때문에 모든 경우의 수를 판단해야한다고 생각했고, 이러한 이유 때문에 DFS를 이용해 모든 경우의 수를 확인하되, 가장 작은 결과보다 값이 높아지는 순간 탈출하여 백트래킹을 적용했다. 그러나 생각보다 점수의 차이가 극명하게 나지 않기 때문에 꽤나 깊이 들어가야 불가능 여부를 파악할 수 있었고 이로 인해 백트래킹을 시켰지만 생각보다 최적화 수준이 좋지 않아서 시간초과가 났다. 고민하다가 결국 알고리즘 분류를 봤는데 DP였다.
>
> 근데 DP라고해서 바로 풀수있었을까? 아니다! 처음에는 1 2 3 4 발판의 여부를 판단해서 2차원 DP를 이용하려고 했다. 그런데 생각해보니 다른 발 또한 움직일 수 있는건데 이를 참고하지않고 진행해도 괜찮은건가? 싶었다.. 그래도 3차원 DP는 아니겠지 하면서 현실부정하면서 고민하다가 도저히 해답이 나오지않아서 블로그에서 힌트를 봤는데 그냥 바로 3차원 DP 길래 더 읽어보지 않고 직접 구현하기로 했다.
>
> 여기서 좀 고민했던 점이 0번에 발이 있는 경우를 어떻게 처리해야할까? 였다.
>
> 위에서도 언급했지만 모든 발을 가능한한 바로 0에서 발을 때는게 이득인 경우는 아니었다
>
> ```c
> 1 1 1 1 1 0
> ```
>
> 이게 예시인데 처음 왼발을 0에서 1로 보내고 계속 왼발만 움직여서 1을 밟으면  오른발은 굳이 0에서 뗄 필요가 없다. 아니, 0에서 때면 안된다. 그래야 최소가 된다.
>
> 처음 3차원 DP를 구상할때 가능한한 바로 2개의 발을 떼고 구현해보았다. 아니나 다를까 바로 위의 반례에 걸렸다...
>
> 아 그렇다면 1 2 3 4 만 보는게 아니라 0 1 2 3 4를 이용해서 100001 * 5 * 5의 3차원 DP를 만들고 맨 처음에는 발을 무조건 때야하기때문에 첫번째 커멘드만 강제로 기록하고 이후에는 5 * 5의 2차원 배열을 확인하면서 각각 발을 움직이면 어떻게 될지 기록하면 되겠구나! 했다.
>
> 잠깐 들었던 의심인데 5 * 5 2차원 배열을 순회하면서 움직이면 한번도 발을 댄적도 없는 곳도 살펴볼텐데 이게 문제 되지 않을까...? 했지만 400001의 값으로 기록해두었기 때문에 `400001 + 움직이는 힘의 값`은 반드시 400001보다 크고 이는 min()을 이용해 갱신하기 때문에 어차피 무시가 되니까 의미가 없었다. 따라서 안심하고 진행하면 되는것이 었다!
>
> 흠... 생각보다 DP라는걸 떠올리지 조차 못한 문제다.. 더 다양하게 접해보는게 중요하겠다 요즘 너무 단순하게 브루트포스로만 접근하려고하는 경향이 있다.
>
> 근데 다 살펴봐야하는건 맞긴했는데... 꼭 다 살펴봐야한다고 브루트 포스를 연상하는건 치명적일 수 있겠다...

