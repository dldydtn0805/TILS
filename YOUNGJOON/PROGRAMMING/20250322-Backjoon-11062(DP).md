# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int T, N;

int card_draw(vector<vector<int> >& DP, vector<int>& cards, int left, int right, int depth)
{
    // 카드의 구간이 유효하지 않을 때 즉, 뽑을 카드가 없을 때 0을 반환
    if (left > right) {
        return 0;
    }
    // 이미 경험한 적 있는 경우라면 기록된 값을 반환
    if (DP[left][right] > 0) {
        return DP[left][right];
    }
    if (depth % 2 == 0) {
        // 내 턴에는 나의 값을 최대로 해야하기 문에 최대값을 기록한다.
        return DP[left][right] = max(card_draw(DP, cards, left + 1, right, depth + 1) + cards[left], card_draw(DP, cards, left, right - 1, depth + 1) + cards[right]);
    }
    else {
        // 상대 턴에는 나의 값을 최소로 만들려고 하기 때문에 최소값을 기록한다.
        return DP[left][right] = min(card_draw(DP, cards, left + 1, right, depth + 1), card_draw(DP, cards, left, right - 1, depth + 1));
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    cin >> T;
    
    for (int t=0; t<T; ++t) {
        cin >> N;
        vector<vector<int> > DP(N, vector<int>(N, 0));
        vector<int> cards(N, 0);
        for (int i=0; i<N; ++i) {
            cin >> cards[i];
        }
        
        cout << card_draw(DP, cards, 0, N-1, 0) << "\n";
        
    }

    return 0;
}
```



> ## 문제
>
> 근우와 명우는 재미있는 카드 게임을 하고 있다. N개의 카드가 일렬로 놓여 있다. 각 카드에는 점수가 적혀있다. 근우부터 시작하여 번갈아가면서 턴이 진행되는데 한 턴에는 가장 왼쪽에 있는 카드나 가장 오른쪽에 있는 카드를 가져갈 수 있다. 카드가 더 이상 남아있지 않을 때까지 턴은 반복된다. 게임의 점수는 자신이 가져간 카드에 적힌 수의 합이다.
>
> 근우와 명우는 서로 자신의 점수를 가장 높이기 위해 최선의 전략으로 게임에 임한다. 놓여있는 카드의 개수 N과 카드가 놓여있는 상태가 주어졌을 때 근우가 얻는 점수를 구하는 프로그램을 작성하시오.
>
> 예를 들어 카드가 [4, 3, 1, 2]로 놓여있다고 하자. 근우는 처음에 4가 적힌 카드를 가져가고, 명우는 3이 적힌 카드를 가져간다. 그리고 근우는 2가 적힌 카드를 가져가고, 명우는 마지막으로 1이 적힌 카드를 가져간다. 이때 근우와 명우는 최선의 전략으로 임했으며, 근우가 얻는 점수는 6이다.
>
> ## 입력
>
> 입력의 첫 줄에는 테스트케이스의 수 T(1 ≤ T ≤ 50)가 주어진다.
>
> 각 테스트케이스 마다 첫 줄에는 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 N개의 자연수가 공백으로 구분되어 주어지는데, i번째로 주어지는 수는 왼쪽에서 i번째에 놓인 카드에 적힌 수를 의미한다. 카드에 적혀있는 수는 1이상 10,000이하다.
>
> ## 해설
>
> 처음 문제를 봤을 때는 그리디를 연상했다. 그러나 그리디이지 않을까하는 생각만하고는 문제를 어떻게 그리디 하게 풀수 있을까는 연상하지 못했다. 주어진 예제에서 `{1, 2, 5, 2}`는 무작정 첫 턴에 오른쪽 2를 집어버리면 상대가 5를 집으므로 어떻게하든 져버린다. 그래서 우선순위를 두어야하는데... 음... 이게 가능할까? 싶었다... 결국 계속 고민하다가 못풀겠어서 알고리즘 분류를 보았다.
>
> 해당하는 분류는 DP, 게임 이론 이었다. 음... DP는 그렇다치고... 게임 이론은 뭐지? 싶었다.
>
> DP로 연상을 하려고해도 딱히 생각나는게 없었고 결국 게임 이론을 찾아보기로 했다.
>
> 게임이론을 깊게 파고들지는 않았지만 기본적인 베이스는 2명이 게임을 하는데 어떠한 조건을 모두 이기기위해 최선을 다해서 최적의 조건으로 플레이를 한다. 는 것이다.
>
> 내가 봤던 이론은 2인 제로섬 게임이었는데 간단한 이론은 다음과 같다. 
>
> > - 조건
> >
> >   > A와 B 2사람이 자신의 차례에 주어지는 N개의 돌을 1개 또는 4개 가져간다. 위와 같이 진행하여 자신에 턴에 가져갈 돌이 없는 사람은 진다. A부터 턴을 시작한다고 할때 A가 이길 수 있는지 없는지를 찾아라.
> >
> > - 풀이
> >
> >   > 위의 조건이 명확하게 기억이 나지 않지만 일단 진행해보자
> >   >
> >   > - N = 1
> >   >   - 반드시 A가 이긴다.
> >   > - N = 2
> >   >   - 반드시 먼저 시작한 A가 진다.
> >   > - N = 3
> >   >   - 반드시 먼저 시작한 A가 이긴다.
> >   > - N = 4
> >   >   - A가 4개를 가져가면 이긴다. 하지만 1을 가져가면 어떨까?
> >   >   - A가 1을 가져가면 3이남고 3의 경우에는 3일때 먼저 가져간 사람이 이긴다. 즉 B가 이겨버린다.
> >   >   - 하지만, 문제에서는 최선의 선택을 해야한다고 적혀있다. 따라서 A는 반드시 4개 가져가야 할 것이다.
> >   > - N = 5
> >   >   - A는 1 or 4개를 가져갈 수 있다.
> >   >   - 하지만 1개를 가져가거나 4개를 가져가도 무조건 A는 진다.
> >   > - 그 이후...
> >   >   - 위의 조건을 좀 둘러본 결과 어떠한 수에서는 반드시 이기거나 지거나 둘 중 하나의 경우만 일어난다.
> >   >     - 어떠한 숫자 n에서 지거나, 이기거나 둘 다의 경우는 일어날 수 없다. N=4일때 1을 가져가면 질수도 있지만 최선의 경우를 골라야한다는 조건이 있어 반드시 4를 골라야하기때문! 즉, 4일때는 이기는 경우밖에 없다고 해도 무방하다
> >   >   - 위의 조건처럼 현재 개수에서 꺼낼 수 있는 개수 `1 or 4`를 뺀 값이 이미 성공 or 실패가 기록되어있다면 해당 값이 현재 개수의 성공 실패 여부를 판단하게 해주는 것이다!
>
> 위의 이론을 통한다면 dp를 통해 둘 중 누가 이기는지 확인할 수 있을 것이었다!
>
> 음... 그러나 이 문제에서는 누가 이기는 것을 구하는 것이아니라 선턴을 잡은 근우가 가질 수 있는 최고의 최적 점수를 구하는 것이다... 음... 어떻게 접목시켜야 할지 조금 어려웠다.. 구상하다가 결국 블로그 글을 봤다. 음.. 풀이법을 우선 기록해보겠다.
>
> > 0. 2차원 DP를 선언한다 크기는 `주어지는 카드의 개수 * 주어지는 카드의 개수`이다. 해당 2차원 DP를 통해 왼쪽카드의 위치, 오른쪽 카드의 위치에 따른 현재 값을 기록한다.
> > 1. 주어지는 카드들을 받는다.
> > 2. 재귀함수를 선언한다. 인자는 현재 왼쪽 카드 인덱스, 현재 오른쪽 카드 인덱스, 진행중인 턴을 인자로 받는다.
> > 3. 현재 왼쪽 카드 인덱스가 오른쪽 카드 인덱스를 넘어서면 이는 더 이상 뽑을 카드가 없다는 뜻으로 0을 반환하여 돌아간다.
> > 4. 만약 현재의 경우가 DP에 기록되어 있다면 해당 값을 반환한다.
> > 5. 3~4에 만족하지 않는다면, 현재 턴수가 근우의 턴인지 명우의 턴인지 확인한다.
> >    1. 만약 현재 턴이 근우의 턴이라면, 최적의 경우를 기록해야하므로 왼쪽에서 카드를 뽑은 경우 + 왼쪽 카드 값과 오른쪽에서 카드를 뽑은 경우 + 오른쪽 카드 값을 각각 재귀함수를 호출하여 구하여 그 중 더 큰값을 현재 위치에 기록한다.
> >    2. 만약 현재 턴이 명우의 턴이라면, 최적의 경우 즉, 근우가 가장 작은 값을 갖게 해야하므로 왼쪽에서 카드를 뽑은 경우와 오른쪽에서 카드를 뽑은 경우를 각각 재귀함수를 호출하여 반환된 값 중 가장 작은 값을 현재 위치에 기록한다.
> >       - 단, 명우의 턴에는 뽑은 카드가 근우의 값에 포함되는 것이 아니므로 이 턴에서 뽑은 카드의 값은 더하지 않아야한다.
> > 6. 최종적으로 반환된 값이 만들 수 있는 가장 큰 값이 된다.
>
> 위와 같은 방식으로 문제를 풀었다.. 음.... 상당히 어려웠다 일단 DP를 보고도 구상 자체가 안됬었고 게임이론을 보고도 접목하기가 어려웠다... 흠............! 뭔가 문제가 머리속에서 잘 정리가 안된 느낌이었다. 나중에 한번 다시 풀어서 숙달할 필요가 있는 문제같다...!
