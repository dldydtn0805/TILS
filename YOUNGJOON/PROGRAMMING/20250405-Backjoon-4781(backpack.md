# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N, money, kcal;
double M, candy;

void buy_candy(vector<pair<int, int> >& infos)
{
    vector<int> DP(money + 1, -1);
    DP[0] = 0;
    int best_kcal = 0;
    
    for (int i=0; i<N; ++i) {
        pair<int, int> now_candy = infos[i];
        
        for (int j=1; j<=money; ++j) {
            if (j - now_candy.second >= 0 && DP[j - now_candy.second] != -1) {
                DP[j] = max(DP[j], DP[j - now_candy.second] + now_candy.first);
                best_kcal = max(best_kcal, DP[j]);
            }
        }
    }
    
    cout << best_kcal << "\n";
    
    return;
    
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    while (true) {
        cin >> N >> M;
        if (N == 0 && M == 0) break;
        money = M * 100 + 0.5;
        vector<pair<int, int> > infos;
        for (int i=0; i<N; ++i) {
            cin >> kcal >> candy;
            int price = candy * 100 + 0.5;
            infos.push_back({kcal, price});
        }
        
        buy_candy(infos);
    }

    return 0;
}

```



> ## 문제
>
> 상근이는 선영이와 걸어가다가 사탕 가게를 지나가게 되었다. 갑자기 상근이는 선영이에게 사탕이 얼마나 건강에 안 좋은지 설명하기 시작했다. 선영이는 매우 짜증이 났고, 상근이에게 누가 더 건강이 안 좋아질 수 있는지 내기를 하자고 했다. 상근이는 내기를 그 즉시 받아들였다.
>
> 두 사람은 같은 돈을 가지고 가게에 들어가서 사탕을 산다. 이때, 구매한 사탕의 칼로리가 더 큰 사람이 내기에서 이기게 된다.
>
> 상근이는 잠시 화장실에 갔다온다고 핑계를 댄 뒤에, 노트북을 열고 사탕 가게의 시스템을 해킹하기 시작했다. 이 시스템에는 현재 사탕 가게에 있는 사탕의 가격과 칼로리가 모두 등재되어 있다. 각 사탕의 개수는 매우 많기 때문에, 원하는 만큼 사탕을 구매할 수 있다. 또, 사탕은 쪼갤 수 없기 때문에, 일부만 구매할 수 없다.
>
> 사탕 가게에 있는 모든 사탕의 가격과 칼로리가 주어졌을 때, 어떻게 하면 칼로리의 합이 가장 크게 되는지를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 각 테스트 케이스의 첫째 줄에는 가게에 있는 사탕 종류의 수 n과 상근이가 가지고 있는 돈의 양 m이 주어진다. (1 ≤ n ≤ 5,000, 0.01 ≤ m ≤ 100.00) m은 항상 소수점 둘째자리까지 주어진다.
>
> 다음 n개 줄에는 각 사탕의 칼로리 c와 가격 p가 주어진다. (1 ≤ c ≤ 5,000, 0.01 ≤ p ≤ 100.00) c는 항상 정수, p는 항상 소수점 둘째자리이다.
>
> 입력의 마지막 줄에는 '0 0.00'이 주어진다.
>
> ## 출력
>
> 각 테스트 케이스에 대해서, 상근이가 돈 m을 가지고 구매할 수 있는 가장 높은 칼로리를 출력한다.
>
> ## 해설
>
> 처음 문제를 봤을때 배낭 문제가 떠올랐다 하지만 주어지는 가격이 실수로 주어지므로 인덱스 값을 이용해 할수 없으니 unordered_map을 이용하여 배낭 문제를 하려고 했다.
>
> 그러나 여기서 문제가 발생했다. set에 기록되는 값이 늘어남에 따라 시간이 너무늘어났기 때문이다.
>
> 그래서 계속 고민해보다가 음... 실수를 *100해서 정수로 바꾸어서 하면 안될까? 생각했다. 하지만 그래도 기존에 구상했던 배낭 문제를 풀면 시간이 터질 것 같았다.
>
> 결국 다른 사람의 코드를 봤는데 틀린점이 2가지 있었다.
>
> > 1. 배낭 문제 진행 방식이 잘못됨
> > 2. double의 연산이 문제가 많음 -> int로 바꾸자! -> double의 실수가 늘 정확하지 않기에 int로 바꾸면 오차가 발생함
>
> - 배낭 문제 진행 방식이 잘못됨
>
>   - 기존에 생각했던 방식은 현재 순회중인 사탕을 여러번 살 수 있기 때문에 현재있는 위치에서 가능한한 사려고 했었다. 그러나 이는 잘못된 방식이다 최대 값이 1만이니까 사탕값이 1원이면 모든 10000개의 가격에 대해 최대 1만번씩 연산을 해서 1억번이 들어가는 것이었다 이것이 5천번 반복되면...어우...
>   - 위처럼 처음에 생각했기 때문에 정수로 바꾼다한들 시간초과가 날 것이라고 생각했다... 하지만 1만개의 경우에서 반드시 모든 값에 대해 1만개를 연산할 필요가 없었다. 그냥 그저 모든 1만개에 대해서 이 사탕을 살래? 라고 물어보는 것이다. 즉, 모든 사탕에 대해 단 1만번의 연산만 하면 되는것이었다. 이렇게하면 자연스럽게 알아서 여러번 산것도 체크가 된다 하아.. 배낭 문제 개념을 까먹은건지 참 아쉽다.. 이걸 알았으면 ...
>
> - double의 연산이 문제가 많음 -> int로 바꾸자! -> double의 실수가 늘 정확하지 않기에 int로 바꾸면 오차가 발생함
>
>   - double은 실수로 이를 연산하는 과정에서 오차가 발생하는것이 꽤 유명하다. 실제로 C++의 math 라이브러리의 pow()는 실수로 제곱값을 연산하기 때문에 이를 많이 반복하면 오차가 발생하는 경우가 발생할 수 있었고 이를 실제로 겪어보았다. 그렇기에 실수를 가지고 배낭의 사이즈를 측정하는 건 음.. 위험할 수 있었다.
>
>   - 그래서 int로 바꿀래! 라고 한다고 해도 이는 쉽지 않다. 결국 소수점 둘째 자리까지는 주어지니 * 100을 해야하는데 이 연산에서 조차 오차가 발생할 수도 있기 때문이다.. (레전드)
>
>     그래서 int로 변환하려면 오차 보정을 해주어야 한다.
>
>     ```
>     int money = M * 100 + 0.5;
>     ```
>
>     여기서 0.5 를 더해서 보정해주는 것이다. int는 소수점 아래의 모든 값을 버리고 정수형만 가져간다 double의 연산에서 만약 7.00 * 100이 오차로 인해 6.99가 되었다고 가정해보자
>
>     그럼 int는 7이 아닌 6을 가진다. 이렇게 크게 오차가 발생해버리는 것이다 이를 막기 위해 0.5를 더해주면 7.49가 되어 int로 변환하여도 7이 되는 것이다.
>
> 위와 같은 2개의 방식을 적용하였더니 맞았다! 흐음... 상당히 어려웠다 배낭 문제를 그저께도 풀었는데 그 개념을 헷갈려 틀리다니... 수련이 더 필요한것 같다..
