# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;
// V = 약속 장소의 개수, M = 길의 개수, J = 지현이의 위치, S = 성하의 위치
int V, M, J, S;

vector<vector<int> > dist_graph;

void prouid()
{
    for (int i=1; i<=V; ++i) {
        dist_graph[i][i] = 0;
    }
    
    for (int k=1; k<=V; ++k) {
        for (int i=1; i<=V; ++i) {
            for (int j=1; j<=V; ++j) {
                dist_graph[i][j] = min(dist_graph[i][k] + dist_graph[k][j], dist_graph[i][j]);
                // cout << i << " " << j << " " << k << " " << dist_graph[i][j] << "\n";
            }
        }
    }
    
    int result = 100000000;
    vector<int> best_loca;
    int best_node = V+1;
    int near_from_J = 100000000;
    
    for (int i=1; i<=V; ++i) {
            if (i != J && i != S) {
                int tmp = dist_graph[J][i] + dist_graph[S][i];
                if (result > tmp) {
                    result = tmp;
            }
        }
    }
    
    for (int i=1; i<=V; ++i) {
        if (i != J && i != S) {
            int tmp = dist_graph[J][i] + dist_graph[S][i];
            
            if (result == tmp && dist_graph[J][i] <= dist_graph[S][i] && near_from_J > dist_graph[J][i]) {
                near_from_J = dist_graph[J][i];
            }
        }
    }
    
    for (int i=1; i<=V; ++i) {
        if (i != J && i != S) {
            int tmp = dist_graph[J][i] + dist_graph[S][i];
            if (result == tmp && dist_graph[J][i] == near_from_J) {
                best_loca.push_back(i);
            }
        }
    }
    
    for (int i : best_loca) {
        if (dist_graph[J][i] <= dist_graph[S][i]) {
            if (best_node > i) {
                best_node = i;
            }
        }
    }
    
    if (best_node == V+1) {
        cout << -1;
    }
    else {
        cout << best_node;
    }
    
    return;
}


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> V >> M;
    int s, e, dist;
    dist_graph.resize(V+1, vector<int>(V+1, 100000000));
    
    for (int i=0; i<M; ++i) {
        cin >> s >> e >> dist;
        
        if (dist_graph[s][e] > dist) {
            dist_graph[s][e] = dist;
        }
        if (dist_graph[e][s] > dist) {
            dist_graph[e][s] = dist;
        }
        
    }
    
    cin >> J >> S;
    
    prouid();

    return 0;
}

```



# 해설

> 연예인 김영광을 너무 닮아서 길거리에서 매번 사진이 찍히는 지헌이는 사람들에게 노출되는 것을 매우 꺼려한다. 하지만 친구인 성하와 약속을 하면 성하는 매번 늦기 때문에 길거리에 나온 지헌이는 매번 성하를 기다린다. 약속 장소에서 성하에게 전화를 하면 매번 “가는 중” 이라는 대답만 듣고 기다리는 동안 길거리에서 사람들에게 사진을 찍히는 지헌이는 스트레스를 심하게 받고 있다. 참지 못한 지헌이는 성하의 핸드폰을 해킹하여서 항상 어디 있는지 알 수 있게 되었다.
>
> 스트레스가 심해진 지헌이는 성하와의 약속 장소를 바꾸려고 한다. 그 위치는 다음과 같은 조건을 만족해야 한다. 장소의 번호는 1부터 차례대로 붙어 있다.
>
> 1. 지헌이의 출발 위치와 성하의 출발 위치는 새로운 약속 장소가 될 수 없다.
>2. 성품도 훌륭한 지헌이는 새로운 약속 장소는 지헌이가 걸리는 최단 시간과 성하가 걸리는 최단 시간의 합이 최소가 되도록 하고 싶다.
> 3. 지헌이가 더 늦게 도착하면 성하에게 안좋은 소리를 들을 것이 뻔하기에, 1번과 2번 조건을 만족하는 장소 중에서도 지헌이가 성하보다 늦게 도착하는 곳은 약속 장소가 될 수 없다.
>4. 위의 세 조건을 모두 만족하는 약속 장소가 여러 곳이 있다면, 그 중에 지헌이로부터 가장 가까운 곳이 최종 약속 장소가 된다. 그런 장소도 여러 곳이 있다면, 그 중에 번호가 가장 작은 장소가 최종 약속 장소가 된다.
> 
>![img](https://upload.acmicpc.net/fe6c7237-d6f3-417c-9eeb-a368228bc999/-/preview/)
>  
>
> 위와 같은 상황이 있다고 했을 때 새로 바꿀 약속 장소를 찾아보자.
> 
> - (조건 1) 3번과 6번은 지헌이와 성하의 출발지이기 때문에 새로운 약속 장소 후보에서 제외된다.
> - (조건 2) 위 상황에서 성하와 지헌의 최단 거리의 합의 최소는 6분이다. 이 때, 조건을 만족하는 약속 장소는 1번, 2번, 5번, 7번이다.
> - (조건 3) 5번은 성하가 먼저 도착하여서 기달리고 있기 때문에 지헌이는 꾸중을 들을 위험이 있다. 그래서 5번은 약속 장소 후보에서 제외된다.
> - (조건 4) 2번 위치는 성하와 지헌이가 동시에 도착, 7번은 지헌이는 2분 걸려서 도착하고 성하는 4분 걸려서 도착한다. 1번은 지헌이는 1분, 성하는 5분 걸려서 도착한다. 따라서, 지헌이가 원하는 이상적인 약속 장소는 1번이 된다.
> 
> 연예인을 닮아서 고통받는 지헌이를 위해 새로운 약속장소를 찾아주자.
> 
> 들어가기 앞서 단언컨데 이런 거지같은 문제는 세상에 존재해서는 안된다.
> 
>처음 보자마자 생각난건 플루이드 워샬이다. 많이 써본 알고리즘은 아니라 처음에 안보고 풀려고 했는데 의외로 플루이드 워샬은 그냥 거치는곳, 현재 위치, 도착 위치에 대해서 따로 만져주지 않아도 알아서 관리를 잘했다. 이 점은 나의 실수로 인해 틀린 것이 맞다.
> 
>문제 자체는 간단한 플루이드 워샬이다. 따라서 이 로직까지는 맞았는데 상단의 조건 4가지와 괴상망측한 입력이 문제가 되었다.
> 
>우선적으로 조건은 모두 한꺼번에 알아보는 것이 아니라 순차적으로 알아봐야했다. 그래서 일일이 해당하는 조건들을 1개씩 다 따져서 정답후보를 골랐고 그 중 가장 번호가 낮은 값을 출력했다.
> 
>그런데 진짜 문제를 풀면서 가장 어이가 없었던 점이 똑같은 간선이 가중치를 다르게해서 계속 들어온다는 것 이었다. 당장 플루이드 워샬을 쓰면 이를 공지하지 않거나 따로 예제를 주지 않으면 2차원 그래프의 간선 가중치가 갱신되어서  답이 무조건적으로 틀리게 되는데 이걸 질문 게시판에 들어가서 알 수 있다는 것 자체가 나는 이해가 되지 않는다. 가중치가 중복되어서 들어온다는 말 한마디만해도 관리하는게 어렵지 않은데 이걸 굳이 이렇게 하는 이유를 알 수가 없었다. 문제 조건 또한 두리뭉슬하게 적어놓아서 3번 조건에서 헤매는 경우가 많을 것이다. 왜냐하면 지현이가 더 멀리가는 둘의 최단거리 7이 있을 때, 지현이가 더 가까운 최단거리 8이 있으면 이미 7이 최단거리라서 8은 최단거리가 아니므로 8짜리는 정답이 될 수 없다는 것이다.  나는 3번 조건에서 탈락한 위치는 배제하고 새로운 최단거리를 봐야한다고 생각했는데 문제를 이해하기가 너무 어려웠다.
> 
>이게 알고리즘 문제인지 독해력 문제인지 알 수가 없었다
> 
>후기 :  최악, 정답률 10%대는 다 이유가 있다.
