# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>

#define pll pair<int, int>

using namespace std;

int s, e;
int board[5][5];
vector<pll> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};


struct Compare
{
	bool operator()(const pair<int, pll>& a, const pair<int, pll>& b) {
		return a.first > b.first;
	}
};


int let_s_move()
{
	vector<vector<int> > visited(5, vector<int>(5, 999999));
	priority_queue<pair<int, pll>, vector<pair<int, pll> >, Compare> que;
	que.push({0, {s, e}});
    visited[s][e] = 0;

	while (!que.empty()) {
		int now_turn = que.top().first;
		pll now = que.top().second;
		que.pop();
		if (board[now.first][now.second] == 1) return now_turn;

		for (int i=0; i<4; ++i) {
			int nx = now.first + directions[i].first;
			int ny = now.second + directions[i].second;

			if (0 <= nx && nx < 5 && 0 <= ny && ny < 5 && visited[nx][ny] > now_turn + 1 && board[nx][ny] != -1) {
				visited[nx][ny] = now_turn + 1;
				que.push({now_turn + 1, {nx, ny}});
			}
            if (0 <= nx && nx < 5 && 0 <= ny && ny < 5 && board[nx][ny] != -1 && board[nx][ny] != 7) {
				while (true) {
					if (0 <= nx + directions[i].first && nx + directions[i].first < 5 && 0 <= ny + directions[i].second && ny + directions[i].second < 5 && board[nx + directions[i].first][ny + directions[i].second] != -1) {
						nx += directions[i].first;
						ny += directions[i].second;
						if (board[nx][ny] == 7) {
							break;
						}
					}
					else break;
				}

				if (visited[nx][ny] > now_turn + 1) {
				    visited[nx][ny] = now_turn + 1;
					que.push({now_turn + 1, {nx, ny}});
				}
            }
		}
	}

	return -1;

}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	for (int i=0; i<5; ++i) {
		for (int j=0; j<5; ++j) {
			cin >> board[i][j];
		}
	}
	cin >> s >> e;

	cout << let_s_move();

	return 0;
}

```

> ## 문제
>
> 5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자에는 **-1, 0, 1, 7**중 하나의 숫자가 적혀 있다. 격자의 위치는 (*r*, *c*)로 표시한다. *r*은 행 번호, *c*는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽 방향으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다. -1이 적혀 있는 칸으로는 이동할 수 없고 0, 1, 7이 적혀 있는 칸으로는 이동할 수 있다.
>
> 현재 한 명의 학생이 (*r*, *c*) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한 방향으로 한 칸 걸어갈 수 있다. 또한 학생은 한 번의 이동으로 **상, 하, 좌, 우 방향 중에서 한 방향으로 -1이 적혀 있는 칸을 만나거나 보드의 밖으로 벗어나서 이동할 수 없을 때까지 뛰어갈 수 있다.** 단, 뛰어가는 중에 7이 적혀 있는 칸을 만나면 이동을 끝내고 해당 칸에서 멈춘다. 뛰어가다가 멈추기 전까지 중간에 지나가는 칸은 방문하지 않은 것으로 간주한다. 걸어가는 동작과 뛰어가는 동작 모두 1회 이동으로 생각한다. 학생이 현재 위치 (*r*, *c*)에서 시작하여 1이 적혀 있는 칸으로 이동하기 위한 최소 이동 횟수를 출력하자. 학생이 현재 위치 (*r*, *c*)에서 시작하여 1이 적혀 있는 칸으로 이동할 수 없는 경우 –1을 출력한다. 보드에는 1이 적혀 있는 격자가 1개 주어진다.
>
> ## 입력
>
> 첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 정보가 순서대로 주어진다. *i*번째 줄의 *j*번째 숫자는 보드의 (*i* - 1)번째 행, (*j* - 1)번째 열의 정보를 나타낸다. 보드의 정보는 -1, 0, 1, 7중 하나이다.
>
> 다음 줄에 학생의 현재 위치 *r*, *c*가 빈칸을 사이에 두고 순서대로 주어진다.
>
> ## 출력
>
> 학생이 현재 위치 (*r*, *c*)에서 1이 적혀 있는 칸에 도착하기 위한 최소 이동 횟수를 출력한다. 현재 위치 (*r*, *c*)에서 1이 적혀 있는 칸으로 이동할 수 없는 경우 -1을 출력한다.
>
> ## 제한
>
> - 0 ≤ *r*, *c* ≤ 4
> - 학생의 현재 위치 (*r*, *c*)에는 0이 적혀 있다.
> - 1이 적혀 있는 칸이 1개 주어진다.
>
> ## 해설
>
> 처음 문제를 봤을 때 BFS 를 떠올렸다. 주어지는 시작 위치에서 4방향으로 1칸 이동하거나, 가능한 끝까지 이동하는것 2가지를 진행한다. 단, 경로가 -1에 막히면 -1 이전 위치에 멈추고 7을 만나면 그 자리에 멈춰야한다.
>
> > 1. 주어지는 값들을 받는다. 그 후 주어진 격자와 똑같은 크기의 방문처리를 기록할 2차원 배열 visited를 선언한다.
> >
> > 2. 주어진 현재 위치를 우선순위 큐인 que에 넣고 BFS를 시작한다. 이때 우선순위는 이동횟수가 가장 적은 값이 우선순위를 갖는다.
> >
> >    > 1. que에서 값 하나를 꺼낸다. 해당 값에는 현재 이동 횟수와 위치가 들어있다.
> >    > 2. 현재 위치에서 4방향으로 이동한다.
> >    >    - 먼저 1칸 이동한다. 이때 격자를 벗어나거나 벽(-1)을 만나면 이동처리하지 않는다. 아닐 경우는 현재 이동횟수에 1을 더하여 que에 넣는다.
> >    >    - 이후 동일한 방향으로 가능한 한 계속 이동한다. 격자 끝을 만나거나 벽을 만나거나 7을 밟을때까지 계속 이동한다. 만약 위의 세 가지 이유 중 어떤 것이라도 해당 되어 멈추면 해당 위치를 현재 이동횟수에 1을 더하여 que에 넣는다.
> >    > 3. 만약 1에서 값을 꺼냈을 때, 해당 위치가 1이라면 최소 이동횟수가 우선순위이므로 현재 도달한 턴이 최소의 턴이 보장되므로 해당 턴을 반환한다.
> >    > 4. 만약 que가 모두 빌때까지 3의 경우가 나타나지 않으면 갈 수 없다는 뜻이므로 -1을 반환한다.
> >
> > 3. 2에서 반환한 값을 출력한다.
>
> 위와 같은 방식으로 문제를 풀었다. 음... 처음에 바로 로직을 떠올려서 문제를 풀었지만 틀렸습니다를 받았는데 그 이유는 바로 1칸 움직이기와 끝까지 움직이기를 동시에 처리하려 했기 때문이다... 이전 코드에서는 1칸 움직이는게 성공해야 끝까지 움직였는데 아래와 같은 경우에 문제가 생겼다.
>
> 아래의 이동횟수가 기록된 경우를 살펴보자
>
> ```
> 9 9 2 9 9
> 9 9 2 9 9
> 9 X 2 9 9
> 0 1 0 9 9
> ```
>
> 현재 위치가 X라고 가정하고 현재위치에 기록된 값이 2일때 오른쪽으로 이동할 때 이동하는 값은 3이므로 한 칸 이동은 실패한다. 그러나 끝까지 간 (2, 4)의 위치는 기록된 값이 9 이므로 끝까지 이동 하면 좋은 이동횟수를 기록할 수 있었다.
>
> 초기 코드에 1칸 이동이 성공한 후 그 값에서 추가로 끝까지 더하는 코드로 작성했기 때문에 1칸 이동이 성공해야 끝까지 가는 코드도 돌아갔었고 이 때문에 틀린것이었다.
>
> 코드를 짧게 하자고 재활용하는건 좋지만 그렇게 했을때 로직이 잘 돌아가는지 확인하고 코드를 작성하는 것이 매우 중요하겠다.

