# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N;
int INF = 123456789;
vector<int> prime_num(40001, 0);
vector<int> dp(40001, 0);
vector<int> primes;

void find_prime()
{
    for (int i=2; i<=40000; ++i) {
        if (prime_num[i] == 0) {
            prime_num[i] = 1;
            primes.push_back(i);
            int tmp = 2;
            while (i * tmp <= 40000) {
                prime_num[i * tmp] = 2;
                tmp++;
            }
        }
    }
    
    return;
}

void make_dp()
{
    dp[0] = 1;
    
    for (int a : primes) {
        for (int i=a; i<40001; ++i) {
            dp[i] += dp[i-a];
            dp[i] %= INF;
        }
    }
    
    cout << dp[N];
    
    return;
}

int main()
{
    cin >> N;
    
    find_prime();
    make_dp();

    return 0;
}

```



# 해설

> ## 문제
>
> 소수나라는 특이하게 모든 소수(prime number)를 화폐 단위로 사용한다.
>
> 소수나라에 놀러 온 하나는 관광을 하다가 가격이 N인 물건을 발견하고 너무 마음에 들어 999983원을 내고 구매하려고 했다. 하지만 상점 주인이 거스름돈이 없어 정확히 N원을 지불해달라고 하였다.
>
> 물건을 구매하려던 하나는 소수나라의 화폐를 이용하여 N원을 정확히 만들 수 있는 방법의 가짓수가 얼마나 되는지 궁금해졌다.
>
> 하나를 도와 N원을 지불하기 위한 가짓수가 얼마나 되는지 구해보자.
>
> 단, 하나는 소수나라의 모든 화폐가 무한정 있다고 가정한다.
>
> ## 입력
>
> 구매하려고하는 물건의 값 N(2 ≤ N ≤ 40,000, N은 정수)이 주어진다.
>
> ## 해설
>
> 처음 문제를 봤을 때 에라토스테네스의 체를 이용해 소수를 찾고 이를 DP를 이용해 값을 찾으려고 했다
>
> 그런데 DP를 구현하다보니 아래와 같은 문제가 발생했다.
>
> ```
> 8 일때
> 2 + 6 = 2원 4개
> 3 + 5 = 3원 1개 5원 1개, 3원 2개 2원 1개
> 4 + 4 = 2원 4개 (중복)
> 
> 9 일때
> 2 + 7 = [2, (2+5)], [2, 7]
> 3 + 6 = [3, (3+3)], [3, (2*3)]
> 5 + 4 = [5, (2, 2)], [2+3, 2+2] (2+7과 중복)
> 
> 7
> 2 + 5 [2+5, 2+2+3]
> 3 + 4 [3+2+2] (2+5와 중복 발생)
> 7
> ```
>
> 위의 예제들에서 전부 중복이 발생하는 것이었다...
>
> 중복되는 개수를 처리하지 못하면 제대로 된 값을 계산할 수 없기때문에 이를 해결하려고 애를 먹었으나 아무리 생각해도 곧잘 떠오르지 않았다...
>
> 그래서 결국 힌트를 보았는데 1년전에 풀었던 문제와 상당히 유사하다는 걸 알 수 있었다.
>
> 그래서 그 때 풀었던 코드를 참고하였는데 로직은 다음과 같다.
>
> > dp[0] = 1을 할당한다.
> >
> > 소수들의 모음 (40000 이하)을 순회한다. 현재 순회 중인 소수의 값부터 40000까지 순회한다. 현재 위치에서 순회 중인 소수 값을 뺀 위치의 값 만큼 현재 위치에 더한다.
> >
> > 소수 2를 예시로 들어보자
> >
> > 가장 먼저 2부터 시작한다 2-2 = 0이므로 dp[0] = 1이니 dp[2]에 1을 더한다.
> >
> > 3은 dp[1] = 0 이기에 0만 더한다.
> >
> > 4는 dp[2]가 1이기에 1을 더한다.
> >
> > 5는 dp[3] = 0이라 0만 더한다.
> >
> > 6은 dp[4] = 1이기에 1만 더한다.
> >
> > ...
>
> 위의 규칙을 보면 흥미로운 사실을 알 수 있는데 현재 순회 중인 소수로만 만들 수 있는 조합이 완성된다. 즉, 2로 만들 수 있는 모든 숫자들이 1의 값이 주어지는 것이다. 이후에 3을 순회하면 5를 볼때 dp[2] = 1이므로 1을 더해주게 된다. 즉 중복없이 만들 수 있는 화폐 조합의 개수를 구할 수 있게 되는 것이다.
>
> 꽤 오래전에 풀었다지만 그때 풀었던 문제와 동일한 로직을 요했고, 그때도 똑같이 중복때문에 애를 먹었던 거로 기억하는데 또 못풀어서 상당히 아쉽다... 이번 기회에 꼭 가져가도록 하자 중복을 관리하는 문제는 생각보다 많이 나오는 것 같으니까...
