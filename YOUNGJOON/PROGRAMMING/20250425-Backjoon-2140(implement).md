# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, result = 0;
vector<vector<char> > board(100, vector<char>(100));
vector<pair<int, int> > directions = {{0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};

void check_around(int x, int y)
{
    for (int i=0; i<8; ++i) {
        int nx = x + directions[i].first;
        int ny = y + directions[i].second;
        
        if (('1' <= board[nx][ny] && board[nx][ny] <= '9') || board[nx][ny] == '#') {
            continue;
        }
        else return;
    }
    
    for (int i=0; i<8; ++i) {
        int nx = x + directions[i].first;
        int ny = y + directions[i].second;
        if ('1' <= board[nx][ny] && board[nx][ny] <= '9') board[nx][ny]--;
    }
    
    result++;
    
    return;
}

void find_mine()
{
    for (int i=1; i<N-1; ++i) {
        for (int j=1; j<N-1; ++j) {
            if (i == 1 || i == N-2) {
                check_around(i, j);
            }
            else if (j == 1 || j == N-2) {
                check_around(i, j);
            }
            else {
                result++;
            }
        }
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    
    for (int i=0; i<N; ++i) {
        for (int j=0; j<N; ++j) {
            cin >> board[i][j];
        }
    }
    
    find_mine();
    
    cout << result;

    return 0;
}

```

> ## 문제
>
> 지뢰찾기는 N×N에서 이뤄지는 게임이다. 보드의 곳곳에는 몇 개의 지뢰가 숨겨져 있고, 지뢰가 없는 칸에는 그 칸과 인접(상하좌우 및 대각선)해 있는 8개의 칸들에 몇 개의 지뢰가 숨겨져 있는지에 대한 정보가 주어진다. 게이머는 게임을 진행하면서 보드의 칸을 하나씩 열게 된다. 만약 그 칸에 지뢰가 있다면 게임이 끝나고, 없는 경우에는 그 칸에 적혀있는 숫자, 즉 그 칸과 인접해 있는 8개의 칸들 중 몇 개의 칸에 지뢰가 있는지를 알 수 있게 된다.
>
> 이 문제는 보드의 테두리가 모두 열려있고, 그 외는 모두 닫혀있는 상태에서 시작한다. 예를 들어 다음과 같은 경우를 보자.
>
> | 1    | 1    | 1    | 0    | 0    |
> | ---- | ---- | ---- | ---- | ---- |
> | 2    | #    | #    | #    | 1    |
>| 3    | #    | #    | #    | 1    |
> | 2    | #    | #    | #    | 1    |
>| 1    | 2    | 2    | 1    | 0    |
> 
>   \#는 닫혀있는 칸을 나타낸다. 이러한 보드가 주어졌을 때, 닫혀있는 칸들 중 최대 몇 개의 칸에 지뢰가 묻혀있는지 알아내는 프로그램을 작성하시오. 위의 예와 같은 경우에는 다음과 같이 6개의 지뢰가 묻혀있을 수 있다.
> 
> | 1    | 1    | 1    | 0    | 0    |
> | ---- | ---- | ---- | ---- | ---- |
> | 2    | *    |      |      | 1    |
> | 3    | *    | *    | *    | 1    |
>   | 2    | *    | *    |      | 1    |
> | 1    | 2    | 2    | 1    | 0    |
>   
> ## 입력
>   
> 첫째 줄에 N(1≤N≤100)이 주어진다. 다음 N개의 줄에는 N개의 문자가 공백 없이 주어지는데, 이는 게임 보드를 의미한다.
>   
> ## 출력
>   
> 첫째 줄에 묻혀있을 수 있는 지뢰의 최대 개수를 출력한다.
>   
> ## 해설
>   
> 처음 문제를 봤을 때 테두리에만 지뢰의 주변개수가 주어지기 때문에 테두리에 인접하지 않은 부분은 지뢰가 있는지 없는지 판별할 수가 없다고 생각했다. 그런데 지뢰의 최대 개수를 구하려 하였으니 지뢰가 없는 부분만 찾아서 고려하고 테두리에 인접하지 않은부분은 지뢰가 있을수도, 없을수도 있기 때문에 무조건 있다고 가정하여 문제를 풀기로 했다.
>   
> 예전에 비슷한 문제를 푼적이 있는것 같은데 테두리를 기준으로 보는것보단 테두리에 붙어있는 #에서 주변 테두리가 현재 위치에 지뢰가 있다는걸 뜻하는지 알아보는 것이 더 수월하게 풀렸던 기억이 있었다.
>   
> 그래서 아래와 같은 방법으로 진행한다.
>
> > 1. 주어지는 보드에서 테두리에 인접하지 않은 '#'은 지뢰로 간주하여 개수를 1 더한다.
>>
> > 2. 테두리에 인접한 '#'은 9방향을 순회하여 순회 중인 위치의 값이 '#'이면 넘어가고 '1' ~ '9'만 존재한다면 지뢰로 간주하고 지뢰 개수를 1 더한 후, 모든 인접한 숫자의 값에 -1을한다.
>>
> >    단, 순회 중인 위치에 `'0'`이 있다면 지뢰가 절대로 없다는 이야기 이므로 현재 위치에 지뢰가 없다고 체크한다.
>>
> > 3. 1에서 구한 값과 2에서 구한 값을 더해 출력한다.
> 
> 뭔가 까다로울줄 알았는데 생각보다 쉽게 풀린 문제였다. 연산의 횟수를 줄이고 간단하게 한 것이 잘 먹힌 것 같다!
> 
> 다음에도 수월하게 풀 수있으면 좋겠다!

