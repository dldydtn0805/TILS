# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    int N, num, mid;
    priority_queue<int, vector<int>, greater<int> > high_que;
    priority_queue<int, vector<int>, less<int> > low_que;
    
    cin >> N;

    int low_size = 0, high_size = 0;
    for (int i=1; i<=N; ++i) {
        cin >> num;
        
        if (i == 1) {
            mid = num;
        }
        else {
            if (num < mid) {
                if (low_size - high_size <= 0) {
                    if (i % 2 == 0 && num < mid) {
                        high_que.push(mid);
                        high_size++;
                        low_que.push(num);
                        mid = low_que.top();
                        low_que.pop();
                    }
                    else{
                        low_que.push(num);
                        low_size++;
                    }
                }
                else {
                    high_que.push(mid);
                    high_size++;
                    low_que.push(num);
                    mid = low_que.top();
                    low_que.pop();
                }
            }
            else if (num > mid) {
                if (high_size - low_size <= 0) {
                    high_que.push(num);
                    high_size++;
                }
                else {
                    low_que.push(mid);
                    low_size++;
                    high_que.push(num);
                    mid = high_que.top();
                    high_que.pop();
                }
            }
            else {
                if (low_size > high_size) {
                    high_size++;
                    high_que.push(num);
                }
                else {
                    low_size++;
                    low_que.push(num);
                }
            }
        }
        
        
        cout << mid << "\n";
    }

    return 0;
}

```



> ## 문제
>
> 백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.
>
> 예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.
>
> ## 해설
>
> 처음 문제를 보았을때 우선순위 큐 2개를 사용하면 어떨까 하는 막연한 생각이 떠올랐다.
>
> 일단 처음 떠오른 생각이니까 이걸 붙잡고 진행해보려 했다. 
>
> > 1. mid값을 두고 이를 기준으로 mid값보다 낮은 값을 가진 값이 높은 값을 우선순위로 갖는 큐,  mid값보다 높은 값을 가진 낮은 값을 우선순위로 갖는 큐를 두었다.
> >
> > 2. 새로운 값이 들어오면 mid와 값을 비교한다. 만약 값이 더 크다면 mid보다 큰 우선순위 큐에, 값이 작다면 mid보다 작은 우선순위 큐에 넣는다.
> >
> > 3. 만약 우선순위 큐에 값을 넣으려는데 넣으려는 우선순위 큐가 반대 우선순위 큐보다 사이즈가 1개 더 많다면 mid값을 보정해야 한다.
> >
> >    현재 mid값을 반대편 큐로 보내고, 넣으려는 우선순위 큐에 새로운 값을 넣은 후 우선순위가 가장 높은 값을 pop하여 mid값에 등록한다. 이렇게 하면 두 개의 큐의 크기가 맞춰지며 mid값이 올바름을 알 수 있다.
> >
> > 4. 만약 짝수번째에서 현재 mid값보다 낮은 값을 넣을때는 양 옆의 값이 일정하지 않으므로 넣으려는 값과 mid값을 비교하여 더 작은 값을 꺼내야한다.
> >
> >    ```
> >    4
> >    -3
> >    9
> >    7
> >    5
> >    ```
> >
> >    위의 입력을 예시로 들어보자
> >
> >    ```
> >    -3
> >    -3
> >    7
> >    5
> >    ```
> >
> >    가 순서대로 출력되어야 한다. 하지만 4번째를 보면 {-3} 7 {9}인 상황에서 5는 7보다 작다. 따라서 {-3, 5} 7 {9}가 되겠지만 이는 틀렸다. 문제의 조건에서 mid 값이 2개라면 더 작은 값을 출력하기로 했기 때문이다. 즉, 낮은 값을 우선순위로 가지는 큐로 값이 들어가면 현재 mid값과 비교하여 둘이 바꾸고 이전 mid 값을 큰 값을 우선순위로 가지는 큐로 넣어야한다. 만약 {-3} 7 {9}인 상황에서 mid값보다 큰값이 들어왔다면 어땠을까? 둘 중 낮은 값이 mid여야 하니까 큰 값으로 들어가는건 보정할 필요가 없다!
> >
> >    - 그렇다면 왜 짝수번에서만...?
> >      - 홀수 번에서는 무조건 양 옆의 밸런스가 맞춰 들어가야한다. 따라서 두개의 우선순위 큐의 사이즈를 맞추는 과정에서 알아서 보정이 되기 때문이다. 하지만 짝수번은 mid 값이 2개 존재할 수 있는 상황이기 때문에 보정을 해주어야 하는 것!
>
> 위의 방법으로 푸니까 바로 풀렸다 사실 문제를 제출하고나서 한번 틀려서 2개의 반례를 얻어 풀긴했다.. 흠... 방법은 맞았지만, 문제의 조건에 따른 보정방법까지 생각을 안해보아서 틀렸던 것이다. 이것까지 한번에 생각했으면 좋았을것을... 좀 아쉽지만 난이도에 비해 빠르게 풀어서 기분이 좋다! 다음에는 좀 더 수월하게 풀 수 있었으면 좋겠다!

