# 코드

```c++
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

string prefix;
vector<char> stacker;
unordered_map<char, int> comp = {{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};

void make_postfix()
{
    string postfix;
    for (char c : prefix) {
        if (c - 'A' < 0) {
            if (c == '(') {
                stacker.push_back(c);
            }
            else if (c == ')') {
                while (stacker.back() != '(') {
                    postfix += stacker.back();
                    stacker.pop_back();
                }
                stacker.pop_back();
            }
            else {
                while (stacker.size() > 0 && stacker.back() != '(' && comp[stacker.back()] >= comp[c]) {
                    postfix += stacker.back();
                    stacker.pop_back();
                }
                stacker.push_back(c);
            }
        }
        else {
            postfix += c;
        }
    }
    
    if (stacker.size() > 0) {
        while (stacker.size() > 0) {
            postfix += stacker.back();
            stacker.pop_back();
        }
    }
    
    cout << postfix;
    
    return;
}

int main()
{
    cin >> prefix;
    
    make_postfix();

    return 0;
}

```



> ## 문제
>
> 수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 `a+b`는 전위 표기법으로는 `+ab`이고, 후위 표기법으로는 `ab+`가 된다.
>
> 이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 `a+b*c`를 후위 표기식으로 바꾸면 `abc*+`가 된다.
>
> 중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.
>
> 예를 들어 `a+b*c`는 `(a+(b*c))`의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 `*`를 괄호 밖으로 꺼내게 되면 `(a+bc*)`가 된다. 마지막으로 또 `+`를 괄호의 오른쪽으로 고치면 `abc*+`가 되게 된다.
>
> 다른 예를 들어 그림으로 표현하면 `A+B*C-D/E`를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.
>
> ![img](https://upload.acmicpc.net/5aad2feb-d9fc-430a-954d-73a06ba0215f/-/preview/)
>
> 결과: `ABC*+DE/-`
>
> 이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오
>
> ## 입력
>
> 첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 `-A+B`와 같이 `-`가 가장 앞에 오거나 `AB`와 같이 `*`가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 `+`, `-`, `*`, `/`, `(`, `)`로만 이루어져 있으며, 길이는 100을 넘지 않는다. 
>
> ## 해설
>
> 처음 문제를 봤을 때 이전에 자료구조 책에서 배웠던 스택 부분에서 후위 표기법에 대해서 자세히 설명해주신 것이 있어서 그걸 이용해보기로 했다.
>
> 진행하는 방식은 다음과 같다 
>
> > 중위 표기법을 맨 왼쪽부터 순회하며 진행한다.
> >
> > 0. 스택 하나와 새로운 후위 표기법을 저장할 변수 하나를 선언한다.
> >
> > 1. 숫자(여기선 알파벳 대문자)는 무조건 후위 표기법 변수로 보낸다.
> >
> > 2. 연산자가 나오면 스택으로 보낸다.
> >
> >    2-1. 만약 스택에 아무것도 없다면 해당 연산자를 바로 저장한다.
> >
> >    2-2. 만약 스택에 이미 연산자가 있다면 스택의 가장 위에 있는 연산자의 사칙연산의 우선순위를 파악한다. `임의로 정하면 ( + = 1, - = 1, * = 2, / = 2)` 그리고 현재 넣으려는 연산자의 우선순위보다 작거나 같은 연산자는 스택에서 빼고 후위 표기법 변수 뒤에 붙인다.
> >
> >    이를, 스택이 다 빌때까지 혹은 자신보다 더 높은 우선순위의 연산자가 스택의 맨 뒤에 나타날 때까지 반복한다.
> >
> > 3. 1~2를 중위 표기법을 전부 순회할때 까지 반복한다. 중위 표기법의 순회가 끝난다면 마지막으로 stack에 연산자들이 남았는지 확인한다. 남아있다면 위에서 부터 순서대로 후위 표기법 변수 뒤에 붙인다.
> >
> > 4. stack까지 비었다면 후위 표기법은 완성이다.
>
> 위와 같은 진행방식을 거쳐 후위 표기법을 만드니 바로 정답을 받았다!
>
> 흑흑 자료구조 책을 본 것이 이렇게 큰 도움이 되다니 정말 감개무량하다... 조금씩 잊혀져 가면 다시 복습도 하고 그래야겠다!
