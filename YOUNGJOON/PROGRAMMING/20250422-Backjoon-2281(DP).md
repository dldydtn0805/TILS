# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int N, M;
vector<long long> DP, numbers;

void set_DP(int depth, long long num)
{
    if (depth == N-1) {
        DP[depth] = 0;
        return;
    }
    
    int tmp = -1;
    for (int i=depth; i<N; ++i) {
        tmp += numbers[i] + 1;
        if (tmp > M) break;
        
        if (i != N-1) {
            long long tmp_power = DP[i+1] + (M - tmp) * (M - tmp);
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << tmp_power << "가 계산값으로 나왔어 \n";
            DP[depth] = min(DP[depth], tmp_power);
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << DP[depth] << "가 최소값이 나왔어 \n";
        }
        else {
            DP[depth] = 0;
            // cout << "나는 " << depth << "이고 현재 " << i << "번째 계산을 해서 " << DP[depth] << "가 최소값이 나왔어 \n";
        }
    }
    
    return;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    DP.resize(N, 1000*1000*1000);
    numbers.resize(N, 0);
    long long num;
    vector<int> one_line;
    for (int i=0; i<N; ++i) {
        cin >> num;
        numbers[i] = num;
    }
    for (int i=N-1; i>=0; --i) {
        set_DP(i, numbers[i]);
    }

    cout << DP[0];
    
    return 0;
}

```

> ## 문제
>
> 사악한 라이토는 기발한 방법을 이용하여 L(애칭 섊)을 살해한 뒤 데스노트를 다시 손에 넣었다. 라이토는 이제 이 노트에 n명의 이름을 적어 넣으려고 한다. 이때 다음과 같은 조건을 만족시키면서 이름을 적어 넣으려 한다.
>
> 우선, 이름을 적어 넣을 때 이미 정해진 순서대로 n명의 이름을 적어 넣어야 한다. 이름을 적을 때도, 노트를 위에서 아래로, 같은 줄에서는 왼쪽 맨 끝에서 오른쪽으로 차례로 적는다고 하자. 또한 이름을 적을 때 각 사람의 이름 사이에 빈 칸을 하나씩 두려고 한다. 한 줄을 적다가 그 줄의 끝에 한 사람의 이름이 다 들어가지 않고 잘리게 되면 반드시 새로운 줄에 이름을 써야 한다. 그렇지 않으면 이름이 중간에 잘려서 자칫하면 두 명의 사람이 죽게 된다. 이때, 각 줄의 끝에 사용하지 않고 남게 되는 칸의 수의 제곱의 합이 최소가 되도록 하려 한다. 이를 계산할 때 제일 마지막 줄은 앞으로 이름을 적을 기회가 있으므로 계산하지 않는다. 예를 들어 노트의 폭(너비)이 20인 다음의 경우를 보자.
>
> ![img](https://www.acmicpc.net/JudgeOnline/upload/201008/ddp.PNG)
>
> 각 사람의 이름의 길이가 차례로 7, 4, 2, 3, 2, 5, 1, 12, 7, 5, 6 인 경우이다. 위와 같이 적으면 차례로 1, 10, 0칸이 남아서 제곱의 합이 101이 된다. 반면에 아래의 경우에는 5, 6, 0칸이 남아서 제곱의 합이 61이 된다.
>
> ## 입력
> 
> 첫째 줄에 n(1 ≤ n ≤ 1,000), m(1 ≤ m ≤ 1,000)이 주어진다. m은 노트의 가로 칸의 개수(폭, 너비)이다. 다음 n개의 줄에는 각 사람의 이름의 길이가 노트에 적어야 할 순서대로 주어진다. 각 길이는 m을 넘지 않는 자연수이다.
> 
> ## 출력
> 
> 첫째 줄에 남게 되는 칸 수의 제곱의 합의 최솟값을 출력한다.
> 
> ## 해설
> 
> 처음 문제를 봤을때 그리디라고 생각했다. 처음 최대한 주어지는 순서대로 이름을 채워넣은 후 가장 공백이 큰 곳에 위 아래에서 하나를 가져와 최적의 조건에서 가져오면 그리디 하게 풀수 있지 않을까? 했는데
> 
> `최적의 조건`이 구상하기 어려웠다 문제에서 주어진 조건에서는 그냥 값을 가져와서 차이값이 가장 낮은 경우를 하면 되지 않을까? 했는데 우선 적으로 이걸 판단하기도 어려웠고 숫자는 맨앞 혹은 맨뒤만 가져 올 수 있기 때문에 어떤 한가지 방법으로 최적의 경우를 만들어 낼 수 있다는 보장이 없었다. 그래서 계속 고민하다가 알고리즘 분류를 봤는데  DP...? 가 나왔다. 보고나서도 감이 계속 안잡혀서 결국 블로그를 보고 접근법을 찾았다.
> 
> > 1. 주어지는 이름을 맨 뒤에서부터 써내려간다. 각 숫자를 썼을 때의 나타나는 최소의 경우를 기록할 1차원 DP를 선언한다.
> >
> > 2. 가장 맨 뒷줄에 이름을 쓴다. 맨 뒷줄은 공백을 판단하지 않으므로 0이다. 즉, DP[N-1] = 0이 된다.
> >
>> 3. 이후에는 가장 처음에 적을 이름까지 아래와 같은 경우를 계속해서 따져본다.
> >
>>    3-1. 현재 이름을 새로운 줄에 쓴다. 이는 `(M - 현재 이름의 크기)^2 + DP[현재 이름순서 - 1]`의 값을 갖는다.
> >
> >    - 새로운 줄에 이름을 쓰기 때문에 이전 이름에서 만든 최적의 경우에 쓰면 된다.
>>
> >    3-2. 현재 이름을 이전 이름과 같이 합쳐서 쓴다. 이는 `(M - 현재 합친 이름들의 크기)^2 +  DP[가장 마지막 이름순서 - 1]`의 값을 갖는다. 이를 모든 이름의 합이 M보다 작을때 까지 반복한다. 만약 모든 이름의 합이 M보다 크다면 이 이상으로 합칠 필요가 없으므로 더 이상 합치지 않는다.
>>
> >    - 만약 합친 이름이 마지막 줄에 해당하면 이 합은 0이 된다. (마지막 줄은 공백을 계산하지 않음)
>
> 위와 같은 방식으로 진행하면 현재이름 까지 최선의 방법을 사용했을 때의 합을 기록해 둘 수있고 DP[0]에 적힌 값이 모든 이름을 보았을 때 최적의 경우가 되는 것이다.
> 
> 이런 방법은 생각도 못했었는데 바텀업 방식이 오랜만인거같다... DP를 이용한 획기적인 방법을 알게 된 것 같다!

