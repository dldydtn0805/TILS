# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>

#define pll pair<int, int>

using namespace std;

int N, M;
pll S = {-1, -1}, E;
vector<vector<char> > board(101, vector<char>(101, ' '));
vector<pll> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

struct Compare
{
    bool operator()(const pair<int, pll>& a, const pair<int, pll>& b) {
        return a.first > b.first;
    }
};

int mirror_mirror()
{
    vector<vector<int> > visited(M, vector<int>(N, 99999999));
    visited[S.first][S.second] = 0;
    priority_queue<pair<int, pll>, vector<pair<int, pll> >, Compare> que;
    que.push({-1, {S.first, S.second}});
    
    while (!que.empty()) {
        int now_mirror = que.top().first;
        pll now = que.top().second;
        que.pop();
        
        if (visited[now.first][now.second] < now_mirror) continue;
        
        for (int i=0; i<4; ++i) {
            int nx = now.first;
            int ny = now.second;
            while (true) {
                nx += directions[i].first;
                ny += directions[i].second;
                if (0 <= nx && nx < M && 0 <= ny && ny < N && board[nx][ny] != '*') {
                    if (visited[nx][ny] > now_mirror + 1) {
                        visited[nx][ny] = now_mirror + 1;
                        que.push({now_mirror + 1, {nx, ny}});
                    }
                    else if (visited[nx][ny] == now_mirror + 1) continue;
                    else break;
                }
                else break;
            }
        }
    }
    
    return visited[E.first][E.second];
}


int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    
    for (int i=0; i<M; ++i) {
        for (int j=0; j<N; ++j) {
            cin >> board[i][j];
            if (board[i][j] == 'C') {
                if (S.first == -1) S = {i, j};
                else E = {i, j};
            }
        }
    }
    
    cout << mirror_mirror();

    return 0;
}
```

> ## 문제
>
> 크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 '`C`'로 표시되어 있는 칸이다.
>
> '`C`'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.
>
> 레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('`/`', '`\`')을 설치해서 방향을 90도 회전시킬 수 있다.
>
> 아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '`.`', 벽은 '`*`'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 '`C`'를 연결한 것이다.
>
> ```
> 7 . . . . . . .         7 . . . . . . .
> 6 . . . . . . C         6 . . . . . /-C
> 5 . . . . . . *         5 . . . . . | *
> 4 * * * * * . *         4 * * * * * | *
> 3 . . . . * . .         3 . . . . * | .
> 2 . . . . * . .         2 . . . . * | .
> 1 . C . . * . .         1 . C . . * | .
> 0 . . . . . . .         0 . \-------/ .
>   0 1 2 3 4 5 6           0 1 2 3 4 5 6
> ```
>
> ## 입력
>
> 첫째 줄에 W와 H가 주어진다. (1 ≤ W, H ≤ 100)
>
> 둘째 줄부터 H개의 줄에 지도가 주어진다. 지도의 각 문자가 의미하는 것은 다음과 같다.
>
> - `.`: 빈 칸
> - `*`: 벽
> - `C`: 레이저로 연결해야 하는 칸
>
> '`C`'는 항상 두 개이고, 레이저로 연결할 수 있는 입력만 주어진다.
>
> ## 출력
>
> 첫째 줄에 C를 연결하기 위해 설치해야 하는 거울 개수의 최솟값을 출력한다.
>
> ##  해설
>
> 처음 문제를 봤을 때 BFS를 떠올렸다.
>
> 두군데의 C 중 한곳을 시작점으로 잡고 네방향으로 BFS를 돌린다. 단, 방향이 틀어질 때마다 기록 횟수를 1 늘린다.
>
> 어차피 최소의 거울을 사용해야하니까 기록 횟수를 최소로 가지고 가면 문제가 풀릴 거라고 생각했다.
>
> > 1. 주어지는 입력을 받는다. 이때 연결해야하는 'C'의 위치 두 곳은 따로 기록한다.
> >
> > 2. 방문처리를 기록할 2차원 배열 visited를 선언 이때 초기화 값은 발생할 수 없을 만큼 큰 값으로한다.
> >
> > 3. 시작 지점의 방문기록을 0으로 한다. 이후, 가중치와 좌표값을 담을 우선순위 큐 que를 선언한다. 우선순위는 가중치가 낮을수록 우선순위를 갖는다.
> >
> > 4. 현재 시작 위치를 가중치 -1과 함께 que에 넣는다.
> >
> > 5. que가 빌때까지 반복한다.
> >
> >    > 1. 현재 위치에 기록된 가중치의 값이 현재 que에서 꺼낸 가중치의 값보다 작다면 continue 한다.
> >    > 2. 1에서 넘어왔다면 4방향으로 이동한다.
> >    >    - 정해진 방향으로 가능한한 끝까지 이동한다. 이동하면서 이동한 위치에 기록된 가중치가 현재 가중치 + 1 보다 크다면 이동을 멈춘다. (이 경우 기록된 가중치에서 파생되면 현재 가중치 + 1과 같거나 더 유리할 것이기 때문)
> >    >    - 이동한 위치에 기록된 가중치가 현재 가중치 + 1과 같다면 이동만 한다.
> >    >    - 이동한 위치에 기록된 가중치가 현재 가중치 + 1과 작다면 이동 후 현재 가중치 + 1을 현재 위치에 기록하고 que에 해당 값들을 push 한다.
> >
> > 6. 5번이 끝나면 도착 지점에 기록된 값을 확인하여 갱신되었다면 해당 값을, 방문 되지 못했다면 -1을 출력한다.
>
> 위와 같은 방식으로 풀었다.
>
> 문제를 풀 때 틀렸습니다를 여러번 받았는데 아래와 같은 이유 때문에 틀렸습니다를 받았다.
>
> 1. 초기 코드에서는 이동한 위치에 기록된 가중치가 현재 가중치 + 1과 같다면 이동을 멈췄었다.
>
>    - 위의 조건에서 이동을 멈춰버리면 아래와 같은 경우 손해를 본다.
>
>      ```
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 2 2 X
>      ? ? ? 2 ? ? 1
>      ? ? * 1 1 1 1
>      ```
>
>      위의 경우를 살펴보자 현재 X가 이동을 시작한 지점이다. 현재 X에서 왼쪽으로 계속가고 있었는데 4번째 열에 2가 기록되어있다. 만약 4번째 열에서 이동을 멈추어 버리면 뒤쪽에 있는 곳은 2로 체크될 수 있는데도 3으로 체크되어 버리고 만다.
>
>      ```
>      // 4번째 열에서 멈춰 버리게 되면 생기게 될 상황
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      3 3 3 2 2 2 X
>      ? ? ? 2 ? ? 1
>      ? ? * 1 1 1 1
>      ```
>
>      하지만 멈추지않고 그대로 진행한다면 2로 체크할 수 있다.
>
>      ```
>      // 4번째 열에서 멈추지 않으면 생기게 될 상황
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      ? ? ? 2 ? ? 1
>      2 2 2 2 2 2 X
>      ? ? ? 2 ? ? 1
>      ? ? * 1 1 1 1
>      ```
>
>      이렇기 때문에 같은 가중치를 만나면 기록은 하지않되, 진행은 계속되어야 했다.
>
> 2. 코드를 이상하게 적었다.
>
>    - 문제를 풀때 정신을 어디다가 두고 문제를 푼걸까... 아래와 같은 상황이 발생했다.
>
>      ```
>      // 혼돈의 시작점 x값과, 도착점 x값을 시작 좌표로 적기.
>      que.push({-1, {S.first, E.first}});
>      
>      // 환란의 도착점에 적힌값을 반환해야 하는데 미지의 위치의 값을 반환하기
>      return visited[S.first][E.second];
>      ```
>
>      정말 기가 막히게 이렇게 적었는데 예제가 돌아갔다 엄청난 우연이었다랄까.... 근데 진짜 말도 안되는 실수라고 생각한다.... 이렇게 심한 실수를 한 적은 없었던거 같은데 정신을 어디다가 두고 문제를 풀었을까... 제발 정신차리자 ㅠㅠㅠㅠ
>
> 위의 2가지 이슈를 해결하니 정답을 받을 수 있었다.... 흠... 요즘 코드를 너무 대충쓰나? 싶을정도로 N과 M을 헷갈린다거나, 부등호를 실수한다거나, 이런일들이 많다... 로직을 생각했으면 꼼꼼하게 주석처리를 하거나... 집중해서 코드를 작성하도록 하자 ㅠㅠ

