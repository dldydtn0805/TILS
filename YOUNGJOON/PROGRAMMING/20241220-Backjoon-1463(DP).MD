# 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

vector<int> dp(1000001, pow(2, 30));

int main()
{
    int N;
    cin >> N;

    dp[1] = 0;
    
    for (int i=2; i<=N; ++i) {
        dp[i] = min(dp[i-1] + 1, dp[i]);
        
        if (i % 2 == 0) {
            dp[i] = min(dp[i / 2] + 1, dp[i]);
        }
        
        if (i % 3 == 0) {
            dp[i] = min(dp[i / 3] + 1, dp[i]);
        }
    }
    
    cout << dp[N];
    
    return 0;
}

```



# 해설

> ## 문제
>
> 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
>
> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
>2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
> 
>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
> 
>## 입력
> 
>첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.
> 
>## 해설
> 
>1은 무조건 0이니까 2부터 N까지 진행한다. 자신의 값 n에서 dp[n-1]에 저장된 값에 + 1을 한값과 현재 dp[n]에 저장된 값 중 최소 값을 기록한다.
> 
>만약, n이 2로 나누어 떨어진다면 dp[n/2]에 저장된 값에 + 1을 한 값과 현재 dp[n]에 저장된 값 중 최소 값을 기록한다.
> 
>만약, n이 3으로 나누어 떨어진다면 dp[n/3]에 저장된 값에 +1을 한 값과 현재 dp[n]에 저장된 값 중 최소 값을 기록한다.
> 
>위의 3가지 연산을 각각 숫자마다 조건이 맞는 경우에 모두 진행하면 결국 일일이 해당 숫자에 대해 연산을 1까지 만들어볼 필요없이 바로바로 최소값을 알 수 있다!
