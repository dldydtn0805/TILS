# 코드

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>

using namespace std;

unordered_set<string> visited;
int result = 999999999;
queue<pair<string, int> > que;
vector<pair<int, int> > directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int lets_move()
{
    while (!que.empty()) {
        string now = que.front().first;
        int depth = que.front().second;
        que.pop();

        if (now == "123456780") {
            return depth;
        }
        else {
            int zero_idx;
            for (int i=0; i<9; ++i) {
                if (now[i] == '0') {
                    zero_idx = i;
                    break;
                }
            }
            // 현재 0의 string 상의 index 값을 2차원 배열 퍼즐 판의 인덱스 값으로 치환
            int x = zero_idx / 3;
            int y = zero_idx % 3;
            for (int i=0; i<4; ++i) {
                int nx = x + directions[i].first;
                int ny = y + directions[i].second;
                
                if (0 <= nx && nx < 3 && 0 <= ny && ny < 3) {
                    int new_idx = nx * 3 + ny;
                    string next = now;
                    swap(next[zero_idx], next[new_idx]);
                    if (visited.find(next) == visited.end()) {
                        visited.insert(next);
                        que.push({next, depth + 1});
                    }
                }
            }
        }
    }
    
    return -1;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    string start = "";
    string S;
    for (int i=0; i<3; ++i) {
        for (int j=0; j<3; ++j) {
            cin >> S;
            start += S;
        }
    }
    que.push({start, 0});
    
    cout << lets_move();
    
    return 0;
}

```



> ## 문제
>
> 3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.
>
> | 1    | 2    | 3    |
> | ---- | ---- | ---- |
> | 4    | 5    | 6    |
> | 7    | 8    |      |
>
> 어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다. 물론 표 바깥으로 나가는 경우는 불가능하다. 우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.
>
> | 1    |      | 3    |
> | ---- | ---- | ---- |
> | 4    | 2    | 5    |
> | 7    | 8    | 6    |
>
> | 1    | 2    | 3    |
> | ---- | ---- | ---- |
> | 4    |      | 5    |
> | 7    | 8    | 6    |
>
> | 1    | 2    | 3    |
> | ---- | ---- | ---- |
> | 4    | 5    |      |
> | 7    | 8    | 6    |
>
> | 1    | 2    | 3    |
> | ---- | ---- | ---- |
> | 4    | 5    | 6    |
> | 7    | 8    |      |
>
> 가장 윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.
>
> ## 입력
>
> 세 줄에 걸쳐서 표에 채워져 있는 아홉 개의 수가 주어진다. 한 줄에 세 개의 수가 주어지며, 빈 칸은 0으로 나타낸다.
>
> ## 출력
>
> 첫째 줄에 최소의 이동 횟수를 출력한다. 이동이 불가능한 경우 -1을 출력한다.
>
> ## 해설
>
> 이 문제는 처음에 모든 경우의 수를 파악해야 한다고 생각해서 재귀를 이용한 DFS로 진행하려고 했다.. 그러나 음.. 메모리 제한이 **32MB**라서 진행중에도 불가능할 거라고 생각했고 계속해서 코드를 짜는데도 안될것 같았다. 우선 문제에서 불가능한 경우에는 -1을 출력하라고 했기 때문에 방문했던 경우를 기록하여 해당 경우는 반복하지 않도록 하고 더이상 진행이 불가능할때 -1을 출력해야했다. 따라서 방문기록을 관리해야하는데... 3*3짜리 배열을 계속해서 적어서 관리를한다면...? 무조건 32MB는 초과할것이라고 생각했다...
>
> 계속해서 고민하다가 결국 해답을 찾지못해서 사람들의 코드를 참고했는데... 아주 신기한 방식으로 문제를 풀었다.
>
> 3*3배열을 string으로 "123456780" 과 같은 방식으로 관리해주는 것 이었다! 방법은 아래와 같다.
>
> > 0. 처음 입력받은 배열을 "123456780" 과 같은 방식의 string으로 받는다.
> >
> > 1. queue를 하나 선언해 현재 배열을 나타내는 string과 반복 횟수인 depth를 같이 인자로 넣어준다.
> >
> > 2. queue가 전부 빌때까지 반복한다. 
> >
> >    2-1. queue의 가장 앞에 있는 값을 꺼낸다.
> >
> >    2-2. 만약 해당 값이 "123456780" 이라면 (종료조건 이라면) 현재의 depth값을 반환한다. (순서대로 이동하기때문에 반드시 가장 빠르게 만든것이 최솟값)
> >
> >    2-3. 만약 해당 값이 정답이 아니라면, 0이 있는 인덱스 값을 찾아 해당 값에서 상,하,좌,우로 이동시킨다.
> >
> >    > 이때, 0이 있는 인덱스 값은 0~8사이의 값이 된다. 이를 x, y의 값으로 바꿔 기존의 BFS처럼 2차원 배열에서의 움직임으로 바꾼다면 문제를 푸는것이 더 수월하다.
> >    >
> >    > ```c++
> >    > // x값은 몇번째 행인지를 나타내는 값으로 행당 3개씩의 숫자가 들어있으니 현재 0이 있는 인덱스 값에 3을 나눈 몫이 행의 번호가 된다.
> >    > int x = zero_idx / 3;
> >    > // y값은 몇번째 열인지를 나타내는 값으로 모든 행의 첫 시작은 3의 배수이니 3으로 나눈 나머지 값이 열의 번호가 된다.
> >    > int y = zero_idx % 3;
> >    > ```
> >    >
> >    > 위에서 구한 x, y 값을 이용해 4방향으로 이동시킨다.
> >
> >    2-4. 이동한 위치가 이전에도 발생한 적이 있는 경우라면 continue 하고, 발생한 적이 없다면, 해당 경우를 방문 기록하고, queue에 현재 경우를 나타내는 string 과 현재 depth에 +1을 한 값을 넣는다. 
> >
> > 3. 2-2의 경우가 발생하면 해당 값을, que가 전부 빌때까지 2-2의 경우가 발생하지 않았다면 -1을 출력한다.
>
> 배열을 string으로 관리해주어 방문처리를 하는 메모리를 상당히 최소화 시켰고 인덱스 문제 또한 생각해보면 간단한 방법으로 풀어내서 BFS를 진행할 수 있게 만들어주었다. 상당히 고효율적인 방법이라고 생각했다. 저번에는 비슷한 문제를 쌩으로 모두 배열째 저장해서 방문처리했었는데... 음... 이렇게 하는것이 메모리 관리에 상당히 도움이 될 것 같다! 직접 풀진못했지만... 상당히 좋은걸 배워가는것 같다!!
