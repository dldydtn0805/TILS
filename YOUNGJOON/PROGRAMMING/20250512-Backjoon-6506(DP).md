# 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N = -1, K = -1;

long long el_dorado(vector<int>& numbers)
{
    vector<vector<long long> > DP(N, vector<long long>(K + 1, 0));
    long long result = 0;
    DP[0][1] = 1;
    
    for (int i=1; i<N; ++i) {
        for (int j=0; j<i; ++j) {
            if (numbers[i] > numbers[j]) {
                for (int k=1; k<K; ++k) {
                    DP[i][k + 1] += DP[j][k];
                }
            }
        }
        
        DP[i][1] = 1;
    }
    
    for (int i=0; i<N; ++i) {
        result += DP[i][K];
    }
    
    return result;
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    while (true) {
        cin >> N >> K;
        if (N == 0 && K == 0) break;
        
        vector<int> numbers(N, 0);
        for (int i=0; i<N; ++i) {
            cin >> numbers[i];
        }
        
        cout << el_dorado(numbers) << "\n";
        
    }

    return 0;
}

```

> ## 문제
>
> 상근이는 라스베가스의 엘 도라도 카지노에 도착했다. 태어나서 카지노에 처음 가본 상근이는 휘황찬란한 카지노의 내부에 입을 다물 수 없었다. 그런 그의 눈길을 사로 잡는 게임이 하나있었다. 그 게임은 화면에 n개의 숫자가 화면에 뜨는 아주 단순해 보이는 게임이었다. 이 게임의 참가자는 컴퓨터가 만드는 수열에서 길이가 k인 증가하는 부분 수열의 개수를 예상해야 한다.
>
> 수열 a1, ..., an의 부분 수열은 1 ≤ i1 < i2 < ... < il ≤ n를 만족하는 ai1, ..., ail로 정의 한다. 부분 수열이 증가하려면 모든 1 < j ≤ l에 대해서, aij-1 < aij를 만족해야 한다.
>
> 상근이는 다른 사람이 작성한 프로그램을 믿지 않는다. 따라서, 기계에 표시된 정답 대신 자신이 직접 정답을 구해 보려고 한다. 기계의 화면에 표시된 숫자가 주어졌을 때, 길이가 k이면서 증가하는 부분 수열의 개수를 세는 프로그램을 작성하시오.
>
> ## 입력
>
> 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n과 k가 주어진다. (1 ≤ k ≤ n ≤ 100) 둘째 줄에는 컴퓨터가 만든 수열 ai가 주어진다. ai는 서로 중복되지 않는다. (-10000 ≤ ai ≤ 10000)
>
> 입력의 마지막 줄에는 0이 두 개 주어진다.
>
> ## 출력
>
> 각각의 테스트 케이스에 대해서, 길이가 k인 증가하는 부분 수열의 개수를 출력한다. 이 값은 64비트 정수 범위를 넘지 않는다.
>
> ## 해설
>
> 처음 문제를 봤을 때 가장 긴 증가하는 부분 수열을 이용해볼까 했으나 길이만 구할 수 있을뿐 개수를 구하는 것은 유리하지 않다고 판단하여 계속 고민해보니 DP를 이용해서 풀면 되겠다고 생각했다.
>
> > 1. 주어진 숫자의 수 * 최대 길이 크기의 2차원 배열 DP를 선언한다.
>>
> >    해당 배열은 각 숫자가 해당 길이의 끝 수로 들어갔을때의 개수를 나타낸다.
>>
> > 2. 맨 앞의 값은 반드시 1의 길이만 가질 수 있으므로 이를 기록한다.
>>
> > 3. 앞에서 두 번째 수부터 끝까지 순회하며 반복한다. 현재 위치 이전의 모든 수에 대하여 1 ~ K - 1 까지의 길이를 가지는 경우의 개수를 자신 위치에 해당 길이 + 1의 위치에 값을 더한다.
>>
> > 4. 3을 마치면 0~N-1까지 순회하여 해당 위치에 기록된 K길이를 가지는 경우의 값들을 모두 더하여 출력한다.
>
> 위와 같이 문제를 풀 수 있었다. 답을 제출했을때 출력 초과가 발생하는 경우가 있었는데 이는 result를 단순히 선언만하고 값을 할당하지않아서 더미데이터가 들어가 너무 이상한 값이 출력된 것 같다.
>
> result = 0으로 작성하니 정답을 바로 받을 수 있었다. 이런 실수는 꼭 주의하자 ㅠㅠ
