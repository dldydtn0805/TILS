# 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N;
vector<int> weights;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N;
    int num;
    bool can_start = false;
    
    for (int i=0; i<N; ++i) {
        cin >> num;
        weights.push_back(num);
        if (num == 1) {
            can_start = true;
        }
    }
    
    sort(weights.begin(), weights.end());
    
    int start = 1;
    for (int i=0; i<N; ++i) {
        if (start < weights[i]) {
            break;
        }243
        else {
            start += weights[i];
        }
    }
    
    cout << start;

    return 0;
}

```



> ## 문제
>
> 하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.
>
> ![img](https://upload.acmicpc.net/7d2a2428-a1b0-47f5-9f53-fecd714d1b1b/-/preview/)
>
> 무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다. 
>
> ## 입력
>
> 첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.
>
> ## 해설
>
> 처음 문제를 봤을때 예전에 풀었던 동전 문제가 떠올랐다 주어진 동전을 사용해서 주어진 값을 만드는 경우의 수를 구하는 것이었는데 이와 같은 방식으로 진행하되, 만들지 못하는 경우를 찾으면 된다고 생각했다.
>
> 주어지는 추들을 오름차순으로 정렬한 후, DP를 이용하여 모든 경우의 수를 만들고, 1부터 시작하여 중간에 비는 숫자를 찾으려 했다.
>
> 그러나 시간 초과가 났다.
>
> 그래서 우선순위 큐를 이용하여 작은 값부터 꺼내면 만들 수 있는 경우의 수가 최대 100만개 정도밖에 되지 않아서 이걸 살펴보면 금방 찾을 수 있다고 생각했으나 메모리 초과가 났다.
>
> 으아... 그래서 결국 알고리즘 분류를 봤는데 정렬 및 그리디 였다.
>
> 근데 딱히 봐도 떠오르는 방법이 없었다... 결국 위의 방법에서 조금 해보다가 다른 사람의 코드를 봤다.
>
> 아주 간단한 방식이 었는데 예시를 들어보자
>
> > - 추가 1이 있다 이 추는 1의 숫자를 만들 수 있다. {1}
> > - 이후 추가 2가 주어진이 이 추는 1이 만든 1 + 2와 본인 2를 만들 수 있다 {1, 2, 3}
> > - 만약 추가 5가 주어졌다고 해보자 그렇다면 5는 {5(본인) ,6, 7, 8}을 만들 수 있다. 이때 4를 만들지 못했으므로 답은 4가된다.
>
> 이 논리만 보고 내가 직접 구현해보려고 했으나 vector에 저장하거나 set나 map에 저장하면 정렬 및 중복의 문제 때문에 계속해서 메모리초과에 걸릴것 같았다.
>
> 결국 코드까지 보았는데 로직은 다음과 같았다.
>
> > 1. 시작(start)은 반드시 1부터 시작한다.
> > 2. 오름차순으로 정렬된 추들을 순서대로 순회한다. 현재 추가 시작 보다 크다면 실패하고. 작거나 같으면 현재 시작 값에 해당 추의 무게를 더한다 이 값이 현재 만들 수 있는 가장 큰 무게 + 1이 된다.
> > 3. 2번의 로직이 끝나면 현재 저장된 start를 하여 출력한다.
>
> 이를 위의 예시에 적용시키면
>
> > 1. 첫번째 추 1은 시작과 같으므로 1을 더한다. (start = 2);
> > 2. 두번째 추 2는 start 와 같으므로 2를 더한다 (start = 4)
> > 3. 세번째 추 5는 start보다 크므로 break 한다. (start = 4)
> > 4. 4를 만들지 못하므로 start를 출력한다. 
>
> 상당히 획기적이었다 start를 1로 두고 시작하면 무게 추 1짜리를 못걸러낼 줄 알았는데 start가 가능한 무게 +1인 상태이기 때문에 문제가 없었다.
>
> 그리고 모든 값들이 순서대로 만들어져야 하기 때문에 가능한 문제였던것 같다...
>
> 하 오랜만에 상당한 아이디어 문제였는데 결국 지고 말았다... 그리디 연습도 좀 필요하겠다... 
