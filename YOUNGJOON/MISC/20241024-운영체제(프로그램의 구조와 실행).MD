> 이 게시글은 반효경 교수님의 운영체제와 정보 기술의 원리 책을 보고 작성한 게시글 입니다.

# 1. 프로그램의 구조와 인터럽트

## 프로그램의 주소 영역

> 프로그램의 주소 영역은 크게 3가지로 구분할 수 있다.

1. 코드(code) 영역
   - 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령(machine instruction) 형태로 변환되어 저장되는 부분
2. 데이터(data) 영역
   - 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분
3. 스택(stack) 영역
   - 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간
     - 메인 함수에서 서브 함수를 호출하여 해당 함수를 수행하고 다시 메인 함수로 돌아왔을 때 어느 부분에서 부터 계속 진행해야하는 지를 기록하는 것

## 인터럽트의 동작 원리

> 함수호출의 원리와 상당히 비슷하다.

- A라는 프로그램이 실행 중에 인터럽트가 발생하면 CPU는 운영체제에게 제어권이 넘어가 운영체제

   

  커널

  안에 있는

   

  인터럽트 처리루틴

  을 따라 인터럽트를 처리하고 다시 돌아와서 A를 진행중이던 작업부터 다시 실행하게된다.

  - 이 때, **함수는 메모리의 스택 영역에 복귀할 주소를 저장**하는 반면, **인터럽트** 때문에 작업을 멈춘 부분으로 돌아가기 위한 **CPU의 주소는 운영체제가 관리하는 프로세스 제어블록에 저장**된다.

# 2. 컴퓨터 시스템의 작동 개요

> CPU는 컴퓨터의 두뇌라고 불리지만, 어떤 작업을 수행해야 하는지는 스스로 알지 못한다. CPU는 그저 매 시점 마다 특정 메모리 주소에 존재하는 명령을 하나씩 읽어 수행할 뿐이다.

## 프로그램 카운터(Program Counter: PC)

> CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터

- CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.
- 일반적으로 조건문이나 반복문, 함수호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 항상 바로 다음 명령을 가리키게 되어 코드의 순차적 수행이 이루어진다.
  - 통상적으로는 명령들은 순차적으로 수행되나, 함수 호출 등으로 점프해 바로 다음 주소가 아닌 명령을 수행할 수도 있다.

## 입출력 장치의 CPU와 메모리

> 컴퓨터에서 이루어지는 작업이 모두 CPU에서 이루어지는 것은 아니다. **컴퓨터 외부장치(입출력 장치)는 자신만의 CPU와 메모리**를 가지고 있고 그 것들과 협업하여 처리하는 것

### 입출력 장치의 CPU

> **입출력 컨트롤러**

### 입출력 장치의 메모리

> **로컬 버퍼**

## PC의 처리에 따른 상태

> 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 CPU가 수행하게 된다.

### 커널 모드

- **프로그램 카운터**가 메모리 주소 중 **운영체제가 존재하는 부분을 가리키고 있다면** CPU는 운영체제의 코드를 수행하게 되며 이 때, CPU가 **커널 모드에서 수행 중**이라고 한다.

### 사용자 모드

- **프로그램 카운터**가 **사용자 프로그램이 존재하는 메모리 위치를 가리키고 있다면** CPU가 **사용자 모드에서 수행 중**이라고 한다.

## CPU가 수행하는 명령

### 특권 명령

- **보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치에 접근하는 명령**이다.
- **항상 운영체제만이 수행할 수 있도록 제한**한다.

### 일반 명령

- 메모리에서 자료를 읽어와 **CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령**
- **모든 프로그램이 수행할 수 있는 명령**이다.

### 모드 비트

- **특권 명령**과 **일반 명령**을 **가르는 역할**을 한다.
- **모드 비트의 값에 따라 커널 모드, 사용자 모드로 바뀌며, 특권 명령은 오직 커널 모드에서만 수행이 가능**하다.

### 시스템 콜

- **사용자 프로그램이 특권 명령에 포함되는 작업(예: 디스크의 파일에 접근, 수행 결과를 화면에 출력)의 수행이 필요**할 때, **운영체제에게 특권명령의 대행을 요청**하는데 이 같은 서비스 요청을 **서비스 콜**이라 한다.
- 작업이 끝나면 연관된 입출력 장치의 **입출력 컨트롤러**에서 **CPU에 시스템 콜이 끝났다**는 것을 알려주기 위해 **인터럽트**를 발생시킨다.

## CPU가 주변장치를 파악하는 방법

- **CPU**는 **프로그램 카운터가 가리키는 메모리 위치의 작업만 수행**하기 때문에 **주변장치의 상태를 파악하지 못한다.**
- 이를 위해 **인터럽트 라인을 세팅**하고, **CPU는 매 작업이 끝날때마다** **인터럽트 라인을 확인**한다.

# 3. 프로그램의 실행

> 프로그램이 실행되고 있다는 건 다음 2가지의 의미를 가진다.
>
> 1. **디스크에 존재하던 실행파일이 메모리에 적재**된다.
> 2. **프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태**이다.

## 프로세스의 주소 공간(영역)

> 프로세스의 주소 공간은 **코드, 데이터, 스택** 등으로 구성된다.

- 각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 이와 같은 주소 공간을

   

  가상메모리 또는 논리적 메모리

  라고 부른다.

  - 실제로 **물리적 메모리의 주소**와 **독립적으로** 각 프로그램마다 **독자적인 주소 공간을 가지기 때문에** 지칭하는 용어이다.

- **운영체제** 또한 **하나의 프로그램**이므로 **운영체제 커널** 역시 **코드, 데이터, 스택의 주소 공간**을 가진다.

## 운영체제의 주소 공간

> **운영체제**는 **아랫단의 하드웨어 자원을 효율적으로 관리**하고, **윗단의 응용프로그램 및 사용자에게 편리한 서비스를 제공**하는 것이다.

### ① 운영체제 커널의 코드

- CPU 및 메모리 자원을 관리하기 위한 부분과, 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이룬다.

### ② 운영체제 커널의 데이터

- 각종 자원을 관리하기 위한 자료구조가 저장된다.
  - CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조뿐 아니라 현재 수행 중인 프로그램을 관리하기 위한 자료구조도 커널의 데이터 영역에 유지된다.
- 하드웨어와 소프트웨어를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 각각 유지하고 있다.

#### 프로세스

> **현재 수행 중인 프로그램을 프로세스(Process)라고 한다.**

- **커널의 데이터 영역**에는 **각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지**하기 위한 **자료구조인 PCB**를 두고 있다.

### ③ 운영체제 커널의 스택

- 일반적인 스택과 마찬가지로 함수호출 시의 복귀 주소를 저장하는 용도

  로 사용되지만, 일반적인 스택과 달리

   

  커널의 스택은 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리

  한다.

  - 프로세스가 함수를 호출할 때 **자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장**하지만, **프로세스가 특권명령을 수행하려고 커널에 정의된 시스템 콜을 호출**하고 **시스템 콜 내부에서 다른 함수를 호출**하는 경우 **그 복귀 주소는 커널 내의 주소**가 되어 사용자 프로그램의 **스택과는 별도의 저장공간이 필요**하게 되기 때문이다.
  - 또한, 커널은 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수에 접근할 수 있으므로, 일관성 유지를 위해 각각의 프로세스마다 별도의 스택을 두는 것이다.

- 프로세스의 스택에 저장하던 복귀주소는 시스템 콜로인해 CPU의 제어권이 운영체제로 넘어가면 해당 주소들을 PCB에 저장하게 된다.

- **커널 스택**은 **프로세스마다 별도**로 두고 있어, 커널 내에서 이루어지는 함수호출은 **직전에 CPU를 가지고 있던 프로세스의 커널 스택을 이용**한다.

# 4. 사용자 프로그램이 사용하는 함수

> 프로그램이 사용하는 함수는 크게 **사용자 정의함수, 라이브러리 함수, 커널 함수** 세 가지로 구분할 수 있다.

## 사용자 정의함수

> 프로그래머 본인이 직접 작성한 함수를 뜻한다.

- 프로그램의 코드 영역에 기계어 명령 형태로 존재
  - 즉, 프로그램이 실행될 때해당 프로세스의 주소 공간에 포함되며, 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용한다.

## 라이브러리 함수

> 프로그래머 본인이 직접 작성하진 않았지만 이미 누군가가 작성해놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.

- 프로그램의 코드 영역에 기계어 명령 형태로 존재
  - 즉, 프로그램이 실행될 때해당 프로세스의 주소 공간에 포함되며, 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용한다.

## 커널 함수

> 운영체제의 커널에 정의된 함수를 뜻한다.

- 종류로는 **시스템 콜 함수**와, 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 **인터럽트 처리함수**가 있다.
- 커널 함수는 사용자 프로그램의 주소 공간에 존재하는 것이 아니라, 운영체제 커널의 주소 공간에 정의한다.

# 5. 인터럽트

> CPU는 매번 **프로그램 카운터가 가리키는 메모리 주소의 명령을 수행**하고 다음 명령을 수행하기전에 **인터럽트 라인을 확인**한다.
> 이때 인터럽트 라인이 세팅이 되어있으면 해당 **인터럽트 처리 루틴으로 이동하여 처리**한다.

## 인터럽트 처리 중에 인터럽트 발생

> 원칙적으로는 **인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.**
> 인터럽트 처리 중에 다른 인터럽트를 처리하면 **데이터의 일관성이 유지되지 않는 문제가 발생할 수 있기 때문**이다.

- 인터럽트를 처리하는 중에 운영체제 커널에 정의된 데이터를 변경하고 있는데, 다른 인터럽트가 발생해 앞선 인터럽트에서 변경 중이던 데이터를 또다시 변경하게 되면 두 인터럽트에 의해 데이터가 원래 의도하지 않았던 결괏값으로 변경될 수 있기 때문이다.

- 하지만

   

  예외가 있을 필요가 있다.

  - 인터럽트 처리중에 시급하게 CPU를 사용해야하는 일이 생길 수 있기 때문

- 위의 문제를 해결하기 위해, 인터럽트에

   

  중요도

  를 정해 놓고 현재 진행중인 인터럽트보다

   

  더 중요도가 높은 인터럽트는 발생을 허락

  하는것이다.

  - **중요도가 더 높은 인터럽트가 발생**하면 현재 **진행중이던 인터럽트의 수행 지점을 저장**하고 중요도가 더 높은 인터럽트를 **먼저 처리**한다. 그 후, 처리가 끝나면 수행 지점으로 다시 돌아와 처음 인터럽트를 계속 진행한다.

# 6. 시스템 콜

> 대부분의 함수를 호출 할 때는 프로그램의 주소 공간 안에 있는 함수를 호출하지만, 시스템 콜은 자신의 주소 영역이 아닌, 커널이라는 다른 프로그램의 주소에 있는 함수를 호출하는 것이다.

- 일반 함수 호출은 자신의 스택 영역에 복귀 주소를 저장하고 함수를 진행하러 가는 반면, 시스템 콜은 프로그램으로 넘어가야 하는 것이므로 상이한 방법으로 처리한다.
  - 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 처리한다. (소프트웨어 인터럽트)
    - 소프트웨어가 발생시킨다는 점이 다를뿐 일반적인 하드웨어 인터럽트와 동일한 방법이다.

## 시스템 콜 진행 순서

1. 프로그램에서

    

   시스템 콜을 발생

   시킨다.

   - **프로그램이 인터럽트 라인에 인터럽트를 발생**시킨다. (=**소프트웨어 인터럽트** 중 하나)

2. **CPU**는 해당 **인터럽트를 확인**하고 **운영체제에 CPU 제어권을 넘겨주어 커널의 인터럽트 처리루틴을 이용**한다.

3. 인터럽트 처리루틴에 따라

    

   입출력 장치에 명령이 전달되고 수행

   한다.

    

   이 때, CPU는 다시 다른 프로세스로 이양

   한다.

   - **CPU의 처리속도**보다 **입출력 장치의 인터럽트 처리속도가 훨씬 느리기 때문**에 이를 기다리며 **CPU를 놀려두는건 비효율적**이다.
     이를 막기 위해 **인터럽트 요청이 끝나면 다시 다른 프로세스로 CPU를 할당**하게 된다.

4. CPU가 다른 작업을 수행하는 중,

    

   입출력 장치에서 작업이 끝나 CPU의 인터럽트 라인에 인터럽트를 발생

   시킨다.

   - 이때 발생하는 **인터럽트**는 **입출력 장치가 발생**시키는 것으로 **하드웨어 인터럽트**에 속한다.

5. CPU는 프로세스를 멈추고

    

   인터럽트를 확인

   해 다시

    

   운영체제에 CPU 제어권을 넘겨주고 커널의 인터럽트 처리루틴을 이용

   한다.

   - **로컬버퍼에 있는 데이터를 메모리로 복사하여 시스템 콜을 요청한 프로그램이 사용**할 수 있게 해줌

6. 처음 시스템 콜을 발생시킨 프로그램이 **해당 결과를 이용해 작업을 계속 수행**

# 7. 프로세스의 두 가지 실행 상태

## 사용자 모드에서의 실행 상태

> 프로세스가 CPU에서 실행 중일 때, 자신의 주소 공간에 정의된 코드를 실행하는 것

## 커널모드에서의 실행 상태

- 엄연히 따지면 프로세스가 시스템 콜을 이용해 커널에 **대행을 요청**한 것이므로, 아직까지 **프로세스가 계속해서 실행중인 상태로 간주**하기 때문에 커널모드에서 실행하고 있다고 하지않고, **"프로세스가 커널모드에서 실행 중"** 이라고 한다.