## 컴포넌트

- 리액트에서 가장 중요한 핵심 개념 중 한가지이다.
- 잠재적으로 재사용이 가능한 구성 요소이다.
- 혼합하여 전반적인 UI 구축한다.

### 컴포넌트 사용하는 이유

1. 재사용성

- HTML, CSS, JS 로직을 감싸는 것으로 관리하기 쉽도록 작게 분리하여 UI의 다른 위치에서도 사용할 수 있게 해준다.

2. 비슷한 코드는 함께 저장된다

- JS 코드를 변경하고 HTML을 수정하지 않을 경우 코드가 망가질 가능성이 있지만 컴포넌트로 작업하는 경우 함께 묶여있어 개발이 단순해진다.

3. 디자인과 개발 원칙을 따른다

- 관심사가 분리된다. 각 컴포넌트는 다른 기능이 있으므로 UI의 다른 부분을 처리한다.
- 프로젝트가 복잡해지면 패턴이 중요해지는데 담당하는 부분이 다른 개발자가 같은 프로젝트를 작업할때 과정이 단순해진다.

## JSX

- JSX는 Javascript Syntax Extension, 자바스크립트 문법 확장자이다. 개발자가 자바스크립트 파일 내에 HTML 마크업 코드를 작성하여 HTML 요소를 생성하게 해준다. 단, 브라우저에는 사용이 불가능하다

- 따라서 app.jsx의 코드는 브라우저에서 사용할 수 없다. 대신, 리액트 개발자가 작성하는 코드는 브라우저에 도달하기 전에 개발 서버에서 변환된다. 브라우저에서 사용가능한 코드로 변환되는 것이다. 

### JSX 컴포넌트

- 리액트 컴포넌트는 자바스크립트 함수와 같다고 볼 수 있다. 

- 리액트에서 컴포넌트로 인식되기 위해 두가지 규칙을 따라야한다.

1. 함수의 제목이 대문자로 시작해야한다

2. 함수에서 렌더링 가능한 값이 반환되어야 한다. 대체로 나중에 렌더 될 HTML 마크업이 반환된다

## 커스텀 컴포넌트

- 함수를 생성해서 부분 컴포넌트를 나눌 수 있다.
- 생성한 함수의 return 값에 HTML을 넣어주면 되는데 단, 여러 줄의 마크업 코드를 반환할 시 코드 시작과 끝을 괄호로 묶어 자바스크립트에게 이 코드가 함께 있다는 것을 알려주어야 한다.
- 일반적으로 자바스크립트 함수를 사용하듯 하지 않고, 리액트 라이브러리에서는 내부에서 실행시키므로 HTML 코드와 같이 컴포넌트 함수를 사용할 수 있다.
- 상위 컴포넌트 JSX 안에 커스텀 컴포넌트를 사용할 수 있다

```js
function Header() {
  return (
    <header>
      ...
    </header>
  )
}

function App() {
  return (
    <div>
      {/* <Header></Header> */} 
      <Header/> 
      ...
    </div>
  );
}
```

- 숏컷 형태로 작성할때는 맨 끝에 `/`가 반드시 필요하다 [마치 이미지 태그처럼]


### 컴포넌트와 파일 확장자

- JSX는 브라우저에서 지원되지 않는 확장자이다. 이것이 작동하는 이유는 리액트 프로젝트에서 지원하기 때문이다. 이 확장자는 빌드 프로세스에게 해당 파일이 JSX 코드를 포함하고 있다는 것을 알려준다

- 따라서 이 확장자를 처리하는 것은 빌드 프로세스 일 뿐이라는 것을 이해해야 한다. 

- 그렇기 때문에 .jsx 대신 .js만 사용하는 리액트 프로젝트도 찾을 수 있다 . 그리고 이 .js안에서 JSX 코드를 찾을 수 있다. 이것은 단순히 빌드 프로세스에 따라 JSX 구문을 사용할 때 어떤 확장자가 예상될지 결정된다.

- 또한 확장자를 가져오기 파일의 일부로서 요구하는 프로젝트와 이를 요구하지 않는 프로젝트도 찾을 수 있다. 마치 `import App from './App.jsx'`와 같이 사용할 수도 있으며 `import App from './App'`만 사용할 수도 있다.

- 이는 브라우저나 표준 자바스크립트와는 무관하며 단순히 선택한 프로젝트 설정의 코드 빌드 프로세스의 요구사항에 의존한다.

## 컴포넌트의 처리과정과 컴포넌트 트리 생성법

- 웹사이트에 방문하여 소스코드를 보면 소스코드에 헤더를 비롯한 웹사이트 내용이 없는 것을 볼 수 있다. 

- 약간의 메타 데이터와 자바스크립트 1개와 로딩된 자바스크립트 파일 하나가 있다. 우리가 집중할 것은 `로딩된 자바스크립트 파일`이다.

- 여기서 실행된 파일은 우리가 작성한 변형된 리액트 코드이다. 

- 결국 `웹사이트 이용자에게는 index.jsx가 포함된 index.html 파일이 제공`되는 것이다.

- 이 index.jsx파일은 App.jsx를 import 하는데, 결국 App component를 가져오는 것이다. 이 과정에서 IMPORT, EXPORT 모두 일반적인 자바스크립트 기능이다.

- `index.jsx에서는 <App/> 을 가져와서 사용`한다. 단, 여기서 JSX 코드는 없다. 함수로 전환되지 않는 것이다. 대신 App.jsx는 값으로 사용되서 다른 메소드의 인자로 쓰인다. 

- 리액트 개발자로서 우리는 `대부분의 경우 컴포넌트에 jsx 코드를 사용`하지만, index.jsx는 index.html 파일에 가장 먼저 로딩되는 파일로, `리액트 앱의 주요 입구로 작동하여 아주 중요한 예외적인 경우로 작동`한다. 

- 정확히는 `ReactDom`이라는 특별한 리액트 DOM 라이브러리로 인해 앱 컴포넌트가 결과적으로 렌더링 되는 것이다. 즉 앱 컴포넌트의 화면 출력을 담당한다. `render` 메서드는 `<App />`이라는 JSX 값을 인자로 받아 화면에 출력하는데 이는 `ReactDOM.createRoot(endPoint).render(<App/>);` 순서로 호출된다. 여기서 `endPoint`는 `index.html`의 `root`라는 이름을 가진 div이다. 즉 리액트 프로젝트가 모든 컴포넌트들[app components와 모든 nested components]을 root에 삽입한다. 

- 따라서 브라우저 소스코드를 보면 추가적인 HTML 요소가 포함되어 있게 된다. 화면에 보이는 `모든 요소가 root div에 모두 추가`되어 있다.

- 모든 요소들은 트리 형태로 제공되는데 root component는 app component이며 header와 같이 자식 컴포넌트를 다수 가지고 있을 수 있다. 이런 형태로 컴포넌트의 계층구조가 설립된다. 이는 `컴포넌트 트리`라 불리는 컴포넌트 구조물이 리액트를 통해 화면으로 렌더링 되는 것이다. 

- 여기서 이해해야할 지점은 커스텀 컴포넌트는 실제로 렌더링 된 DOM에 나타나지 않고 기본 HTML 요소만 있다는 것이다. 즉 `<Header />`라는 컴포넌트와 `<App />` 컴포넌트는 보이지 않는다. 즉 이 컴포넌트 트리는 리액트가 분석만한다. 리액트는 모든 컴포넌트에서 나온 JSX를 결합하여 전반적인 `DOM`을 생성한다. 즉 화면에 보이는 요소를 만든다. 

- 그렇기 때문에 리액트 개발자는 감사하게도 각자 개별적인 요소들인 컴포넌트로 작업할 수 있는 것이다.

- 여기서 우리는 왜 컴포넌트 이름이 대문자로 시작해야하는 지 알수있는데, `div, image, header와 같은 내장 요소는 소문자`로 시작한다. 즉 리액트에게 내장 요소가 아니라고 알려주는 것이다. `충돌 가능성을 방지`하기도 하지만, 리액트의 내장 컴포넌트는 리액트에서 DOM 노드로서 렌더링된다. 반면 커스텀 컴포넌트는 리액트에서 함수로서 실행된다. 즉 내용을 훑어보기만 하고 반환된 값을 사용해 코드를 분석하고 시간이 지나면 내장 요소만 남게 되고 이것이 화면에 렌더링 되는 것이다. 