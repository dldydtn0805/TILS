# 비트 필드를 활용한 다이나믹 프로그래밍

다이나믹 프로그래밍은 복잡한 문제를 더 작고 관리 가능한 부분 문제로 나누어 해결하는 방식입니다. 이 방법은 문제의 중복 계산을 피함으로써 효율적인 문제 해결이 가능하게 합니다. 하지만, 많은 다이나믹 프로그래밍 문제는 상태 공간의 크기가 크기 때문에, 메모리 사용량이 문제가 될 수 있습니다. 여기서 비트 필드를 사용하면 상태를 효율적으로 표현하고 메모리 사용을 줄일 수 있습니다.

## 비트 필드란?

비트 필드는 데이터를 비트 단위로 표현하는 방법입니다. 각 비트는 0 또는 1의 값을 가질 수 있으며, 여러 상태나 플래그를 하나의 정수로 표현할 수 있습니다. 이는 메모리를 절약하고, 비트 연산을 통해 빠르게 데이터를 처리할 수 있는 장점이 있습니다.

## 비트 연산의 기초

비트 연산은 비트 단위의 연산을 수행합니다. 다음은 가장 자주 사용되는 비트 연산자들입니다:

* `&` (AND): 두 비트가 모두 1이면 1을 반환합니다. 예를 들어, 특정 비트가 설정되어 있는지 확인할 때 사용됩니다.

* `|` (OR): 두 비트 중 하나라도 1이면 1을 반환합니다. 비트를 설정하거나 여러 상태를 결합할 때 유용합니다.

* `^` (XOR): 두 비트가 서로 다르면 1을 반환합니다. 비트를 토글하거나 특정 상태를 변경할 때 사용됩니다.

* `~` (NOT): 비트를 반전합니다. 모든 비트를 반대 값으로 변경할 때 사용됩니다.

* `<<` (Left Shift): 지정된 비트 수만큼 왼쪽으로 이동시킵니다. 2의 거듭제곱 계산이나 비트 마스크 생성에 활용됩니다.

* `>>` (Right Shift): 지정된 비트 수만큼 오른쪽으로 이동시킵니다. 비트 값을 추출하거나 나눗셈 연산에 사용됩니다.

## 다이나믹 프로그래밍에서의 비트 필드 활용

비트 필드를 다이나믹 프로그래밍에 활용하는 방법은 다음과 같습니다:

### 1. 상태 정의

문제의 상태를 비트로 표현합니다. 예를 들어, n개의 원소를 가진 집합의 부분집합을 표현할 때, n비트의 정수를 사용하여 각 원소의 포함 여부를 나타낼 수 있습니다.

### 2. 상태 전이

비트 연산을 사용하여 상태를 전이시킵니다. 이는 메모리를 절약하고, 계산을 빠르게 수행할 수 있게 합니다. 예를 들어, i번째 비트를 1로 설정하려면 `state |= (1 << i)`를 사용할 수 있습니다.

### 3. 최적화

중복 계산을 방지하기 위해 계산된 결과를 저장하고 재사용합니다. 이를 메모이제이션(memoization)이라고 합니다. 비트 필드를 사용하면 상태를 정수 인덱스로 직접 사용할 수 있어 효율적인 메모이제이션이 가능합니다.

```ts
import * as readline from 'readline';

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
let idx = 0;
let inputLines = [];
const INF = Number.MAX_SAFE_INTEGER
const MOD = BigInt(1000000000)
rl.on('line', (line: string) => {
    inputLines.push(line);
}).on('close', () => {
    const [N] = inputLines[idx++].split(' ').map(Number)
    // N이 주어질 때, 길이가 N 이면서 0부터 9까지 숫자가 모두 등장하는 계단 수[인접한 모든 자리의 차이가 1인 수]가 총 몇개 있는가 ?
    // dp[등장한 계단의 상태의 비트 필드][인덱스][넘버] = 계단 수의 개수
    const M = 10
    let mask = 1 << M
    const dp = new Array(mask+1).fill(null).map(()=>
        new Array(N).fill(null).map(()=>
            new Array(M).fill(null).map(()=>BigInt(0))
    ))
    // console.log('0')
    for (let i = 1; i < M; i++) {
        dp[1<<i][0][i] = BigInt(1)
    }

    for (let i = 0; i < mask; i++) {
        for (let j = 0; j < N-1; j++) {
            for (let k = 0 ; k < M; k ++) {
                // 계단 수 만들기
                if (k+1 < M) {
                    dp[i | (1 << (k+1))][j+1][k+1] += dp[i][j][k]
                }
                if (k-1 >= 0) {
                    dp[i | 1 << (k-1)][j+1][k-1] += dp[i][j][k]
                }
            }
        }
    }
    console.log((dp[mask-1][N-1].reduce((A,B)=>A+B)%MOD).toString())

})


/*
10
* */
```