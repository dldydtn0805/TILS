## 문제

https://www.acmicpc.net/problem/11066

## 해설

입력은 T개의 테스트 데이터로 이루어져있다.

각 데이터는 두개의 행으로 주어지는데, 첫행은 소설을 구성하는 장의 수를 나타내는 3 <= K <= 500이 주어진다.

두번째 행에는 1장부터 K 장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다.

파일의 크기는 10^4를 초과하지 않는다.

소설의 모든 장을 쓰고 나서 각 장이 쓰여진 파일을 합쳐서 한개의 파일을 만든다.

이 과정에서 두개의 파일을 합쳐서 하나의 임시파일을 만들고,

임시 파일이나 원래의 파일을 계속 2개씩 합쳐서 소설의 여러장들이 연속이 되도록 합쳐가고,

최종적으로 하나의 파일을 합친다.

두개의 파일을 합칠때 필요한 비용(시간 등)이 두 파일 크기의 합이라 할떄, 최종 비용의 합은 ?

각 테스트 데이터마다 모등 장을 합치는데 필요한 최소비용을 출력한다

C1, C2, C3, C4가 연속적인 네개의 장을 수록하는 파일이고, 각각 40, 30, 30, 50이라 할때,

먼저 C2, C3를 합쳐 X1을 만든다. 이때 비용 60이 필요하다.

그리고 C1, X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다.

최종적으로 X2, C4를 합쳐 최종 파일을 만들면 150이 필요하다.

따라서 최종 한 파일을 만드는데 필요한 비용의 합은 310이다.

이는 60 + 100 + 150 = 310인 것이다.

이것은 다시 말하면 (30+30) + (30+30)+40 + ((30+30)+40+50)인 것이다.

따라서 이건 현재 i 인덱스에서 j 인덱스까지 연결했을때, 최소 연결 비용인 것이다.

그렇지만 연결하는 과정에서 2개의 파일씩만 연결할 수 있음을 기억해야한다.

그렇게 때문에, dp[i][j] = dp[i][i+k] + dp[i+k][j]이다.

한편 C1 + C2 = Y1, C3 + C4 = Y2, Y1 + Y2 =300이다.

최소비용을 계산하라.

주요 규칙은 다음과 같다.

1. 항상 두개의 파일만 합칠 수 있다.

2. 두 파일을 합치는 비용은 두 파일 크기의 합이다.

3. 파일은 연속적으로 합쳐야한다.

이 문제는 다이나믹 프로그래밍으로 해결할 수 있다.

dp[i][j]는 i번 파일부터 j번 파일까지 합치는 최소비용을 저장한다.

이를 위해 가능한 모든 분할지점 k를 시도해야한다.

예컨대 1에서 4까지 파일을 합치는 방법은

(1) + (2,3,4)
(1,2) + (3,4)
(1,2,3) + (4)

이중에 가장 비용이 적은 방법을 선택하면 된다.

점화식은 다음과 같다.

dp[i][j] = min(dp[i][k] + dp[k+1][j] + sum(i~j))

여기서 핵심은 누적합 배열을 통해 해결할 수 있다는 것이다.

1. 기본 값 설정

- 하나의 파일만 있는 경우는 이미 합쳐져있으므로 비용이 0이다.

- 누적합 배열을 만들어 i부터 j까지 파일 크기 합을 빠르게 계산한다.

2. 작은 구간부터 계산

- 파일을 2개씩 합치는것부터 시작해서 점점 많은 파일을 합치는 경우로 확장한다.

    - [1, 2], [2, 3], [3, 4] ...
    - [1, 3], [2, 4], ...
    - [1, K] (모든 파일 합치기)

3. 각 구간마다 최적의 분할 지점 찾기

- 구간 [i, j]에 대해 모든 분할 지점 k를 시도해보고, 가장 비용이 적은 k를 선택한다.

4. 누적합 배열을 사용한 비용 계산 원리

- 파일 병합 문제에서 두 파일 그룹을 합치는 비용은, 두 그룹 파일 크기의 총합이다.

`int cost = dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]`

- dp[i][k] : i부터 k까지 파일 그룹을 합치는 최소 비용
- dp[k+1][j] : k+1부터 j까지 파일 그룹을 합치는 최소 비용
- sum[j] - sum[i-1] : i부터 j까지 모든 파일 크기의 합

이번 문제도 나에게 너무 어려운 다이나믹 프로그래밍 문제였다.

처음에 분할정복으로 시도하다가 절대 불가능함을 알고, 다이나믹 프로그래밍으로 전환했는데,

길이를 2부터 K까지 순차적으로 탐색하고, 각 길이마다 시작위치를 순서대로 탐색하고,

그렇게 나눈 길이와 시작 위치를 기준으로 k를 지정하여 잘라서 최저비용을 계산한다는 개념은,

결국 혼자서 생각해내지 못했다.

다이나믹 프로그래밍과 누적합 각각에 대해 잘 알고있지만,

두 개념을 합친 문제를 푼다는 것은, 어려웠다.

길이 결정 -> 시작위치 결정 -> 자를위치 결정 하는 삼중 반복문을 떠올리고

다이나믹 프로그래밍을 할 수 있도록, 조금 더 다양한 문제를 풀수 있도록 해야겠다.


## 입력
```
2
4
40 30 30 50
15
1 21 3 4 5 35 5 4 3 5 98 21 14 17 32
```

## 출력
```
300
864
```

```java
import java.io.*;
import java.util.*;

public class Main {
    static int INF = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        int T = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder("");
        for (int tc = 0 ; tc < T ; tc++) {
            int K = Integer.parseInt(br.readLine());
            StringTokenizer st = new StringTokenizer(br.readLine());
            int[] books = new int[K];
            for (int k = 0; k < K; k++) {
                books[k] = Integer.parseInt(st.nextToken());
            }
            sb.append(dynamicProgramming(books, K)[1][K]).append("\n");
        }
        bw.write(sb.toString().trim());
        bw.flush();
        bw.close();
        br.close();
    }

    public static int[][] dynamicProgramming (int[] books, int K) {
        // dp[i][j] i 부터 j 까지 연결했을때 최소 비용
        int[][] dp = new int[K+1][K+1];

        int[] sum = new int[K+1];
        for (int i = 1; i <= K; i++) {
            sum[i] = sum[i-1] + books[i-1];
        }
        for (int len = 2; len <= K; len++) { // 구간의 길이
            for (int i = 1; i <= K-len+1; i++) { // 시작 위치
                int j = i + len -1; // 끝위치
                dp[i][j] = INF;
                for (int k = i; k < j; k++) {
                    int cost = dp[i][k] + dp[k+1][j] + (sum[j]-sum[i-1]);
                    dp[i][j] = Math.min(dp[i][j], cost);
                }

            }
        }
        return dp;
    }
}
```