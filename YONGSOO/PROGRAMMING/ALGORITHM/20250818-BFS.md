## Source

https://www.acmicpc.net/problem/17142  

## Commentary
  
인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려 한다  
  
바이러스는 활성상태와 비활성상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성상태인 바이러스는 상하좌우로 인접한 모든 빈칸으로 동시에 복제되며, 1초가 걸린다.  
  
승원이는 연구소의 바이러스 M개를 활성상태로 변경하고자 한다  
  
연구소는 크기가 N X N 인 정사각형으로 나타낼 수 있으며, 정사각형은 1 X 1 크기의 정사각형으로 나누어져있다.  
  
연구소는 빈칸, 벽, 바이러스로 이루어져있으며, 벽은 칸 하나를 가득 차지한다.  
  
활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다  
  
---  
  
1. 비활성 바이러스를 M개 선택해서 모든 빈칸에 바이러스를 퍼트려야 한다.  
  
2. M개를 선택하는 경우의 수는, 전체 바이러스의 최대 개수가 10이므로, 상수시간이다. (완전탐색이 가능하다.)  
  
3. 비어있는 공간에 바이러스를 퍼트려야한다.  
  
4. 따라서 전체 바이러스 중 M개의 바이러스를 선택하는 모든 경우의 수를 너비우선탐색한다.  
  
5. 단, 비활성화된 바이러스를 활성화 시킬 필요는 없지만 비활성화된 바이러스를 지나갈 수는 있다는 것을 주의해야한다.  
  
## Input

```
7 3  
2 0 0 0 1 1 0  
0 0 1 0 1 2 0  
0 1 1 0 1 0 0  
0 1 0 0 0 0 0  
0 0 0 2 0 1 1  
0 1 0 0 0 0 0  
2 1 0 0 0 0 2  
```

## Output

```
4
```

## Source Code

```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    static int[][] directions = {{-1,0},{0,1},{1,0},{0,-1}};  
    static int[][] map;  
    static int N, M, T, ans;  
    static int[] combinations;  
    static LinkedList<int[]> virus;  
    static int INF = (int) 1e9;  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        N = Integer.parseInt(st.nextToken());  
        M = Integer.parseInt(st.nextToken());  
        ans = INF;  
        map = new int[N][N];  
        virus = new LinkedList<>();  
        for (int i = 0; i < N; i ++) {  
            st = new StringTokenizer(br.readLine());  
            for (int j = 0; j < N; j ++) {  
                map[i][j] = Integer.parseInt(st.nextToken());  
                if (map[i][j] == 2) {  
                    virus.add(new int[]{i,j});  
                }  
            }  
        }  
        T = virus.size();  
        combinations = new int[M];  
        comb(0, 0);  
        System.out.println(ans == INF ? -1 : ans);  
    }  
  
    private static void bfs () {  
        LinkedList<int[]> queue = new LinkedList<>();  
        int[][] visited = new int[N][N];  
        for (int i = 0; i < M; i ++) {  
            int num = combinations[i];  
            int[] cur = virus.get(num);  
            queue.add(new int[]{cur[0], cur[1]});  
            visited[cur[0]][cur[1]] = 1;  
        }  
        while (!queue.isEmpty()) {  
            int[] cur = queue.poll();  
            for (int[] dir : directions) {  
                int ni = cur[0] + dir[0];  
                int nj = cur[1] + dir[1];  
                if (0 <= ni && ni < N && 0 <= nj && nj < N) {  
                    if (map[ni][nj] != 1) {  
                        if (visited[ni][nj] == 0) {  
                            queue.add(new int[]{ni, nj});  
                            visited[ni][nj] = visited[cur[0]][cur[1]] + 1;  
                        }  
                    }  
                }  
            }  
        }  
        int curAns = 0;  
        for (int i = 0; i < N; i ++) {  
            for (int j = 0; j < N; j++) {  
                if (map[i][j] == 0) {  
                    if (visited[i][j] == 0) {  
                        return;  
                    }  
                    curAns = Math.max(curAns, visited[i][j]-1);  
                }  
            }  
        }  
        ans = Math.min(ans, curAns);  
    }  
  
    private static void comb (int depth, int idx) {  
        if (depth == M) {  
            bfs();  
            return;  
        }  
        for (int i = idx; i < T; i ++) {  
            combinations[depth] = i;  
            comb(depth+1, i+1);  
        }  
    }  
}
```
