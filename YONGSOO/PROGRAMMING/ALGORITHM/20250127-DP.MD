# 경로 찾기

## 문제 설명
세준이는 크기가 \(N X M\)인 직사각형 도시에 살고 있다.  
- 세준이의 집은 \((1, 1)\)이고, 학원은 \((N, M)\)이다.  
- 오락실이 \(C\)개 있다.  

세준이는 현재 위치가 \((r, c)\)일 때, 아래 두 가지 방향으로만 이동할 수 있다.
1. 아래로 이동: \((r+1, c)\)
2. 오른쪽으로 이동: \((r, c+1)\)

### 오락실 방문 규칙
1. 오락실 번호는 반드시 **오름차순**으로 방문해야 한다.  
   - 예: 2번 오락실을 방문하려면, 그 전에 1번 오락실을 방문했어야 한다.
   - 순서를 어기면 안 된다.
2. 방문하지 않아도 되는 경우도 있다.

세준이는 **오락실을 0개 방문했을 때부터 \(C\)개 방문했을 때까지** 학원에 도착하는 경로의 경우의 수를 알고 싶다.

---

## 입력
### 첫 줄
- \(N, M, C\) (자연수, \(N, M <= 50\), \(C <= 50\))  
도시의 크기와 오락실의 개수가 주어진다.

### 둘째 줄부터 \(C\)개의 줄
- 각 줄에 오락실의 위치 \(r, c\)가 차례로 주어진다.  
  - 오락실의 위치는 중복되지 않으며, \((1, 1)\) 또는 \((N, M)\)일 수도 있다.

---

## 출력
- \(0\)개 방문했을 때부터 \(C\)개 방문했을 때까지의 경로의 경우의 수를 공백으로 구분해 출력한다.
- 출력값은 \(1,000,007\)로 나눈 나머지를 출력한다.

---

## 예제

### 입력 1
```
3 3 2
2 2
3 2
```

### 출력 1
```
1 3 2
```

**경로 설명**  
- \(0개\): (1,1) → (1,2) → (1,3) → (2,3) → (3,3)  
- \(1개\):  
  1. (1,1) → (2,1) → (2,2) → (2,3) → (3,3)  
  2. (1,1) → (1,2) → (2,2) → (2,3) → (3,3)  
  3. (1,1) → (2,1) → (3,1) → (3,2) → (3,3)  
- \(2개\):  
  1. (1,1) → (2,1) → (2,2) → (3,2) → (3,3)  
  2. (1,1) → (1,2) → (2,2) → (3,2) → (3,3)  

---

### 입력 2
```
6 4 2
5 3
3 2
```

### 출력 2
```
14 24 0
```

---

### 입력 3
```
5 5 3
1 3
2 4
3 5
```

### 출력 3
```
42 14 10 4
```

---

### 입력 4
```
50 50 2
50 50
1 1
```

### 출력 4
```
0 0 0
```

---

```js
// https://www.acmicpc.net/problem/1495
/* 해설

DP 테이블을 다음과 같이 구성한다.

dp[i][j][k][l] = i행 j열 위치에서 k번 오락실까지 l개의 오락실을 방문했을때의 경로의 수이다.

현재 위치가 오락실인지 여부에 따라 DP를 갱신하는 경우가 달라진다.

오락실이 아니라면, 이전 위치의 경로 개수를 더한다.

오락실이라면, 이전 위치의 0~k-1 오락실 경로 개수를 더한다.
* */

/*입력
3 3 2
2 2
3 2
* */

/*출력
1 3 2
* */

let fs = require('fs');
let input = fs.readFileSync(process.platform === "linux" ? "/dev/stdin" : "input.txt"
).toString().trim().split('\n');

const INF = Number.MAX_SAFE_INTEGER
const directions = [
    [-1,0],[0,1],[1,0],[0,-1]
]
const MOD = 1000007
const solve = (inputLines) => {
    let idx = 0
    const [N, M, C] = inputLines[idx++].split(' ').map(Number)
    const arcade = new Array(N+1).fill(null).map(()=>
        new Array(M+1).fill(null).map(()=>0)
    )
    for (let i = 1; i < C+1; i ++) {
        const [x, y] = inputLines[idx++].split(' ').map(Number)
        arcade[x][y] = i
    }

    const dp = new Array(N+1).fill(null).map(()=>
        new Array(M+1).fill(null).map(()=>
            new Array(C+1).fill(null).map(()=>
                new Array(C+1).fill(null).map(()=>0)
            )
        )
    )

    if (arcade[1][1] !== 0) {
        dp[1][1][arcade[1][1]][1] = 1
    } else {
        dp[1][1][0][0] = 1
    }
    for (let i = 1; i < N+1; i ++) {
        for (let j = 1; j < M+1; j ++) {
            if (arcade[i][j] !== 0) {
                const K = arcade[i][j]
                for (let k = 0; k < K; k++) {
                    for (let l = 1; l < C+1; l++) {
                        dp[i][j][K][l] += (dp[i-1][j][k][l-1] + dp[i][j-1][k][l-1])
                    }
                }
                for (let l = 1; l < C+1; l ++) {
                    dp[i][j][K][l] %= MOD
                }
            } else {
                for (let k = 0; k < C+1; k++) {
                    for (let l = 0; l < C+1; l++) {
                        dp[i][j][k][l] += (dp[i-1][j][k][l] + dp[i][j-1][k][l])%MOD
                    }
                }
            }
        }
    }
    let ans = new Array(C+1).fill(null).map(()=>0)
    for (let i = 0; i < C+1; i++) {
        for (let j = 0; j < C+1; j++) {
            ans[j] += dp[N][M][i][j]
        }
    }
    for (let i = 0; i < C+1; i++) {
        ans[i] %= MOD
    }
    return ans.join(' ')

}


console.log(solve(input))

```