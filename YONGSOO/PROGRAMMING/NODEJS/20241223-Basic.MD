## CREATE NODE JS SERVER

- 빈 폴더에 새 파일을 생성한다. NODEJS 어플리케이션을 구성하는 루트 파일이기 때문에 `server.js` 혹은 `app.js`로 이름을 짓는다.

- 서버 생성을 위해서는 몇가지 코드를 불러와야 하는데 브라우저나 NODE의 JS는 파일에 아무것도 불러오지 않고도 전역에서 쓸수있는 기능과 객체가 많기는 하지만 대부분의 기능은 기본으로 사용 가능하지 않다. 글로벌 네임스페이스의 저장된 키워드나 이름을 어지럽히지 않고 각 파일이 토대로 하는 기능을 확실하게 나타내기 위해서이다. NODE에는 몇가지 코어 모듈이 있다. [HTTP / HTTPS / FS / PATH / OS]

- PATH : 윈도우, 맥, 리눅스가 다른 형식을 사용하기 때문에, 파일 시스템에 있는 파일에 대한 경로를 구축하는 용도이다. 

- OS : 운영체제 관련 도움을 준다.

- HTTP / HTTPS : 서버를 생성하거나, HTTP 요청 및 응답 작업에 아주 유용하다. 특히 HTTP는 서버를 출시하거나 요청을 보내는 것과 같은 작업에도 도움을 준다. 즉 노드 앱이 다른 서버로 요청을 보내 여러 서버간에 소통할 수 있다. 예를들어 GOOGLE MAPS API에 좌표를 달라는 요청을해서 주소를 받는다.

- HTTPS는 모든 전송 데이터가 암호화되는 SSL 암호화 서버를 출시할 때 도움이 된다. 


### HTTP 모듈

- 기본으로 전역에서 사용가능하지 않으므로 파일에서 해당 기능을 사용하도록 기능을 불러와야한다. 

- 파일을 불러오는 방법인 `require 키워드`는 `다른 파일로의 경로나 자바스크립트 파일을 불러올 수 있다`[.와 /를 사용해서]. `파일에 대한 경로를 모른다 해도 http와 같은 코어 모듈`을 불러올 수 있다. 

`const http = require('http');`

- 경로를 생략하면 http라는 글로벌 모듈을 찾게되는데 이는 노드에 탑재된 모듈 중 하나이다. 

- 모듈에서 불러온 http 객체에는 다양한 메서드들이 있는데 그 중 `createServer` 메서드는 `서버를 생성`할때 반드시 필요하다. 이는 `requestListener 인자`가 필요한데, 이는 쉽게말해 들어오는 모든 요청을 실행하는 기능이다. 또다시 requestListener는 두개의 인수가 필요하다. `들어오는 메시지` 혹은 `응답 객체 유형`의 요청을 받는다. 정리하자면 노드가 자동으로 들어오는 `요청을 대변하는 객체를 제공`하고 해당 요청으로부터 데이터를 읽을 수 있게끔 하며 `요청을 보낸 사람에게 응답을 보낼 수 있는 응답 객체를 주는 것`이다. 

- 쉽게 말하면 첫번째 인수는 request에 대한 데이터, 두번째 인수는 response에 사용된다는 것만 기억하면 된다.

```js
function rqListener(req, res) {

}
http.createServer(rqListener)
```

- 이렇게 하면 들어오는 모든 요청에 따라 실행하라고 설정하게 된다. 이제 이 함수는 서버에 도달하는 모든 요청에 따라 실행되며 이는 createServer로 부터 시작된다.

- 혹은 익명 함수를 사용할 수도 있다. 서버에 요청이 들어올때마다 노드가 익명 함수를 실행한다. 이게 노드의 대표적인 `이벤트 드리븐 아키텍처`이다 [EDA]

```js
http.createServer(function(req, res) {
    
});
```

- 앞으로 이같은 설정이나 스니펫을 자주 사용할 것이다. 코드 스니펫은 노드에게 X가 일어나면 Y를 실행하라는 것이다. 즉 이 경우는 요청이 들어오면 이 함수를 실행하라 알려주는 것이다.

- 혹은 차세대 JS 문법으로 작성해본다면 다음과같다. 이를 createServer 콜백 함수라고 부른다. 서버에 요청이 들어올때마다 NODE가 호출하게 된다. 

```js
http.createServer((req, res) => {
    console.log(req)
});
```

- 내장된 터미널에서 파일을 실행할 수 있다. 터미널에 해당 폴더로 들어가 `node app.js`를 실행하면 아무일도 일어나지 않는다. `console.log`가 나오지 않는 이유는 서버에 요청을 보내지 않았기 때문인데, 사실상 서버가 어디있는지도 모르기 때문이다. 위에서 한가지 빠진 부분은 다음과 같다. 

```js
const server = http.createServer((req, res) => {
    console.log(req)
});
```

- 서버를 상수로 저장하고 `listen 메서드를 사용`한다. 이는 노드가 스크립트를 바로 종료하지 않고 계속 실행하면서 듣도록 한다. `listen에 입력할 수 있는 인수 여러 중에 첫번째는 듣고자 하는 포트`이다. 실무에서는 대개 포트 인자를 입력하지 않으며 기본적으로 포트 번호 80이 사용되지만 일단 다른 포트를 사용해보자. 호스트 이름도 지정해야하는데 기본적으로 실행중인 머신의 이름과 같다. 즉 로컬 머신의 호스트 이름은 기본적으로 localhost이다. 포트번호는 비교적 자유롭게 천번대 포트 번호면 대개 괜찮다.

```js
const http = require('http');

const server = http.createServer((req, res) => {
    console.log(req)
});

server.listen(3000)
```

- 이를 실행해보면 커서가 깜빡이는데, 파일의 실행이 아직 끝나지 않았기 때문이다. `루핑 프로세스를 시작해 요청을 계속해서 듣도록 설정했기 때문에 웹 서버가 계속 요청을 듣는것`이다. 새 브라우저 윈도우를 열어 `localhost:3000`을 입력하면 특정 html 문서를 반환하도록 설정하지 않았기 때문에 아무 일도 일어나지 않는다. 하지만 터미널로 돌아가보면 아주 긴 출력 결과가 나온다. console.log로 인해 콘솔에 요청 로그가 남은 것이다. 고작 3줄로 완벽하게 기능하는 웹 서버를 생성한 것이다. 