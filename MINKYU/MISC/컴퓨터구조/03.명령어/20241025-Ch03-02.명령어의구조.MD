# 컴퓨터 구조
## Ch03. 명령어
### 명령어의 구조
출처 : [강민철 - 개발자를 위한 컴퓨터공학 1 : 혼자 공부하는 컴퓨터구조 + 운영체제](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

### 1. 명령어의 구조
컴퓨터 속 명령어 : *무엇*을 대상으로 *어떤 일*을 수행하라!
- 무엇을 대상으로 : 데이터 관련
- 어떤 일을 수행하라 : 명령어 관련

명령어의 구조 : 연산 코드 + 오퍼랜드
- 연산 코드 필드에 연산 코드를 담는다
- 오퍼랜드 필드에 오퍼랜드를 담는다

#### 오퍼랜드
오퍼랜드(Operand) : 연산에 사용할 데이터(또는 데이터가 저장된 위치)
- 피연산자
- 오퍼랜드 필드(Operand Field)에 담길 수 있는 것들
    - 데이터
    - 메모리 주소
    - 레지스터 주소

N-주소 명령어(N-Address Instruction) : 오퍼랜드의 개수가 N개인 명령어
- 0-주소 명령어 ~ 다양함!

#### 연산 코드
연산 코드(Operation Code) : 명령어가 수행하려는 연산
- 연산자
- 4가지 유형이 존재

<연산 코드 영역에 담기는 연산 유형>
1. 데이터 전송
- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단에 위치한 데이터를 가져와라

2. 산술/논리 연산
- ADD / SUBTRACT / MULTIPLY / DIVDE : 사칙연산을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 1을 빼라
- AND / OR / NOT : AND 연산 / OR 연산 / NOT 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE - FALSE 값을 비교하라

3. 제어 흐름 변경
- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건을 만족하는 경우, JUMP를 실행하라
- HALT : 프로그램 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 JUMP를 실행하라
- RETURN : CALL을 호출했을 때 저장했던 주소로 돌아가라

4. 입출력 제어
- READ(INPUT) : 특정 입출력장치로부터 데이터를 읽어와라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

### 2. 주소 지정 방식
Q. 하나의 명령어가 N비트일 경우, 연산 코드 필드가 할당된 공간과 오퍼랜드 필드가 할당된 공간의 합은 반드시 N비트여야 하는가?

A. 정답! 만약 연산 코드 필드가 M비트일 경우, 오퍼랜드 필드는 (N-M)비트이다.
- 오퍼랜드 필드에 최대 공간을 할당하는 경우(1-주소 명령어), (N-M)비트, 즉 2^(N-M)개의 정보를 담을 수 있다.
- 데이터를 직접 할당 시, 실제로 2^(N-M)비트를 넘어가는 데이터는 담지 못한다!!!
- 이러한 한계 때문에, 오퍼랜드 필드에 실제 데이터를 담는 대신, 데이터가 저장된 주소(유효주소)를 담음으로서 효율적으로 사용 가능
    - 유효 주소(Effect Address) : 연산의 대상이 되는 데이터가 저장된 위치

주소 지정 방식(Addressing Mode) : 유효 주소를 찾는 방법
- 즉시 주소 지정 방식
- 직접 주소 지정 방식
- 간접 주소 지정 방식
- 레지스터 주소 지정 방식
- 레지스터 간접 주소 지정 방식

#### 즉시 주소 지정 방식
![즉시 주소 지정 방식](<../images/Ch03/즉시 주소 지정 방식.PNG>)
즉시 주소 지정 방식(Immediate Addressing Mode) : 오퍼랜드 필드에 연산에 필요한 데이터를 직접 명시하는 방식

장점
- 가장 간단한 형태의 주소 지정 방식(데이터를 직접 할당)

단점
- 표현할 수 있는 데이터의 크기에 한계 발생

#### 직접 주소 지정 방식
![직접 주소 지정 방식](<../images/Ch03/직접 주소 지정 방식.PNG>)
직접 주소 지정 방식(Direct Addressing Mode) : 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
- 데이터가 저장된 메모리 주소를 명시

장점
- 즉시 주소 지정 방식보다 표현 가능한 데이터 크기가 커짐

단점
- 여전히 유효 주소 표현 범위가 연산 코드 비트 수 만큼 감소

#### 간접 주소 지정 방식
![간접 주소 지정 방식](<../images/Ch03/간접 주소 지정 방식.PNG>)
간접 주소 지정 방식(Indirect Addressing Mode) : 오퍼랜드 필드에 유효 주소의 주소를 명시하는 방식
- 데이터가 저장된 메모리 주소가 저장된 주소를 명시

장점
- 직접 주소 지정 방식보다 표현 가능한 데이터 크기가 커짐

단점
- 두 번의 메모리 접근 필요 -> 상대적으로 느림
    - 오퍼랜드 필드에는 유효 주소의 주소가 명시되어 있다
    - 해당 주소를 통해 유효 주소가 적힌 메모리 주소로 접근
    - 접근한 주소를 통해 데이터가 저장된 메모리 주소로 접근

여기서 Quiz. 왜 메모리 접근 횟수가 많아질 수록 느려질까?
- CPU와의 물리적 거리 때문!!(메모리는 CPU 바깥에 존재 -> 가기 힘듬 ㅠ)

#### 레지스터 주소 지정 방식
![레지스터 주소 지정 방식](<../images/Ch03/레지스터 주소 지정 방식.PNG>)
레지스터 주소 지정 방식(Register Addressing Mode) : 오퍼랜드 필드에 연산에 사용할 데이터가 저장된 레지스터 주소를 직접 명시하는 방식
- 특정 레지스터에 연산에 사용하려는 데이터가 저장되어 있음
- 해당 레지스터 주소를 명시함으로써 데이터에 접근 가능

장점 
- 메모리 주소 접근 방식에 비해 빠름
    - 레지스터는 CPU 내부에 위치하기 때문

단점
- 직접 주소 지정 방식과 비슷한 형태 : 표현 가능한 레지스터 크기에 제한

#### 레지스터 간접 주소 지정 방식
![레지스터 간접 주소 지정 방식](<../images/Ch03/레지스터 간접 주소 지정 방식.PNG>)
레지스터 간접 주소 지정 방식(Register Indirect Addressing Mode) : 오퍼랜드 필드에 연산에 사용할 데이터를 저장한 메모리 주소를 저장한 레지스터 주소를 명시하는 방식
- 특정 메모리 주소에 연산에 사용하려는 데이터가 저장되어 있음
- 해당 메모리 주소를 저장한 레지스터 주소를 명시함으로써 데이터에 접근 가능

장점
- 기존 메모리에 두 번 접근해야 하는 간접 주소 지정 방식과 비슷한 형태지만, 메모리에 한 번만 접근해도 됨!
    - 간접 주소 지정 방식 : 메모리 -> 메모리 -> 데이터
    - 레지스터 간접 주소 지정 방식 : 레지스터 -> 메모리 -> 데이터

단점
- 어찌됐던, 메모리 접근 필요
- 큰 단점은 아닌듯?


