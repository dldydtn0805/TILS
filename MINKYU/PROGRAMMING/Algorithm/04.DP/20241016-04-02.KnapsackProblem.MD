# Algorithm
## 04. DP Algorithm
### Knapsack Problem

### 배낭 문제
배낭 문제 : 한 배낭에 담을 수 있는 무게의 최댓값이 정해져 있고, 일정 가치와 무게가 있는 짐들을 배낭에 넣을 때, 무게의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제
- 분할가능 배낭 문제(Fractional Knapsack Problem) : 담을 수 있는 물건이 나누어 질 경우
    - 그리디 알고리즘으로 해결 가능(가치가 높은 순으로 정렬 -> 배낭에 담은 후, 남은 부분을 물건을 쪼개어 넣기)
- 0-1 배낭 문제(0-1 Knapsack Problem) : 담을 수 있는 물건이 나누어 질 수 없을 경우
    - 물건의 수, 각 물건의 무게와 가치, 배낭의 최대 용량이 주어질 경우, DP를 활용해 해결
    - 점화식 : dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)
    - i번 물건의 무게가 w이고 가치가 v일 때, i번 물건을 넣을 수 있는 경우(w < j), 넣을 수 있는 최대 무게 j를 넘지 않았을 때의 최대 가치
    
#### 0-1 배낭 문제의 동작 원리
1. 물건의 수(N), 각 물건들의 무게(wi)와 가치(vi), 배낭의 최대 용량(W)가 주어진다
2. 물건을 i개 선택했을 때의 최대 무게가 j가 되는 경우의 최대 가치를 저장한다
- 물건을 선택하지 않는 경우, 최대 무게가 j가 되는 경우의 최대 가치는 이전과 같다
- 물건을 선택하는 경우, 최대 무게가 j가 되는 경우의 최대 가치를 해당 물건을 선택하지 않았을 때의 무게의 경우의 최대 가치와 비교하여 갱신한다
3. 2번 과정을 모든 물건에 대해 결정했을 때에 대해 반복한다

#### 0-1 배낭 문제 구현
```python
def knapsack(weights, values, N, W):
    # dp[i][j] : i번 물건까지 결정했을 때의 최대 무게가 j일때 최대 가치
    dp = [[0] * (W+1) for _ in range(N+1)]
    
    for i in range(1, N+1):
        for j in range(1, W+1):
            # w : i번 물건의 무게
            w = weights[i-1]
            v = values[i-1]
            # 현재 가방에 물건을 넣을 수 없는 경우
            if j < w:
                dp[i][j] = dp[i-1][j] # 물건 넣는 경우 스킵
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)
```