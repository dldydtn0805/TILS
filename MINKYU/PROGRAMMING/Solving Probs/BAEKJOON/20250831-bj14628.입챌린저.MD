# 백준 문제 풀이

## bj 14628. 입 챌린저(2025-08-31)

## 문제 유형

1. Dynamic Programming
2. Knapsack

## 문제 설명

광현이는 자칭 게임 아티스트이다. 게임 아티스트라고 해서 게임 캐릭터를 디자인하는 일이 아니라 게임을 Art하게 플레이하는 것을 의미한다. 광현이는 요즘 '리그오브스톰'이라는 게임에 빠졌다. 리그오브스톰은 스킬을 써서 상대방의 체력을 0 이하로 만들면 이기는 게임이다. 스킬은 총 N개가 있는데, 모든 스킬에는 사용 시 마나 포인트라는 비용이 필요하다. 또한, 스킬마다 상대방의 체력을 깎을 수 있는 수치가 정해져 있다. 스킬 사용 제한 횟수는 없지만 같은 스킬을 한 번 이상 사용할 때엔 필요한 마나 포인트가 원래 마나 포인트에서 K씩 추가로 증가한다. 예를 들어 어떤 스킬의 마나 포인트가 10이고 K값이 5이면 처음 사용할 때는 10, 그다음은 15, 그다음은 20 이런 식으로 증가하게 된다. 광현이는 이 게임을 아주 많이 플레이하여 브론즈 등급에 있었지만 슬슬 질려가고 있었다. 그래서 광현이는 게임 아티스트답게 플레이에 어떤 제약을 걸고 게임에 임하려고 한다. 그 제약이란 상대방의 체력을 정확하게 0으로 만들면서 마나 포인트를 최대한 적게 사용하는 것이다. 과연 광현이는 이 제약을 지킬 수 있을까? 광현이의 플레이가 맞는지 확인하기 위해 적의 체력을 정확하게 0으로 만들 때 필요한 가장 적은 마나 포인트를 구해보자.

## 입력

입력은 항상 적의 체력을 정확히 0으로 만들 수 있는 스킬의 조합만 들어온다. 첫째 줄에 스킬의 개수 N, 적의 체력 M, 같은 스킬을 사용할 때마다 추가되는 마나 포인트 K가 주어진다. (1≤N,M,K≤100) 둘째 줄부터 N개의 줄에 걸쳐서 한 줄마다 스킬에 필요한 마나 포인트 X와 상대방의 체력을 깎는 수치인 Y가 주어진다. (1≤X,Y≤100)

## 출력

첫째 줄에 적의 체력을 정확하게 0 으로 만들 때 필요한 가장 적은 마나 포인트를 출력한다.

## 문제풀이

누적값을 활용한 knapsack 문제이다. 각 스킬 별로 드는 마나 소모, 깎는 체력이 다음과 같다.

만약, i번 스킬의 마나 소모량이 m, 깎는 체력이 h일 경우

- 1번 사용 시 : m, h
- 2번 사용 시 : m + (m + K), 2 \* h
- ...
- j번 사용 시 : m + (m + K) + ... + (m + (j-1) _ K), j _ h

가 된다. 이를 활용하여, 각 스킬 별로 j번 활용 시 드는 마나 합, 체력 합을 저장했다.

dp는 i번 스킬까지 활용했을 때, 정확하게 체력을 j만큼 깎을 수 있는 경우 드는 최소 마나 소모량을 저장한다.

위에서 생성한 배열을 활용하여 i, j를 순차적으로 순회하며 갱신해준다.

## 문제풀이 코드

```python
# 백준 14628
import sys

# N : 스킬의 개수(1 <= N <= 100)
# M : 적의 체력(1 <= M <= 100)
# K : 같은 스킬 사용 시 추가되는 마나 포인트(1 <= K <= 100)
# skills[i] = (x, y) : i번 스킬 사용 마나량(x)과 체력 수치(y)
def solution(N, M, K, skills):
    skills_sum = [[(0, 0)] for _ in range(N+1)]
    for i in range(1, N+1):
        m, h = skills[i]
        new_m = 0
        new_h = 0
        for j in range(1, M+1):
            new_m += m + K * (j-1)
            new_h += h
            if new_h > M:
                break
            skills_sum[i].append((new_m, new_h))
    # for i in range(1, N+1):
    #     print(skills_sum[i])
    dp = [[int(1e9)] * (M+1) for _ in range(N+1)]
    dp[0][0] = 0
    # i번 스킬까지 해서
    # 체력을 총 j만큼 깎을 경우,
    # 사용할 수 있는 최소 마나
    for i in range(1, N+1):
        L = len(skills_sum[i])
        for j in range(M+1):
            dp[i][j] = dp[i-1][j]
            for k in range(1, L):
                # m : i번 스킬을 k번 사용했을 경우 드는 총 마나
                # h : i번 스킬을 k번 사용했을 경우 깎을 수 있는 체력
                m, h = skills_sum[i][k]
                if j - h < 0:
                    break
                # 직전에 j-h가 되는 경우가 있을 경우
                if dp[i-1][j-h] != int(1e9):
                    dp[i][j] = min(dp[i][j], dp[i-1][j-h] + m)
    # for i in range(1, N+1):
    #     print(dp[i])
    return dp[N][M]

N, M, K = map(int, input().split())
skills = [(0, 0)]
for _ in range(N):
    x, y = map(int, input().split())
    skills.append((x, y))
print(solution(N, M, K, skills))
```

```java


```
