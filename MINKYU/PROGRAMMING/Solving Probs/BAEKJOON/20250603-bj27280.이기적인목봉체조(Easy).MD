# 백준 문제 풀이

## bj . (2025-)

## 문제 설명

대망의 유격 훈련 날, 조교는 훈련병들에게 목봉 체조 훈련을 시키려고 한다. 목봉 체조 훈련이란 여러 명이 동시에 하나의 목봉을 어깨높이로 들고, 반대편 어깨로 목봉을 옮기는 훈련이다.

조교들은 N명의 모든 훈련병들을 M개의 그룹으로 나눠서 목봉 체조를 실시하고자 한다. 이때, 훈련병들의 번호를 헷갈리지 않도록 서 있는 순서대로 연속된 훈련병들만 한 그룹으로 묶어야 하며, 각 그룹은 한 명 이상의 훈련병들로 구성되어야 한다.

하지만 이 훈련병들은 전부 다 너무 이기적이어서, 동일한 그룹에 본인보다 키가 조금이라도 큰 훈련병이 있다면 힘을 아예 쓰지 않고 드는 척만 한다. 즉, 그룹 안에서 키가 가장 큰 훈련병들만 목봉에 힘을 가한다.

N명의 훈련병을 적절히 M개의 그룹으로 나누었을 때 훈련병들이 들 수 있는 목봉 무게의 합의 최댓값을 구하여라.

## 입력

첫 번째 줄에 훈련병의 수 N과 그룹의 수 M이 공백으로 구분되어 주어진다.(1 <= N <= 1,000, 1 <= M <= 10, M <= N)

두 번째 줄부터 N+1번째 줄까지, 훈련병의 키를 나타내는 정수 h_i와 힘을 나타내는 정수 s_i가 서 있는 순서대로 공백으로 구분되어 주어진다. (1 <= h_i, s_i <= 10^9)

## 출력

N명의 훈련병을 적절히 M개의 그룹으로 나누었을 때 훈련병들이 들 수 있는 목봉 무게 합의 최댓값을 출력한다.

## 문제풀이

처음에는 기본적인 dp 문제인 줄 알고 생각보다 쉽게 해결될 줄 알았다. 하지만, 문제를 잘못 읽어서 한 개의 그룹에 한 명의 가장 키가 큰 훈련병만 목봉에 힘을 가하는 줄 알고 i ~ j훈련병이 한 그룹이 되었을 때의 힘을 담은 2차원 배열 strong에 값을 잘못 대입했다.

가장 키가 큰 훈련병이 한 그룹에 여러 명 있을 경우, 그들의 힘을 모두 합쳐야 하는 것이 문제의 핵심이었다.

dp[i][j]를 0번 훈련병부터 i번 훈련병까지 j개의 그룹을 만들었을 때의 최대 들 수 있는 목봉 무게 합의 최대값을 담게 했다. 이렇게 할 경우, 점화식을 짜기 위해서는 다음과 같이 생각해야 했다.

- 0과 i 사이의 임의의 k에 대하여, dp[i][j]는 기존 값과 (0 ~ k 훈련병들이 j-1개의 그룹을 만들었을 때 최대값 + k+1 ~ i 훈련병들이 하나의 그룹일 때의 들 수 있는 목봉 무게 합)을 비교하여 갱신하는 과정이 필요

해당 과정을 점화식으로 풀어 문제를 해결할 수 있었다.

## 문제풀이 코드

```python
import sys

def get_strong(N, arr):
    strong = [[0] * N for _ in range(N)]
    for i in range(N):
        hi, si = arr[i]
        h = hi
        s = si
        strong[i][i] = s
        for j in range(i+1, N):
            hj, sj = arr[j]
            if h < hj:
                h = hj
                s = sj
            elif h == hj:
                s += sj
            strong[i][j] = s
    return strong

def solution():
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]

    strong = get_strong(N, arr)

    dp = [[-float('inf')] * (M+1) for _ in range(N+1)]
    dp[0][0] = 0

    for i in range(1, N + 1):
        for j in range(1, M + 1):
            for k in range(j - 1, i):
                if dp[k][j-1] != -float('inf'):
                    dp[i][j] = max(dp[i][j], dp[k][j-1] + strong[k][i-1])

    print(dp[N][M])

solution()

```

```java


```
