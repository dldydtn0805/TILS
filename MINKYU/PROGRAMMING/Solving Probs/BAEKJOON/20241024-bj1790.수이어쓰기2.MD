# 백준 문제 풀이
## bj 1790. 수 이어 쓰기 2(2024-10-24)

## 문제 설명
    1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.
        1234567891011121314151617181920212223...
    이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.

## 입력
    첫째 줄에 N(1 ≤ N ≤ 100,000,000)과, k(1 ≤ k ≤ 1,000,000,000)가 주어진다. N과 k 사이에는 공백이 하나 이상 있다.

## 출력
    첫째 줄에 앞에서 k번째 자리 숫자를 출력한다. 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 -1을 출력한다.

## 문제풀이
    주어진 수까지 쭉 풀어 썼을 때 만들어진 수에서 K번째 자리의 숫자를 출력하는 문제였다. 만약, 1 ~ N까지 다 이었을 때 길이가 K를 넘지 않는다면, -1을 출력하면 된다. 
    문제를 쉽게 생각한다면 다음과 같다.
    1 ~ 9 : 총 9글자(1 * 9 * (10**0))
    10 ~ 99 : 총 180글자(2 * 9 * (10**1))
    100 ~ 999 : 총 2700글자(3 * 9 * (10**2))
    ...
    digit 자리수 일 때, 총 (digit * 9 * (10**(digit-1))) 글자이다.
    따라서, K번째 자리를 구하기 위해 자릿수를 기준으로 하며 좁히는 방식으로 문제를 해결했다.
    이후, 더 이상 넘어갈 자릿수가 없을 경우(주어진 자릿수보다 클 경우, K를 넘어갈 경우), 지금까지 합친 자릿수의 개수에 +1, +(K-1)//digit을 통해 나머지를 구하는 느낌으로 현재 자릿수를 찾아간다.
    만약 만들어낸 숫자가 N보다 클 경우(더 큰 숫자로 K번쨰 자릿수를 찾아야 함 -> 실패), -1을 출력하고, 아닐 경우 해당 수를 기준으로 하여 자릿수를 찾아나선다.

## 문제풀이 코드
```python
# 백준 1790. 수 이어 쓰기 2
import sys

def check(N, K):
    '''
    123456789 : 9 * 1
    1011 ~ 99 : 90 * 2
    100101~999 : 900 * 3 = 2700
    N자릿수를 쭉 붙여놓으면 9 * (10^(자릿수-1)) * 자릿수
    '''
    num = 0
    digit = 1
    while K > digit * 9 * (10**(digit-1)):
        K -= digit * 9 * (10**(digit-1))
        num += 9 * (10**(digit-1))
        digit += 1
    num = (num+1) + (K-1)//digit

    # N으로는 못 만듬
    if num > N:
        return -1
    return str(num)[(K-1)%digit]


def solution():
    # 1부터 N까지의 수를 이어서 만든 새로운 수에서, 앞에서 K번쨰 자리 숫자 구학
    # 1 <= N <= 100000000
    # K 1 <= K <= 1000000000
    N, K = map(int, input().split())
    print(check(N, K))
solution()
```