# 백준 문제 풀이

## bj 22953. 도도의 음식 준비(2025-07-01)

## 문제 설명

도도는 주방장이다. 총 K개의 요리가 준비되는 최소 시간을 구해야 한다.

각각의 요리사는 자신만의 음식 조리 시간이 있다. 음식 조리 시간은 음식 하나를 만들 때 걸리는 시간이다.

도도는 요리사에게 격려를 해줄 수 있다. 격려받은 요리사는 영구적으로 음식 조리 시간이 1초 감소한다.

도도는 한 요리사에게 여러 번 격려할 수 있고, 요리사의 음식 조리 시간을 1초 미만으로 줄일 수는 없다.

도도를 위해 요리에 걸리는 최소 시간을 출력하는 프로그램을 만들어 보자.

## 입력

첫째 줄에 요리사의 수 N (1 <= N <= 10), 만들어야 할 음식의 개수 K (1 <= K <= 1,000,000), 격려해줄 수 있는 횟수 C (0 <= C <= 5)가 주어진다.

둘째 줄에 길이가 N인 정수 수열 A가 주어진다. i번째로 주어지는 수 A_i는 i번째 요리사의 음식 조리 시간이다. (1 <= i <= N, 1 <= A_i <= 1,000,000)

## 출력

첫째 줄에 K개의 음식 조리가 완료되는 최소 시간을 출력한다.

## 문제풀이

백트래킹과 이분 탐색을 섞는 문제였다. 배열을 오름차순 정렬 후, 주어진 격려 횟수에 대해 요리를 완성하는데 걸리는 시간이 1보다 큰 요리사들에 대해 격려를 진행하면서 백트래킹을 조정한다.

정제된 배열에 대해, 이분탐색을 진행한다. 주어진 중간값 m에 대해서, m보다 작거나 같은 시간 내에 음식을 만들 수 있을 경우, 최대한 음식을 만든다. 만들어진 음식 개수 합이 K보다 크거나 같을 경우, 최대값(r)을 조정한다. 아닐 경우, 최소값(l)을 조정한다. 마지막에 왼쪽값, 즉 K개 이상을 만들기 위해 가능한 최소값을 리턴하면 된다. 해당 리턴값이 현재 주어진 배열에서 만들어 낼 수 있는 최소 시간이기 때문에, 계속해서 backtracking 초입 부분에 호출함으로써 결과값을 갱신한다.

백트래킹 문제인 만큼, 가지치기 return이 중요하다. 현재 사용한 격려 횟수가 C에 도달했을 경우 또는 현재 주어진 배열의 모든 원소가 1일 경우 return해줌으로써 가지치기를 통해 효율성을 증가시켰다.

## 문제풀이 코드

```python
# 백준 22953
import sys

# N : 요리사의 수(1 <= N <= 10)
# K : 만들어야 할 음식의 개수(1 <= K <= 1000000)
# C : 격려해줄 수 있는 횟수(0 <= C <= 5)
# arr[i] : i번 요리사의 음식 조리 시간
def solution(N, K, C, arr):
    result = float('inf')
    # 현재 주어진 배열로 계산하기
    def calculate_time(arr):
        l = 1
        r = N * K * max(arr)
        while l <= r:
            m = (l+r) // 2
            time = 0
            for n in arr:
                time += m // n
            if time >= K:
                r = m-1
            else:
                l = m+1
        return l
    # c : 격려 횟수
    # idx : 시작 인덱스
    def backtracking(c, idx):
        nonlocal result
        # 모든 backtracking에 대해 최소값 갱신
        result = min(result, calculate_time(arr))
        # 격려를 다 한 경우 return
        if c == C:
            return

        # 모든 원소의 값이 1일 경우 return
        if arr == [1] * N:
            return
        for i in range(idx, N):
            if arr[i] > 1:
                arr[i] -= 1
                backtracking(c+1, i)
                arr[i] += 1

    backtracking(0, 0)
    return result

N, K, C = map(int, input().split())
arr = list(map(int, input().split()))
arr.sort()
print(solution(N, K, C, arr))
```

```java


```
