# 백준 문제 풀이

## bj 13164. 행복 유치원(2025-07-04)

## 문제 설명

행복 유치원 원장인 태양이는 어느 날 N명의 원생들을 키 순서대로 일렬로 줄 세우고, 총 K개의 조로 나누려고 한다. 각 조에는 원생이 적어도 한 명 있어야 하며, 같은 조에 속한 원생들은 서로 인접해 있어야 한다. 조별로 인원수가 같을 필요는 없다.

이렇게 나뉘어진 조들은 각자 단체 티셔츠를 맞추려고 한다. 조마다 티셔츠를 맞추는 비용은 조에서 가장 키가 큰 원생과 가장 키가 작은 원생의 키 차이만큼 든다. 최대한 비용을 아끼고 싶어 하는 태양이는 K개의 조에 대해 티셔츠 만드는 비용의 합을 최소로 하고 싶어한다. 태양이를 도와 최소의 비용을 구하자.

## 입력

입력의 첫 줄에는 유치원에 있는 원생의 수를 나타내는 자연수 N(1 ≤ N ≤ 300,000)과 나누려고 하는 조의 개수를 나타내는 자연수 K(1 ≤ K ≤ N)가 공백으로 구분되어 주어진다. 다음 줄에는 원생들의 키를 나타내는 N개의 자연수가 공백으로 구분되어 줄 서 있는 순서대로 주어진다. 태양이는 원생들을 키 순서대로 줄 세웠으므로, 왼쪽에 있는 원생이 오른쪽에 있는 원생보다 크지 않다. 원생의 키는 109를 넘지 않는 자연수이다.

## 출력

티셔츠 만드는 비용이 최소가 되도록 K개의 조로 나누었을 때, 티셔츠 만드는 비용을 출력한다.

## 문제풀이

그리디를 오랜만에 풀어보았다. 오름차순 정렬 된 값들에 대해서, 인접한 원소들끼리 K개의 집합으로 묶었을 때, 같은 집합 내의 원소들 간 최대값과 최소값의 차이의 합이 최소가 되도록 하는 문제이다. 당연히 최소값이 되기 위해서는 집합의 원소 수가 최대한 작아야 한다. 모든 인접 원소간의 차이를 구하고, 이를 정렬해주면 두 개의 원소를 하나의 집합으로 묶었을 때의 결과가 나온다. 정렬된 원소들 중 N-K개만 더해줄 경우 원하는 대로 K개의 집합으로 묶은 결과가 나온다(나머지는 한 개의 원소가 한 개의 집합을 이룰 경우, 최대값과 최소값의 차이가 0이 되기 때문에 최적의 결과가 나온다.)

예를 들어, 1 3 5 6 10 형태의 배열이 주어질 경우, 인접 원소간의 차이를 정렬한 결과는 1 2 2 4가 된다. K가 3일 경우, N-K = 2번 원소간의 차이를 더해주면 3이 된다. 이 3은

- 1 3
- 5 6
- 10

이렇게 나누었을 때 최적의 결과가 나옴을 알 수 있다.(N-K개만 인접한 두 개의 원소를 집합으로 만들고, 나머지는 한 개의 원소가 한 개의 집합으로 만드는 것이 최적의 결과인 것이다)

## 문제풀이 코드

```python
# 백준 13164
import sys

# N : 유치원생의 수(1 <= N <= 300000)
# K : 나누려고 하는 조의 개수(1 <= K <= N)
# arr[i] : i번 유치원생의 키(1 <= arr[i] <= 10**9)
def solution(N, K, arr):
    D = []
    for i in range(1, N):
        D.append(arr[i] - arr[i-1])
    # 차이를 최소화 하려면 최대한 가까운 애들 두명끼리 합치기
    D.sort()
    print(D)
    result = 0
    for i in range(N-K):
        result += D[i]
    return result

N, K = map(int, input().split())
arr = list(map(int, input().split()))
print(solution(N, K, arr))
```

```java


```
