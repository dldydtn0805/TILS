# 백준 문제 풀이

## bj 3987. 보이저 1호(2024-12-21)

## 문제 설명

보이저 1호는 1977년에 발사된 NASA의 태양계 무인 탐사선이다. 현재 보이저 1호는 태양권덮개 (헬리오시스)에 있다.

보이저 1호와 같이 오랜 기간동안 활동하는 탐사선은 경로를 항성계를 만날 때 마다 라디오 시그널 메시지를 이용해서 기록하고 있다.

항성계를 N \* M개의 직사각형으로 나누어져 있는 N행 M열의 직사각형 그리드라고 생각해보자. 각 칸은 행성, 블랙홀을 포함할 수 있으며, 비어있을 수도 있다. 탐사선은 인접한 네 칸(위, 아래, 오른쪽, 왼쪽)중에서 하나를 골라서 시그널을 보낸다.

시그널은 항상 일직선으로 전파되며, 행성을 만났을 경우에는 전파되는 방향이 90도로 바뀌게 된다. 행성은 '/'와 '\'로 표현되는 두 종류가 있으며, 반사되는 법칙은 아래 그림과 같다.

시그널이 블랙홀이 있는 칸을 만나거나 항성계를 벗어날 때 까지 계속 전파된다. 시그널이 인접한 칸으로 이동하는데 걸리는 시간은 1초이다.

탐사선이 어느 방향으로 시그널을 보내면, 시그널이 항성계 내부에 있는 시간이 최대가 되는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 500)

다음 N개 줄에는 M개의 문자가 주어지며, '/'와 '\'는 행성을, C는 블랙홀을, '.'는 빈 칸을 나타낸다.

마지막 줄에는 탐사선이 있는 위치 PR과 PC가 주어진다. (1 ≤ PR ≤ N, 1 ≤ PC ≤ M)

## 출력

첫째 줄에 시그널을 보내는 방향을 출력한다. (U: 위, R: 오른쪽, D: 아래, L: 왼쪽)

만약, 방향이 여러 가지가 존재한다면, U, R, D, L의 순서 중 앞서는 것을 출력한다.

둘째 줄에는 가장 긴 시간을 출력한다. 만약, 시그널이 항성계 내에서 무한히 전파될 수 있다면 "Voyager"를 출력한다.

## 문제풀이

dfs를 활용하여 문제를 해결하였다. 조건에 따라 분기점을 나누는 것이 조금 어려웠다. 현재 위치(i, j), 현재 방향(d), 현재 시간(t)를 기준으로 하여 파악하면 된다.

## 문제풀이 코드

```python
# 백준 3987. 보이저 1호
import sys

def check(N, M, R, C, d, arr, di, dj, P, Q):
    start_d = d

    i = R
    j = C
    t = 1
    while True:
        ni = i + di[d]
        nj = j + dj[d]

        # 벽을 만나거나, 블랙홀을 만날 경우 -> t 리턴
        if not (0 <= ni < N and 0 <= nj < M) or arr[ni][nj] == 'C':
            return t

        # /를 만남 -> d 변경(P)
        if arr[ni][nj] == '/':
            d = P[d]
        # \를 만남 -> d 변경(Q)
        elif arr[ni][nj] == '\\':
            d = Q[d]
        # i, j, t 갱신
        i = ni
        j = nj
        t += 1

        # 시작 위치랑 동일한 방향을 반복 -> Voyage
        if i == R and j == C and d == start_d:
            return -1


def solution():
    # N, M : 항성계의 크기(1 <= N, M <= 500)
    N, M = map(int, input().split())
    # arr[i][j] = / : 행성
    # arr[i][j] = \ : 행성
    # arr[i][j] = C : 블랙홀
    # arr[i][j] = . : 빈 칸
    arr = [list(input()) for _ in range(N)]
    R, C = map(int, input().split())
    R -= 1
    C -= 1

    direction = ['U', 'R', 'D', 'L']
    di = [-1, 0, 1, 0]
    dj = [0, 1, 0, -1]
    P = [1, 0, 3, 2]
    Q = [3, 2, 1, 0]

    result1 = 0
    result2 = 0
    for d in range(4):
        t = check(N, M, R, C, d, arr, di, dj, P, Q)
        if t == -1:
            result1 = d
            result2 = "Voyager"
            break
        if t > result2:
            result1 = d
            result2 = t
    print(direction[result1])
    print(result2)
solution()
```
