# 백준 문제 풀이

## bj 5569. 출근 경로(2025-01-28)

## 문제 설명

상근이가 사는 도시는 남북 방향으로 도로가 w개, 동서 방향으로 도로가 h개 있다.

남북 방향 도로는 서쪽부터 순서대로 번호가 1, 2, ..., w로 매겨져 있다. 또, 동서 방향 도로는 남쪽부터 순서대로 번호가 1, 2, ..., h로 매겨져 있다. 서쪽에서 i번째 남북 방향 도로와 남쪽에서 j번째 동서 방향 도로가 만나는 교차로는 (i, j)이다.

상근이는 교차로 (1, 1)에 살고 있고, 교차로 (w, h)에 있는 회사에 차로 다니고 있다. 차는 도로로만 이동할 수 있다. 상근이는 회사에 최대한 빨리 가기 위해서, 동쪽 또는 북쪽으로만 이동할 수 있다. 또, 이 도시는 교통 사고를 줄이기 위해서 교차로를 돈 차량은 그 다음 교차로에서 다시 방향을 바꿀 수 없다. 즉, 교차로에서 방향을 바꾼 후, 1 블록만 이동한 후 다시 방향을 바꿀 수 없다.

상근이가 회사에 출근할 수 있는 경로의 수는 몇 가지 일까?

w와 h가 주어졌을 때, 가능한 출근 경로의 개수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 w와 h가 주어진다. (2 ≤ w, h ≤ 100)

## 출력

첫째 줄에 상근이가 출근할 수 있는 경로의 개수를 100000로 나눈 나머지를 출력한다.

## 문제풀이

4차원의 dp로 문제를 해결하였다. (i, j)에 대해 이전에 온 경로를 파악해야 했기 때문이다. 4번째 차수의 인덱스가 0일 경우는 일직선으로, 1일 경우는 이전에 교차로에서 방향을 바꾼 것으로 인식하여 문제를 풀 수 있었다.

## 문제풀이 코드

```python
# 백준 5569. 출근 경로
import sys

def dynamic_programming(N, M):
    dp = [[[[0] * 2 for _ in range(2)] for _ in range(M+1)] for _ in range(N+1)]
    for i in range(2, N+1):
        dp[i][1][0][0] = 1
    for i in range(2, M+1):
        dp[1][i][1][0] = 1

    for i in range(2, N+1):
        for j in range(2, M+1):
            dp[i][j][0][0] = (dp[i-1][j][0][0] + dp[i-1][j][0][1]) % 100000
            dp[i][j][0][1] = dp[i-1][j][1][0]
            dp[i][j][1][0] = (dp[i][j-1][1][0] + dp[i][j-1][1][1]) % 100000
            dp[i][j][1][1] = dp[i][j-1][0][0]
    result = 0
    for i in range(2):
        for j in range(2):
            result += dp[N][M][i][j]
    return result % 100000

def solution():
    N, M = map(int, input().split())
    print(dynamic_programming(N, M))

solution()
```
