# 백준 문제 풀이

## bj 15487. A[j]-A[i]+A[l]-A[k](2025-07-26)

## 문제 유형

1. Dynamic Programming(DP)

## 문제 설명

크기가 N인 배열 A가 주어졌을 때, i < j < k < l을 만족하는 (i, j, k, l) 중에서 A[j]-A[i]+A[l]-A[k]의 최댓값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 배열 A의 크기 N(4 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 배열 A에 들어있는 수가 순서대로 주어진다. 배열에 들어있는 수는 1,000,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 i < j < k < l을 만족하는 (i, j, k, l) 중에서 A[j]-A[i]+A[l]-A[k]의 최댓값을 출력한다.

## 문제풀이

구현하기 굉장히 어려운 문제였다. 주어진 N은 1000000이 최대지만, 이를 O(4N) 시간 복잡도로 풀 수 있었다.

dp를 1 X 5의 일차원 배열로 구현한 후, 다음과 같이 취급하면 된다.

각 인덱스 i(i는 1 ~ N 사이의 정수)에 대해

1. dp[4]는 i까지의 값중 -, +, -, +의 형태로 계산 시 최대가 되는 값을 담는다
2. dp[3]는 i까지의 값중 -, +, -의 형태로 계산 시 최대가 되는 값을 담는다
3. dp[2]는 i까지의 값중 -, +의 형태로 계산 시 최대가 되는 값을 담는다
4. dp[1]는 i까지의 값중 -의 형태로 계산 시 최대가 되는 값을 담는다

위와 같이 역순으로 dp에 접근하며 현재 주어진 값(arr[i] = n)을 기준으로 dp의 앞 인덱스에 저장된 값에 n을 더하거나 뺀 값을 비교하며 갱신해주면 된다.

1번부터 3번 사이의 값들을 각각 초기화 시켜주고, 4번부터 N번까지에 대한 값들을 갱신해 주어야 한다. 이 때 초기화는 다음과 같다.

1. dp[1] : 1 ~ 3 사이의 값들 중, 음수값이 최대인 값의 음수값

- dp[1] = max(-arr[1], -arr[2], -arr[3])

2. dp[2] : 1 ~ 3 사이의 서로 다른 두 값에 대해, 뒤 - 앞의 값이 최대인 값

- dp[2] = max(-arr[1] + arr[2], -arr[1] + arr[3], -arr[2] + arr[3])

3. dp[3] : 1 ~ 3 사이의 값들을 차례대로 -, +, -를 붙여서 계산한 값

- dp[3] = -arr[1] + arr[2] - arr[3]

4. 점화식의 편의를 위해서 dp[0]에는 0을 넣어준다

## 문제풀이 코드

```python
# 백준 15487
import sys

# N : 배열에 들어간 수의 개수(4 <= N <= 1000000)
def solution(N, arr):
    # dp[1] : 현재 본 값들까지 했을 대 - 최대값
    # dp[2] : 현재 본 값들까지 했을 때 -+ 최대값
    # dp[3] : 현재 본 값들까지 했을 때 -+-가 최대값
    # dp[4] : 현재 본 값들까지 했을 때 -+-+가 최대값
    dp = [-float('inf')] * 5
    dp[3] = -arr[1] + arr[2] - arr[3]
    dp[2] = max(-arr[1] + arr[2], -arr[1] + arr[3], -arr[2] + arr[3])
    dp[1] = max(-arr[1], -arr[2], -arr[3])
    dp[0] = 0
    for i in range(4, N+1):
        n = arr[i]
        for j in range(4, 0, -1):
            dp[j] = max(dp[j], dp[j-1] + n * (-1)**j)
    return dp[4]
N = int(input())
arr = [0] + list(map(int, input().split()))
print(solution(N, arr))
```

```java


```
