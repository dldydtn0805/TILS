# 백준 문제 풀이

## bj 26260. 이가 빠진 이진 트리(2024-12-29)

## 문제 설명

김소마는 최근에 포화 이진 트리에 대해 배웠다. 포화 이진 트리란, 이진 트리에서 리프 노드를 제외한 모든 노드가 두 자식 노드를 가지며, 모든 리프 노드가 채워진 것을 말한다.

김소마는 예쁜 포화 이진 검색 트리를 그려 만족했지만, 밥 먹다 흘린 소스가 리프 노드 한 개를 가려버렸다. 여기서 이진 검색 트리란, 모든 왼쪽 자식이 자신보다 작고, 모든 오른쪽 자식이 자신보다 큰 이진 트리를 이야기한다.

그림을 버리려던 찰나, 김소마는 갑자기 포화 이진 검색 트리를 유지하며, 임의의 수를 넣을 때, 트리 구조가 어떻게 바뀔지 궁금해졌다. 멍청한 김소마를 위해 당신이 도와주자.

## 입력

첫 번째 줄에 가려진 노드를 포함한 노드의 개수 N이 주어진다. (N=2^k-1, 2 <= k <= 17, k는 정수)

두 번째 줄에 A_1, A_2, ..., A_N이 공백으로 구분되어 주어진다.
A_i는 i번 노드에 적혀있는 수이다.(0 <= A_i <= 10^9, 가려진 하나의 노드에 대해서만 A_i = -1) i != j이면 A_i != A_j이다.
노드 번호는 루트 노드부터 시작하여, 같은 깊이 내 왼쪽에서 오른쪽으로 갈수록 증가하는 순서로 매겨진다.

세 번째 줄에 트리에 넣을 수 X가 주어진다.(0 <= X <= 10^9, X != A_i)

입력으로 주어지는 모든 수는 정수이다.

## 출력

첫 번째 줄에 바뀐 트리를 후위(postorder) 순회한 결과를 출력한다. (단, 왼쪽 자식 노드를 먼저 방문한다.)

## 문제풀이

주어진 노드들을 정렬한 후, 이를 후위 순회로 방문한 순서를 출력하는 것이다.

## 문제풀이 코드

```python
# 백준 26260. 이가 빠진 이진 트리
import sys

def post_order(arr, result):
    if len(arr) == 1:
        result.append(arr[0])
        return
    mid = len(arr)//2
    left = arr[:mid]
    right = arr[mid+1:]

    post_order(left, result)
    post_order(right, result)
    result.append(arr[mid])
    return

def solution():
    # N : 가려진 노드를 포함한 노드의 개수(N = 2^k-1, 2 <= k <= 17)
    N = int(input())
    # arr[i] == -1 : 가려진 노드
    arr = list(map(int, input().split()))
    # X : 트리에 넣을 수(0 <= X <= 10^9)
    X = int(input())

    for i in range(N):
        if arr[i] == -1:
            arr[i] = X
            break
    arr.sort()
    result = []
    post_order(arr, result)
    print(*result)

solution()
```
