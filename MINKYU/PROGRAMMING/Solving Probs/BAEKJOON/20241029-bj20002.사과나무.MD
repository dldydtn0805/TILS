# 백준 문제 풀이
## bj 20002. 사과나무(2024-10-29)

## 문제 설명
    N × N 크기의 정사각형 모양 과수원이 있고, N × N 개의 사과나무가 1 × 1 크기의 간격으로 모든 칸에 심어져있다.

    농부 형곤이가 가을을 맞아 사과를 수확하려는데, 땅주인 신영이가 "너는 과수원 내에 사과나무를 K × K 의 크기의 정사각형 모양으로만 수확해 가져갈 수 있어, 이때 K는 1보다 크거나 같고 N보다 작거나 같은 정수라구! 나머지는 내가 먹을께! 하하!" 라고 통보했다.

    하나의 사과나무를 수확할 때, 사과를 통해 얻을 수 있는 이익과 노동비로 빠져나가는 손해가 동시에 이루어진다.

    그래서 형곤이는 나무의 위치를 좌표로 하여, 사과를 통해 얻은 이익과 노동비를 더한 총이익을 2차원 배열의 형태로 정리했다.

    악독한 땅주인 신영이로부터 고통받는 귀여운 형곤이에게 최대 총이익을 안겨주고 싶은 당신, 형곤이를 도와주자!

## 입력
    첫 번째 줄에는 과수원의 크기 N이 주어진다. (1 ≤ N ≤ 300)
    두 번째 줄부터 N + 1번째 줄까지, 해당 나무를 수확했을 때 얻을 수 있는 총이익을 표시한다.
    총이익은 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

## 출력
    첫 번째 줄에 최댓값을 출력한다.

## 문제풀이
    처음에는 단순한 누적합 문제인 줄 알았다. N의 범위가 넓지도 않았기 때문에 K의 범위를 전 범위로 두고, 주어진 i와 j에 대해 k를 활용한 끝 점이 N보다 작거나 같을 경우에만 계산을 하도록 했다. 하지만, N = 300이고, i, j, k = 150일 경우, 150 * 150 * 150 * 150이라 시간초과가 발생하게 된다.
    따라서, 1과 N 사이의 k를 설정 후, 끝점이 (i, j)이고 길이가 k인 정사각형을 만들기 위해 i와 j의 범위를 k부터 시작하도록 했다!

## 문제풀이 코드
```python
# 백준 20002. 사과나무
import sys

def calculate(i, j, k, sum_arr):
    return sum_arr[i][j] - sum_arr[i][j-k] - sum_arr[i-k][j] + sum_arr[i-k][j-k]

def prefix_sum(N, arr):
    # sum_arr[i][j] : (i, 1) ~ (i, j) 사이 순이익 총합
    sum_arr = [[0] * (N+1) for _ in range(N+1)]
    for i in range(1, N+1):
        for j in range(1, N+1):
            sum_arr[i][j] = sum_arr[i-1][j] + sum_arr[i][j-1] - sum_arr[i-1][j-1] + arr[i][j]
    result = sum_arr[1][1]
    for k in range(1, N+1):
        for i in range(k, N+1):
            for j in range(k, N+1):
                result = max(result, calculate(i, j, k, sum_arr))
    return result

def solution():
    # N : 과수원의 크기(1 <= N <= 300)
    N = int(input())
    # arr[i][j] : (i, j)에서 나무를 수확했을 대 얻을 수 있는 총이익(-1000 <= arr[i][j] <= 1000)
    arr = [[0] * (N+1)]

    for _ in range(N):
        arr.append([0] + list(map(int, input().split())))

    '''
    형곤이가 얻을 수 있는 이익 : K X K 크기의 정사각형 모양(1 <= K <= N)
    '''
    print(prefix_sum(N, arr))

solution()
```