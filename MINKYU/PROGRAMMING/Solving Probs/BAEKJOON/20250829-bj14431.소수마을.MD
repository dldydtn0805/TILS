# 백준 문제 풀이

## bj 14431. 소수마을(2025-08-29)

## 문제 유형

1. Min Heap
2. Dijkstra
3. Prime

## 문제 설명

소수 마을들의 주민들은 매우 특이한 규칙을 준수한다. 규칙은 바로 “가고 싶은 위치까지의 거리가 소수일 경우에만 간다”라는 것이다. 소수 마을의 주민 승욱이는 소수 마을에서 멀리 떨어진 A마을에 볼일이 있어 그곳까지 가야한다. 소수 마을에서 A마을까지의 단숨에 가고 싶지만 안타깝게도 두 마을의 거리는 소수가 아닐 경우에는 그럴 수가 없다. 그럴 경우에는 다른 마을들을 경유하여 가야한다. (경유하는 마을도 현재 위치에서의 거리가 소수일 경우에만 갈 수 있다.) 소수 마을과 경유할 수 있는 마을들, 그리고 A마을의 위치가 좌표평면 상으로 주어질 때, 승욱이가 소수 마을의 규칙을 준수하여 A마을로 갈 수 있는 최단의 길을 찾는 것을 도와주자. 소수 판정을 위해 마을 간의 거리는 정수 부분만으로 취급한다. 예를 들어, 거리가 3.1415라면 이를 버림하여 3만 취급한다.

## 입력

첫 번째 줄에 소수 마을의 위치 (X1,Y1)와 A마을의 위치 (X2,Y2)가 입력된다. 두 번째 줄에 경유할 수 있는 마을의 개수 N (0 ≤ N ≤ 4000)가 입력된다. 세 번째 줄부터 N+2번째 줄까지 경유 할 수 있는 마을들의 위치 (X3,Y3)가 입력된다. 단, 각 마을들의 좌표는 절댓값이 3000을 넘지 않는 정수이다.

## 출력

소수 마을의 규칙을 준수하여 A마을까지 가는 방법 중 제일 짧은 거리로 갈 수 있는 길의 거리합을 출력한다. 만약 소수 마을의 규칙을 준수하여 갈 수 있는 방법이 없는 경우 -1을 출력한다.

## 문제풀이

소수 판별을 활용한 다익스트라를 통한 최소 거리 문제이다.

각 마을에 대해 서로 거리를 정수값으로 버림 한 결과가 소수일 경우만 갈 수 있다. 이를 이용하면 쉽게 풀 수 있는 문제이다.

min heap에 들어있는 각 노드(거리, 인덱스)에 대해, 다음 마을로 방문하기 위해 각 마을까지의 거리가 소수인지 계산 후, 현재 거리와 해당 마을로 가기까지의 거리를 합한 값과 visited의 값을 비교하며 갱신 및 min heap에 추가를 반복한다.

만약 목표한 위치(A 마을 : N+1번 인덱스 좌표)에 도달하지 못했을 경우(visited[N+1] == int(1e9)) -1을, 도달했을 경우 해당 값을 출력한다.

## 문제풀이 코드

```python
# 백준 14431
import sys
import heapq

# Y1, X1 : 소수 마을의 위치
# Y2, X2 : A 마을의 위치
# N : 경우 할 수 있는 마을의 개수
# arr[i] = (y, x) : 경우할 수 있는 마을의 좌표(-3000 <= y, x <= 3000)
def solution(Y1, X1, Y2, X2, N, arr):
    def is_prime(num):
        if num == 2:
            return True
        if num < 2:
            return False
        for i in range(2, int(num**0.5)+1):
            if num % i == 0:
                return False
        return True
    pq = []
    visited = [int(1e9)] * (N+2)
    heapq.heappush(pq, (0, 0))
    visited[0] = 0
    while pq:
        dist, i = heapq.heappop(pq)
        y1, x1 = arr[i]
        if visited[i] < dist:
            continue
        for j in range(N+2):
            y2, x2 = arr[j]
            next_dist = int(((y1-y2) ** 2 + (x1-x2) ** 2) ** 0.5)

            if not is_prime(next_dist):
                continue
            if visited[j] <= dist + next_dist:
                continue
            heapq.heappush(pq, (dist+next_dist, j))
            visited[j] = dist+next_dist
    if visited[N+1] == int(1e9):
        return -1
    return visited[N+1]

arr = []
Y1, X1, Y2, X2 = map(int, input().split())
arr.append((Y1, X1))
N = int(input())
for _ in range(N):
    y, x = map(int, input().split())
    arr.append((y, x))
arr.append((Y2, X2))
print(solution(Y1, X1, Y2, X2, N, arr))
```

```java


```
