# 백준 문제 풀이

## bj 15573. 채굴(2025-08-25)

## 문제 유형

1. Breath First Search
2. Binary Search
3. Min Heap

## 문제 설명

땅 위에 놓여있는 세로 N, 가로 M 길이의 광산에 1 × 1 광물 N × M개가 있으며, 각 광물은 고유의 강도Si, j를 가진다.

채굴기를 이용하여 이 광물들을 채굴하려고 한다. 채굴기는 공기와 맞닿아 있는 광물 하나를 골라 채굴할 수 있다. 바닥과 광물과만 맞닿아 있으면 채굴할 수 없다. 채굴기의 성능 D에 대해, 채굴기는 강도가 D 이하인 광물들만 채굴할 수 있다. 원하는 광물의 수 K 이상을 채굴할 수 있는 최소의 D를 구하여라.

## 입력

첫째 줄에 N, M, K가 주어진다. (1 ≤ N, M ≤ 1000, 1 ≤ K ≤ N × M) 둘째 줄부터 맨 위의 광물들부터 순서대로 N줄 동안 M개의 광물의 강도 Si, j가 주어진다.(i = 1, 2, ..., N, j = 1, 2, ..., M) (1 ≤ Si, j ≤ 106)

## 출력

K개 이상의 광물을 채굴할 수 있는 최소의 D를 구하여라.

## 문제풀이

문제에서 주어진 값들의 제한을 보자마자 한숨이 나왔다.. 이 문제를 Python으로 어떻게 풀라는 것인가??????

고민 끝에 문제 유형을 보니 이분탐색이라는 말이 나왔다. 역시, 너무 큰 값은 이분탐색을 활용하는 것이 최적화에 좋은 것 같다.

문제 풀이 방식은, 가장자리부터 파고들며 K개를 지나는 방법들 중, 채굴기의 성능 D의 값이 최소가 되는 경우를 구하는 것이다. 따라서, 이분 탐색으로 설정한 D를 활용했을 때, K개 이상의 광물을 채굴할 수 있는지를 보며 l, r을 조절하면 된다.

시작 위치는 가장자리(i = 0 또는 j = 0 or j = M-1의 경우)에서부터 가능하다. 이분 탐색을 통해 설정한 D에 대해 가장자리에서부터 시작하며 bfs로 파고들어 가능한 개수를 구해주면 된다.

이 문제는 무조건 PyPy로 풀어야 하는 줄 알고 문제 제출 후, Python으로 푼 사람들이 혹시나 있을까 싶어 확인해 봤더니, 있었다! 역시 코딩 고수들이 너무 많다.

해당 풀이자들은 최소 힙을 이용했다. 가장자리의 값들을 최소 힙에 넣어두고, 해당 위치의 광물을 기준으로 heappop을 할 경우, 현재 힙에 들어있는 값들 중 최소 값을 가진 위치가 나오게 된다. 그 때 마다 나온 값을 현재 저장된 광물의 최소 강도와 비교하며 갱신하고, 개수를 늘려가면 된다.

이 방법을 사용할 경우, 현재 최소힙에 들어있는 광물들 중 강도가 가장 작은 광물을 먼저 채굴하게 된다. 따라서, 채굴한 광물의 개수가 K가 될 때 까지 최소 강도를 계속 갱신해 나갈 수 있다.

최소 힙을 이렇게 사용하다니 정말 참신한 방법이었다. 어쩌면, 이분 탐색보다 쉽게 생각 해 낼 수 있는 알고리즘이라고 생각한다.

## 문제풀이 코드 - 1(bfs)

```python
# 백준 15573
import sys
from collections import deque

# N, M : 크기(1 <= N, M <= 1000)
# arr[i][j] : 광물의 크기(1 <= arr[i][j] <= 10**6)
# K : 광물의 수(1 <= K <= N * M)
def solution(N, M, K, arr):
    def get_minmax():
        l = int(1e9)
        r = 0
        for i in range(N):
            for j in range(M):
                l = min(l, arr[i][j])
                r = max(r, arr[i][j])
        return l, r
    l, r = get_minmax()
    start = []
    for j in range(M):
        start.append((0, j))
    for i in range(1, N):
        start.append((i, 0))
        start.append((i, M-1))
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    def bfs(d):
        cnt = 0
        que = deque()
        visited = [[0] * M for _ in range(N)]
        for y, x in start:
            if arr[y][x] <= d:
                que.append((y, x))
                visited[y][x] = 1
                cnt += 1
        while que:
            i, j = que.popleft()
            for di, dj in dir:
                ni = i + di
                nj = j + dj
                if not (0 <= ni < N and 0 <= nj < M):
                    continue
                if visited[ni][nj] == 1:
                    continue
                if arr[ni][nj] > d:
                    continue
                que.append((ni, nj))
                visited[ni][nj] = 1
                cnt += 1
        return cnt

    result = r
    while l <= r:
        d = (l+r)//2
        cnt = bfs(d)
        if cnt >= K:
            result = min(result, d)
            r = d-1
        else:
            l = d+1
    return result

N, M, K = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
print(solution(N, M, K, arr))
```

## 문제풀이 코드 - 2(min heap)

```python
# 백준 15573
import sys
import heapq

# N, M : 크기(1 <= N, M <= 1000)
# arr[i][j] : 광물의 크기(1 <= arr[i][j] <= 10**6)
# K : 광물의 수(1 <= K <= N * M)
def solution(N, M, K, arr):
    pq = []
    visited = [[int(1e9)] * M for _ in range(N)]
    for j in range(M):
        heapq.heappush(pq, (arr[0][j], 0, j))
        visited[0][j] = 1
    for i in range(1, N):
        heapq.heappush(pq, (arr[i][0], i, 0))
        visited[i][0] = 1
        heapq.heappush(pq, (arr[i][M-1], i, M-1))
        visited[i][M-1] = 1
    result = 0
    cnt = 0
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while pq:
        d, i, j = heapq.heappop(pq)
        result = max(result, d)
        cnt += 1

        if cnt == K:
            return result
        for di, dj in dir:
            ni = i + di
            nj = j + dj
            if not (0 <= ni < N and 0 <= nj < M):
                continue
            if visited[ni][nj] == 1:
                continue
            heapq.heappush(pq, (arr[ni][nj], ni, nj))
            visited[ni][nj] = 1

N, M, K = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
print(solution(N, M, K, arr))
```
