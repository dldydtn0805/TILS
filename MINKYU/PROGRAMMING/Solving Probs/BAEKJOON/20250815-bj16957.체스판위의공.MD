# 백준 문제 풀이

## bj 16957. 체스판 위의 공(2025-08-15)

## 문제 유형

1. Dynamic Programming
2. Depth First Search

## 문제 설명

크기가 R×C인 체스판이 있고, 체스판의 각 칸에는 정수가 하나씩 적혀있다. 체스판에 적혀있는 정수는 모두 서로 다르다.

체스판의 각 칸 위에 공을 하나씩 놓는다. 이제 공은 다음과 같은 규칙에 의해서 자동으로 움직인다.

인접한 8방향 (가로, 세로, 대각선)에 적힌 모든 정수가 현재 칸에 적힌 수보다 크면 이동을 멈춘다.
그 외의 경우에는 가장 작은 정수가 있는 칸으로 공이 이동한다.
공의 크기는 매우 작아서, 체스판의 한 칸 위에 여러 개의 공이 있을 수 있다. 체스판의 상태가 주어진다. 공이 더 이상 움직이지 않을 때, 각 칸에 공이 몇 개 있는지 구해보자.

## 입력

첫째 줄에 체스판의 크기 R, C가 주어진다. 둘째 줄부터 R개의 줄에 체스판에 적혀있는 정수가 주어진다.

## 제한

1 ≤ R, C ≤ 500

0 ≤ 체스판에 적힌 정수 ≤ 300,000

## 출력

총 R개의 줄에 걸쳐서 체스판에 적힌 정수를 출력한다.

## 문제풀이

dfs를 활용하는 문제였다. 각 점에 대해, 마지막에 도착하는 점(인접하는 8개의 노드들 중 최소값을 가진 노드로 계속해서 연결)을 담는 방식으로 dfs를 진행하면 각 노드 별로 최종 도착 노드가 정해진다.

이후, 각 노드 별로 최종 도착 노드에 대해 값을 1씩 추가해주면 된다.

## 문제풀이 코드

```python
# 백준 16957
import sys

# N, M : 체스판의 크기(1 <= N, M <= 500)
# arr[i][j]
def solution(N, M, arr):
    dir = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    visited = [[None] * M for _ in range(N)]
    def dfs(i, j):
        if visited[i][j] is not None:
            return visited[i][j]

        min_val = arr[i][j]
        ii = i
        jj = j
        for di, dj in dir:
            ni = i + di
            nj = j + dj
            if not (0 <= ni < N and 0 <= nj < M):
                continue
            if arr[ni][nj] < min_val:
                min_val = arr[ni][nj]
                ii = ni
                jj = nj
        if min_val != arr[i][j]:
            visited[i][j] = dfs(ii, jj)
        else:
            visited[i][j] = (i, j)
        return visited[i][j]
    result = [[0] * M for _ in range(N)]

    for i in range(N):
        for j in range(M):
            ni, nj = dfs(i, j)
            result[ni][nj] += 1

    for i in range(N):
        print(*result[i])

N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
solution(N, M, arr)
```

```java


```
