# 백준 문제 풀이

## bj 23815. 똥게임(2025-07-02)

## 문제 설명

이 게임은 똥냄새가 너무 나서 도저히 볼 수가 없다! 따라서 당신은 직접 똥게임을 하지 않고 프로그램한테 똥게임을 시킬 것이다. 처음에는 사람 1명으로 시작한다. 당신에게는 총 N번의 턴이 주어지며, 각 턴마다 다음 선택지 4개중 2개가 주어진다. 같은 선택지가 주어질 수도 있다. 각 선택지는 +x, -x, \*x, /x \, (1 <= x <= 9) 중 하나로 주어진다.

+x를 선택할 경우, 사람의 수가 x명만큼 증가한다.

-x를 선택할 경우, 사람의 수가 x명만큼 감소한다.

\*x를 선택할 경우, 사람의 수가 x배가 된다.

/x를 선택할 경우, 사람의 수가 x만큼 나눠진다. 만약 현재 사람 수가 x로 나눠지지 않을 경우 나머지는 버린다.

N개의 선택지 중 1번에 한해 광고를 보고 선택지를 건너뛸 수 있다. 광고를 보지 않고 선택지를 건너뛰지 않아도 된다. 만약 각 턴이 끝난 뒤 현재 사람이 0명 이하가 되면 게임 오버가 된다. 당신은 N번의 선택지를 거친 후 사람의 수를 최대로 만들어야 한다. 어떠한 선택을 하더라도 중간에 사람의 수가 32비트 정수 범위를 넘지 않음을 보장한다.

## 입력

첫 번째 줄에 선택지의 개수 N(1 <= N <= 100,000)가 주어진다.

그 이후 N개의 줄에 걸쳐 2개의 선택지가 공백을 사이로 두고 주어진다.

각 선택지는 +x, -x, \*x, /x 중 하나로 주어진다 (1 <= x <= 9).

## 출력

N개의 선택지를 거친 후 최대 사람의 수를 출력한다.

만약 어떤 선택을 하더라도 게임 오버가 된다면 ddong game을 출력한다.

## 문제풀이

dp문제이다. 최대 한 번의 건너뛰기를 사용하고 만들 수 있는 최대 사람의 수를 구해야 한다.

이 문제는 건너뛰기를 사용하지 않았을 경우, 사용했을 경우 두 가지로 분리해서 생각해야 하는 문제였다. 건너뛰기를 사용한 경우는 이전 건너뛰기를 사용하고, 이번에는 사용 X 또는 이전 건너뛰기를 사용하지 않고, 이번에 사용 두 가지가 있다. 건너뛰기를 사용하지 않은 경우에는 그냥 최대값을 만들 수 있는 경우를 선택하면 된다.

매 상황 별로 건너뛰기를 사용하던 말던 0보다 작거나 같은 값이 나올 경우, 종료되는 알고리즘이다.

## 문제풀이 코드

```python
# 백준 23815
import sys

def calculate(n1, n2, oper):
    if oper == '+':
        return n1 + n2
    if oper == '-':
        return n1 - n2
    if oper == '*':
        return n1 * n2
    if oper == '/':
        return n1 // n2

# N : 선택지의 개수(1 <= N <= 100000)
# queries : 2개의 선택지 모음
# queries[i] = [q1, q1]
# 각 선택지는 +x, -x, *x, /x중 하나로 주어진다(1 <= x <= 9)
def solution(N, queries):
    # dp[i][0] : 한 번도 건너뛰기를 하지 않았을 때의 최대값
    # dp[i][1] : 건너뛰기를 했을 때의 최대값
    dp = [[-10] * 2 for _ in range(N+1)]
    dp[0][0] = 1
    for i in range(1, N+1):
        query1, query2 = queries[i-1]

        o1 = query1[0]
        n1 = int(query1[1])
        o2 = query2[0]
        n2 = int(query2[1])
        # 사용하는 방법
        # 1. 이전에 건너뛰기 한 적이 없음
        # 2. 이전에 건너뛰기를 했음 -> 이번에 무조건 골라야 함
        dp[i][1] = max(dp[i-1][0], calculate(dp[i-1][1], n1, o1), calculate(dp[i-1][1], n2, o2))

        if dp[i-1][0] > 0:
            dp[i][0] = max(calculate(dp[i-1][0], n1, o1), calculate(dp[i-1][0], n2, o2))
        if max(dp[i]) <= 0:
            return 'ddong game'
    return max(dp[N])

N = int(input())
queries = list(input().split() for _ in range(N))
print(solution(N, queries))
```

```java


```
