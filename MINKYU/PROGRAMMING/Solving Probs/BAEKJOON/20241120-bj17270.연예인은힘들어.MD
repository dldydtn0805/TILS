# 백준 문제 풀이

## bj 17270. 연예인은 힘들어(2024-11-20)

## 문제 설명

연예인 김영광을 너무 닮아서 길거리에서 매번 사진이 찍히는 지헌이는 사람들에게 노출되는 것을 매우 꺼려한다. 하지만 친구인 성하와 약속을 하면 성하는 매번 늦기 때문에 길거리에 나온 지헌이는 매번 성하를 기다린다. 약속 장소에서 성하에게 전화를 하면 매번 “가는 중” 이라는 대답만 듣고 기다리는 동안 길거리에서 사람들에게 사진을 찍히는 지헌이는 스트레스를 심하게 받고 있다. 참지 못한 지헌이는 성하의 핸드폰을 해킹하여서 항상 어디 있는지 알 수 있게 되었다.

스트레스가 심해진 지헌이는 성하와의 약속 장소를 바꾸려고 한다. 그 위치는 다음과 같은 조건을 순서대로 만족해야 한다. 장소의 번호는 1부터 차례대로 붙어 있다.

1. 지헌이의 출발 위치와 성하의 출발 위치는 새로운 약속 장소가 될 수 없다.
2. 성품도 훌륭한 지헌이는 새로운 약속 장소는 지헌이가 걸리는 최단 시간과 성하가 걸리는 최단 시간의 합이 최소가 되도록 하고 싶다.
3. 지헌이가 더 늦게 도착하면 성하에게 안좋은 소리를 들을 것이 뻔하기에, 1번과 2번 조건을 만족하는 장소 중에서도 지헌이가 성하보다 늦게 도착하는 곳은 약속 장소가 될 수 없다.
4. 위의 세 조건을 모두 만족하는 약속 장소가 여러 곳이 있다면, 그 중에 지헌이로부터 가장 가까운 곳이 최종 약속 장소가 된다. 그런 장소도 여러 곳이 있다면, 그 중에 번호가 가장 작은 장소가 최종 약속 장소가 된다.

연예인을 닮아서 고통받는 지헌이를 위해 새로운 약속장소를 찾아주자.

## 입력

첫 번째 줄에는 약속 장소 후보의 수 V와 약속 장소를 연결하는 총 길의 수 M이 주어진다. (2 ≤ V ≤ 100, 1 ≤ M ≤ 1,000)
그리고 다음 M개의 각 줄에는 a, b, c 가 주어진다. a, b는 길의 시작과 끝이며 c는 그 길을 지나가는 데 걸리는 시간을 나타낸다.
(1 ≤ a, b ≤ V, c는 10,000이하의 자연수, 길은 양방향이다)
그리고 그 다음 줄에는 지헌이의 위치 J 와 성하의 위치 S 가 주어진다. (1 ≤ J, S ≤ V)
지현이와 성하가 항상 만날 수 있는 입력만 주어진다.

## 출력

연예인을 닮아서 고통받는 지헌이를 위한 이상적인 약속 장소의 위치를 출력한다. 만약 조건을 만족하는 약속 장소가 없다면 -1을 출력하라.

## 문제풀이

문제의 난이도가 골드 3인 것에 의아해 하며 문제를 풀었다. 골드 3인 이유가 있었다. 문제가 굉장히 불친절했고, 심지어 문제 풀이에 가장 중요한 조건(주어진 조건을 순서대로 만족하는 결과를 구하는 것)에 대한 얘기가 없었다. 알고리즘 적용을 위해 백준을 적극적으로 활용하고, 많은 풀이자들과 내 풀이를 비교하며 큰 도움을 받고 있지만, 이런 문제는 좀 걸러줬으면 하는 바람이 있다. 약 3시간 동안 잡고 못 풀어서 질문 게시판을 확인하고 나서 알게 되었다. 내 시간이 너무 아깝다...
다익스트라, 또는 플루이드 워셜을 통해 J - S 사이의 최소 시간을 구한 후, 해당 시간을 만족하는 중간 경로들(J, S 제외)에 대하여 J까지의 거리가 S까지의 거리보다 작거나 같은 중간 경로들 중 가장 번호가 작은 경로를 결과값으로 내어놓았다.

## 문제풀이 코드

```python
# 백준 17270. 연예인은 힘들어
import sys
import heapq
input = sys.stdin.readline

def solution():
    # V : 약속 장소 후보의 수(2 <= V <= 100)
    # M : 약속 장소를 연결하는 총 길의 수(1 <= M <= 1000)
    V, M = map(int, input().rstrip().split())

    edges = [[int(1e9)] * (V+1) for _ in range(V+1)]
    for i in range(V+1):
        edges[i][i] = 0

    for _ in range(M):
        # a - b 사이의 길은 c만큼의 시간이 걸림
        a, b, c = map(int, input().rstrip().split())
        edges[a][b] = min(edges[a][b], c)
        edges[b][a] = min(edges[b][a], c)

    # J : 지헌의 위치
    # S : 성하의 위치
    J, S = map(int, input().rstrip().split())
    # print(V, M, graph)
    for k in range(1, V+1):
        for i in range(1, V+1):
            for j in range(1, V+1):
                edges[i][j] = min(edges[i][j], edges[i][k] + edges[k][j])
    min_val = int(1e9)
    result = []
    time = int(1e9)
    for i in range(1, V+1):
        if i == J or i == S:
            continue
        min_val = min(min_val, edges[J][i] + edges[i][S])
    for i in range(1, V+1):
        if i == J or i == S:
            continue
        if min_val == edges[J][i] + edges[i][S] and edges[J][i] <= edges[i][S] and time > edges[J][i]:
            time = edges[J][i]
    for i in range(1, V+1):
        if i == J or i == S:
            continue
        if min_val == edges[J][i] + edges[i][S] and time == edges[J][i]:
            result.append(i)
    if result:
        print(result[0])
    else:
        print(-1)
    '''
    1. 지헌이의 출발 위치와 성하의 출발 위치는 새로운 약속 장소가 될 수 없다.
    2. 새로운 약속 장소는
    - 지헌이가 걸리는 최단 시간
    - 성하가 걸리는 최단 시간
    - 의 합이 최소가 되도록 하고 싶다.
    3. 1번과 2번 조건을 만족하는 장소 중에서도
    - 지헌이가 성하보다 늦게 도착하는 곳은 약속 장소가 될 수 없다.
    4. 위의 세 조건을 모두 만족하는 약속 장소가 여러 곳이 있다면
    - 그 중에 지헌이로부터 가장 가까운 곳이 최종 약속 장소가 된다.
    - 그런 장소도 여러 곳이 있다면, 그 중에 번호가 가장 작은 장소가 최종 약속 장소가 된다.
    '''

solution()
```
