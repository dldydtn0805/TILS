# 백준 문제 풀이

## bj 22944. 죽음의 비(2025-08-22)

## 문제 유형

1. Breath First Search

## 문제 설명

가로, 세로 길이가 N인 정사각형 격자가 있다. 해당 격자에는 두 곳을 제외한 모든 곳에 체력을 1씩 감소시키는 죽음의 비가 내리고 있다. 죽음의 비가 안내리는 곳은 현재 있는 위치와 안전지대라는 곳이다. 현재 있는 위치에도 곧 비가 내릴 예정이라 빨리 이 죽음의 비를 뚫고 안전지대로 이동해야한다.

다행히도 격자에는 죽음의 비를 잠시 막아주는 우산이 K개 존재한다. 우산에는 내구도 D라는 개념이 존재한다. 우산에 비를 맞으면 내구도가 1씩 감소하고, 내구도가 0이 되는 순간 우산은 사라진다. 문제에서 주어지는 우산의 내구도는 모두D로 동일하다.

격자에서 이동을 할 때 다음과 같이 순서로 진행된다.

1. 상하좌우로 이동한다. 만약 이동할 곳이 격자 밖이라면 이동할 수 없다.
2. 이동한 곳이 안전지대라면 반복을 종료한다.
3. 이동한 곳에 우산이 있다면 우산을 든다. 만약, 이동할 때부터 우산을 가지고 있다면 가지고 있는 우산을 버리고 새로운 우산으로 바꾼다. 버린 우산은 더 이상 사용할 수 없다.
4. 죽음의 비를 맞았을 때, 우산을 가지고 있다면 우산의 내구도가 1이 감소하고 만약 우산을 가지고 있지 않는다면 체력이 1 감소한다.
5. 만약 우산의 내구도가 0이 되면 들고 있는 우산이 사라진다.
6. 만약 체력이 0이 되면 죽는다...
7. 아직 체력이 남았다면 안전지대까지 위 과정을 반복한다.

현재 있는 위치에서 안전지대로 얼마나 빠르게 이동할 수 있는지 구해주자.

## 입력

첫 번째 줄에 정사각형 격자의 한변의 길이인 N와 현재 체력 H, 우산의 내구도 D가 공백으로 구분되어 주어진다.

다음 N개의 줄에는 정사각형 격자의 정보가 N개의 문자로 붙어서 주어진다. 이때 주어지는 문자는 우산은 "U", 현재 있는 위치 "S", 안전지대 "E", 빈 칸 "."만 존재한다. 현재 있는 위치 "S"와 안전지대 "E"는 반드시 1개 존재한다.

## 제한

4 ≤ N ≤ 500

1 ≤ H ≤ 10,000

1 ≤ D ≤ 5,000

주어지는 모든 수는 정수이다.

## 출력

안전지대로 이동할 때 최소 이동 횟수를 출력한다. 만약 안전지대로 이동하지 못하는 경우에는 -1을 출력한다.

## 문제풀이

꽤나 불친절하고 까다로운 bfs 문제이다. 각 상황에 대한 현재 체력, 우산의 내구도(없을 경우 0), 이동 횟수를 가지고 문제를 해결해야 한다.

만약, 현재 방문한 지점이 우산이 있을 경우, 우산을 새것으로 교체한다. 이후 우산의 내구도를 1 감소시킨다.

만약, 현재 방문한 지점이 비가 내릴 경우, 우산의 내구도가 남아있으면 우산의 내구도를 1 감소시킨다. 우산의 내구도가 0이고, 체력이 1보다 클 경우, 체력을 감소시킨다.

만약, 현재 방문한 지점이 안전지대일 경우, 비가 내리지 않기 때문에 감소 없이 이동 횟수만 증가시킨다.

이 과정에서, 방문할 지점에서 가진 체력과 내구도 합이 현재 가진 체력과 내구도 합보다 커야 이동 가능하다. 더 좋은 조건으로 이미 방문했을 경우, 해당 지점을 방문하지 못한다.

우산이 없어지는 조건, 내구도와 체력의 감소 조건 및 선행 관계 등 많은 조건을 고려해야 하는 문제여서 꽤나 힘들었다..

문제가 이해되지 않는다면 질문 게시판을 천천히 읽어보고, 반례를 반드시 찾아봐야 한다!

## 문제풀이 코드

```python
import sys
from collections import deque

def solution(N, H, D, arr):
    def find_start():
        for i in range(N):
            for j in range(N):
                if arr[i][j] == 'S':
                    return i, j
        return -1, -1
    si, sj = find_start()
    que = deque()
    visited = [[0] * N for _ in range(N)]

    que.append((si, sj, H, 0, 0))
    visited[si][sj] = H
    cases = []
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while que:
        i, j, h, d, cnt = que.popleft()

        for di, dj in dir:

            ni = i + di
            nj = j + dj
            if not (0 <= ni < N and 0 <= nj < N):
                continue
            if arr[ni][nj] == 'E':
                return cnt+1
            if h == 0:
                continue
            if arr[ni][nj] == 'U':
                if visited[ni][nj] < h+D-1:
                    que.append((ni, nj, h, D-1, cnt+1))
                    visited[ni][nj] = h+D-1
            else:
                if d > 0:
                    if visited[ni][nj] < h+d-1:
                        que.append((ni, nj, h, d-1, cnt+1))
                        visited[ni][nj] = h+d-1
                elif h-1 > 0 and visited[ni][nj] < h+d-1:
                    que.append((ni, nj, h-1, d, cnt+1))
                    visited[ni][nj] = h+d-1
    return -1

N, H, D = map(int, input().split())
arr = [input() for _ in range(N)]
print(solution(N, H, D, arr))
```

```java


```
