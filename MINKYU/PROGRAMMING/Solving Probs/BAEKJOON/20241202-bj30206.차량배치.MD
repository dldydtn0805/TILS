# 백준 문제 풀이

## bj . (2024-10-28)

## 문제 설명

올해 국군의 날의 행사에 시가행진 행사도 계획되었다. 그래서 시가행진에 동원된 차량을 통솔해야 하는 김 중위는 차들이 어디서 대기하다가 시가행진에 진입하게 할지를 계획하게 되었다.

김 중위는 시가행진을 시작하기 전, 시가행진에 동원된 차량을 여러 지점에 적절히 배치할 수 있다. 단, 최소 한 대의 차량이 동원되며, 배치가 가능하다면 더 동원할 수 있다. 차량의 배치가 가능한 지점들은 총 N개로, 1번부터 N번까지 번호들이 매겨져 있으며 각 지점에는 차량을 최대 한 대만 배치할 수 있다. 또한, M개의 양방향 도로들을 통해서 지점 사이를 이동할 수 있다. 하나의 도로를 지나는 데에 1분이 걸린다. 시가행진이 시작되는 장소는 1번 지점을 거쳐서만 들어갈 수 있으며, 1번 지점에도 차량을 배치할 수 있다.

차량의 배치가 끝나면 1번 지점에 있던 차량은 바로 시가행진 행사에 들어가서 사라지고, 모든 차량은 1번 지점으로 이동하기 시작한다. 이때, 모든 차량은 최단 경로를 통해 동일한 속도로 이동하며, 만약 최단 경로가 여러 가지라면 그 중 다음으로 가는 정점의 번호가 작은 경로를 따라 이동한다. 이후에 1번 지점에 무사히 도착한 차량은 직후 시가행진 행사에 들어가서 사라진다. 다만 두 차량이 같은 시간에 1번 지점을 포함한 같은 지점에 도달하면 충돌 사고가 난다.

김 중위를 도와서 지점들을 잇는 도로들이 주어졌을 때, 충돌 사고가 나지 않는 차량 배치 방법의 개수를 1,000,000,007(= 10^9+7)으로 나눈 나머지를 구해보자. 1,000,000,007은 소수이다.

## 입력

첫 번째 줄에 지점의 개수 N과 도로의 개수 M이 공백으로 구분되어 정수로 주어진다. (1 <= N <= 200,000, N-1 <= M <= min(N(N-1)/2, 200,000))

이후 M개의 줄에 걸쳐 각 도로가 잇는 서로 다른 두 지점을 나타내는 정수 a, b가 공백으로 구분되어 정수로 주어진다. (1 <= a,b <= N, a != b)

임의의 두 지점마다, 둘을 잇는 도로는 최대 하나이다. 또한, 모든 지점에서 1번 지점으로 이동할 수 있다.

## 출력

충돌 사고가 나지 않는 차량 배치 방법의 개수를 1,000,000,007로 나눈 나머지를 출력한다.

## 문제풀이

문제가 길다. 결국 요약하자면, 주어진 노드들에 대하여, 1번 노드(시작 위치)로부터 각 노드별 최단 거리를 구한 후, 같은 거리에 위치한 노드들은 그 중 최대 한 개의 노드만 선정하는 방식으로 하여 모든 경우의 수를 구하는 것이었다.
따라서, bfs로 visited를 구하고(visited[i] : 1번 노드에서 i번 노드로 가는데 걸리는 최단 시간), 각 dist의 개수들을 파악하여 이를 통해 dist 개수가 1이 넘을 경우(여러 노드가 동일 시간이 걸리는 경우), 해당 위치에서는 총 (dist+1)의 경우의 수(모두 안 가는 방법 + 하나만 가는 방법) 이 존재한다. 1인 경우(한 노드만 해당 시간이 걸리는 경우)에는 가는 경우, 안가는 경우 2 가지가 존재한다.
마지막으로 모두 안 가는 경우인 1을 빼면 문제가 해결된다.

## 문제풀이 코드

```python
# 백준 30206. 차량 배치
import sys
from collections import deque, defaultdict

def bfs(N, M, graph):
    que = deque()
    visited = [-1] * (N+1)
    que.append(1)
    visited[1] = 0
    dist = defaultdict(int)

    while que:
        now = que.popleft()
        dist[visited[now]] += 1

        for next in graph[now]:
            if visited[next] == -1:
                que.append(next)
                visited[next] = visited[now] + 1

    return dist

def solution():
    # N : 지점의 개수(1 <= N <= 200000)
    # M : 도로의 개수(N-1 <= M <= min(N(N-1)//2, 200000))
    N, M = map(int, input().split())

    graph = [[] for _ in range(N+1)]
    for _ in range(M):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    dist = bfs(N, M, graph)
    result = 1
    for num in dist.keys():
        result *= (dist[num]+1)
        result %= 1000000007
    print(result-1)

solution()
```
