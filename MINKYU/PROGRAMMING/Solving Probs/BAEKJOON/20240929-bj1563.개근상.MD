# 백준 문제 풀이
## bj 1563. 개근상(2024-09-29)

## 문제 설명

    백준중학교에서는 학기가 끝날 무렵에 출결사항을 보고 개근상을 줄 것인지 말 것인지 결정한다. 이 학교는 이상해서 학생들이 학교를 너무 자주 빠지기 때문에, 개근상을 주는 조건이 조금 독특하다.
    출결사항이 기록되는 출결은 출석, 지각, 결석이다.

    개근상을 받을 수 없는 사람은 지각을 두 번 이상 했거나, 결석을 세 번 연속으로 한 사람이다.

    한 학기가 4일이고, O를 출석, L을 지각, A를 결석이라고 했을 때, 개근상을 받을 수 있는 출결정보는

        OOOO OOOA OOOL OOAO OOAA OOAL OOLO OOLA OAOO OAOA 
        OAOL OAAO OAAL OALO OALA OLOO OLOA OLAO OLAA AOOO 
        AOOA AOOL AOAO AOAA AOAL AOLO AOLA AAOO AAOA AAOL
        AALO AALA ALOO ALOA ALAO ALAA LOOO LOOA LOAO LOAA 
        LAOO LAOA LAAO

    총 43가지이다.
    한 학기는 N일이다. N이 주어졌을 때, 개근상을 받을 수 있는 출결정보의 개수를 세는 프로그램을 작성하시오.

## 입력
    첫째 줄에 N이 주어진다. N은 1,000보다 작거나 같다.

## 출력
    첫째 줄에 정답을 1,000,000으로 나눈 나머지를 출력한다.

## 문제풀이

    전형적인 DP 문제이다. N일 동안 개근상을 받을 수 있는 경우의 수를 구하는 문제로, 개근상을 받지 못하는 경우는 다음과 같다.

        1. N일동안 2번 이상 지각하는 경우
        2. N일동안 3일 연속 결석하는 경우

    즉, 각 일수 별로
        - 0번 지각, 0번 연속 결석
        - 0번 지각, 1번 연속 결석
        - 0번 지각, 2번 연속 결석
        - 1번 지각, 0번 연속 결석
        - 1번 지각, 1번 연속 결석
        - 1번 지각, 2번 연속 결석
    인 경우의 수를 구해야 한다.
    
    따라서, dp는 일차를 나타내는 i, 지각 횟수를 나타내는 j, 연속 결석 일수를 나타내는 k로 이루어진 삼차원 배열 형태이다.
    
    dp[i][j][k] = i일차에 j번 지각, k번 연속 결석한 경우의 수
    - i일차는 결국 i-1일차의 경우의 수에 대해 영향을 받는다
    - 그리고 i-1일차의 지각횟수, 연속결석횟수에도 영향을 받는다
    - 1일차 가능한 경우의 수 : 출석 or 지각 or 1일 연속 결석 

    이것을 토대로 점화식을 구성한다면, 다음과 같다.
    0. 1일차의 경우
    dp[1][0][0] = 1
    dp[1][1][0] = 1
    dp[1][0][1] = 1
    
    1. i일차에 0번 지각, 0번 연속 결석 = (i-1)일차에 0번 지각, 모든 연속 결석 + 오늘 출석
    dp[i][0][0] = dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2]

    2. i일차에 0번 지각, 1번 연속 결석 = (i-1)일차에 0번 지각, 0번 연속 결석 + 오늘 결석
    dp[i][0][1] = dp[i-1][0][0]
    
    3. i일차에 0번 지각, 2번 연속 결석 = (i-1)일차에 0번 지각, 1번 연속 결석 + 오늘 결석
    dp[i][0][2] = dp[i-1][0][1]
    
    4. i일차에 1번 지각, 0번 연속 결석 = (i-1)일차에 0번 지각, 모든 연속 결석 + 오늘 지각 or (i-1)일차에 1번 지각, 모든 연속 결석 + 오늘 출석 
    dp[i][1][0] = dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2] + dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2]
    
    5. i일차에 1번 지각, 1번 연속 결석 = (i-1)일차에 1번 지각, 0번 연속 결석 + 오늘 결석
    dp[i][1][1] = dp[i-1][1][0]

    6. i일차에 1번 지각, 2번 연속 결석 = (i-1)일차에 0번 지각, 1번 연속 결석 + 오늘 결석
    dp[i][1][2] = dp[i-1][1][1]

## 문제풀이 코드

```python
# 백준 1563. 개근상
import sys
input = sys.stdin.readline

# N : 한 학기 일수(0 <= N <= 1000)
N = int(input().rstrip())
'''
개근상을 받을 수 없는 경우
- 지각 2번 이상
- 결석 세 번 연속
'''
# dp[i][j][k] : i일차까지 지각 j, 연속 결석 k
dp = [[[0] * 3 for _ in range(2)] for _ in range(N+1)]
dp[1][0][0] = 1
dp[1][0][1] = 1
dp[1][1][0] = 1

# dp[i][0][0] :
# dp[i][0][1]
for i in range(2, N+1):
    # i일차 0지 0결 = i-1일차 0지
    dp[i][0][0] = sum(dp[i-1][0])
    # i일차 0지 1결 = i-1일차 0지 0결 + 오늘결석
    dp[i][0][1] = dp[i-1][0][0]
    # i일차 0지 2결 = i-1일차 0지 1결 + 오늘결석
    dp[i][0][2] = dp[i-1][0][1]

    # i일차 1지 0결 = i-1일차 0지 + 오늘지각 or i-1일차 1지
    dp[i][1][0] = sum(dp[i-1][0]) + sum(dp[i-1][1])
    # i일차 1지 1결 = i-1일차 1지 + 오늘결석
    dp[i][1][1] = dp[i-1][1][0]
    # i일차 1지 2결 = i-1일차 1지 1결 + 오늘결석
    dp[i][1][2] = dp[i-1][1][1]
# 목표 : N일차 0지 0결, 0지 1결, 0지 2결, 1지 0결, 1지+1결, 1지+2결,
print((sum(dp[N][0]) + sum(dp[N][1])) % 1000000)
```