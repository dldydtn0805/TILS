# 백준 문제 풀이

## bj 괄호. (2025-01-19)

## 문제 설명

‘(‘, ‘)’ 문자로만 이루어진 문자열을 괄호 문자열이라 한다. 올바른 괄호 문자열이란 다음과 같이 정의된다. ()는 올바른 괄호 문자열이다. S가 올바른 괄호 문자열이라면, (S)도 올바른 괄호 문자열이다. S와 T가 올바른 괄호 문자열이라면, 두 문자열을 이어 붙인 ST도 올바른 괄호 문자열이다. (()())()은 올바른 괄호 문자열이지만 (()은 올바른 괄호 문자열이 아니다. 괄호 문자열이 주어졌을 때 올바른 괄호 문자열인지 확인하는 방법은 여러 가지가 있다.

하지만 우리가 궁금한 것은 길이가 L인 올바른 괄호 문자열의 개수이다. 길이 L이 주어졌을 때 길이가 L인 서로 다른 올바른 괄호 문자열의 개수를 출력하는 프로그램을 만들어 보자.

## 입력

첫 번째 줄에 테스트케이스의 개수를 나타내는 T (1 ≤ T ≤ 100)가 주어진다. 두 번째 줄부터 각 테스트케이스마다 괄호 문자열의 길이를 나타내는 L이 주어진다. (1 ≤ L ≤ 5000)

## 출력

각 테스트 케이스에 대해 길이가 L인 올바른 괄호 문자열의 개수를 1,000,000,007로 나눈 나머지를 출력하시오.

## 문제풀이

dp 문제이다. 처음에는 (T)와 S+T의 경우의 수를 나누어서 구해야겠다는 생각을 했다. 하지만, 처음 시작이 무조건 `(`라는 이유로, 해당 열린 괄호와 쌍을 이루는 닫는 괄호의 위치를 정해야 한다는 사실을 깨달았다.

- 시작 열린 괄호 `(`와 쌍을 이루는 닫는 괄호 `)`의 위치를 선정한다
- 선정된 위치에 따라 해당 괄호 쌍 안의 길이, 바깥의 길이를 구분하여 dp를 갱신한다

찾아보니, 카탈린의 수라는 알고리즘이 있었다. 주어진 n에 대하여, 한 가지 경우를 시행할 경우 그와 쌍이 되는 다른 경우를 반드시 시행하는 모든 경우의 수를 구하는 것이다. 식은 다음과 같다.

- f(N) = 2N! / (N! \* (N+1)!)

## 문제풀이 코드

```python
# 백준 10422. 괄호
import sys

# dp[i] : 길이가 i인 올바른 괄호 문자열의 개수
dp = [0] * 5001
dp[0] = 1
for i in range(2, 5001, 2):
    '''
    j : 첫 번째 괄호를 닫는 위치
    - (...)...
    - 0...j
    - (j-2) * (i-j)
    '''
    for j in range(2, i+1, 2):
        dp[i] += dp[j-2] * dp[i-j]
    dp[i] %= 1000000007

'''
dp[0]
- X

dp[2]
- ()

dp[4]
- () + ()
- ( () )

dp[6]
- () + ()()
- () + (())
- ()() + () ----> 겹침
- (()) + ()
- ( ()() )
- ( (()) )

dp[8]
- (0) + 6
- (2) + 4
- (4) + 2
- (6)
'''
def solution():
    # L : 괄호 문자열의 길이(1 <= L <= 5000)
    L = int(input())
    '''
    1. ()은 올바른 괄호 문자열
    2. S가 올바른 괄호 문자열 -> (S)도 올바른 괄호 문자열
    3. S, T가 올바른 괄호 문자열 -> ST도 올바른 괄호 문자열
    '''
    print(dp[L])

T = int(input())
for tc in range(T):
    solution()
```
