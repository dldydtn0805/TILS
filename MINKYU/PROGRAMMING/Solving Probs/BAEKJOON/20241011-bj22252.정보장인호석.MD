# 백준 문제 풀이
## bj 22252. 정보 장인 호석(2024-10-11)

## 문제 설명
    암흑가의 권력은 주먹과 정보에서 나온다. 주먹은 한 명에게 강하고, 정보는 세계를 가지고 놀 수 있기 때문에 호석이는 세상 모든 정보를 모으는 "정보 상인"이 되고 싶다. 정보 상인은 정보를 사고파는 사람을 의미한다.
    호석이는 아직 상인계의 새싹이기 때문에, 초기 투자를 통해서 여러 명의 "정보 고릴라"들로부터 정보를 모으려고 한다. 정보 고릴라란 여기저기서 정보를 수집하는 사람들을 의미한다. 일단 정보를 긁어모으기 위해서 호석이는 여러 정보 고릴라들에게 정보를 구매하려고 한다.
    암흑가의 연락망은 빼곡하기 때문에 누가 어떤 정보를 얻었는지에 대한 찌라시들이 수시로 퍼진다. 찌라시로 알 수 있는 것은, 어떤 이름을 가진 고릴라가 C1, C2, ..., Ck 만큼의 가치가 있는 정보 k 개를 얻었다는 점이다.

    호석이는 이를 바탕으로 임의의 시점에 특정 고릴라에게 정보를 몇 개 살 것인지를 정할 수 있다. 이때 가치 순으로 가장 비싼 정보들을 구매한다. 예를 들어 고릴라가 가진 정보가 10개이고, 호석이가 사고 싶은 정보 개수가 4개라면, 고릴라는 10개 중에서 가치 순으로 가장 비싼 4개를 팔 것이다. 한 번 거래한 정보는 호석이에게 더 이상 가치가 없기 때문에 고릴라도 그 정보를 파기한다.
    당신은 암흑가의 주먹이며 양대 산맥이 될 가능성이 있는 호석이를 주시하고 있다. 관찰하면서 얻은 정보는 총 Q개이다. 각 정보는 다음의 2가지 중 하나이다.

        1 Name k C1, C2,..., Ck : 이름이 Name인 고릴라가 k개의 정보를 얻었으며, 각 가치는 
        C1부터 Ck이다.
        2 Name b : 호석이가 이름이 Name인 고릴라에게 
        b개의 정보를 구매한다. 이때 고릴라가 가진 정보들 중 가장 비싼 b개를 구매하며, 고릴라가 가진 정보가 b개 이하이면 가진 모든 정보를 구매한다.
    
    견제를 위해서 호석이가 가진 정보들의 가치 총합, 즉 호석이가 정보들을 구매하는 데에 쓴 돈의 총합을 구하자.

## 입력
    고릴라들이 정보를 얻는 사건과 호석이가 거래하는 정보가 시간순으로 주어진다. 첫 번째 줄에는 쿼리의 개수 Q(1 <= Q <= 100000)가 주어진다.이어서 Q개의 줄에 걸쳐서 각 줄에 쿼리가 주어진다. 쿼리는 1이나 2로 시작한다. 1로 시작하는 경우에는 정보를 얻은 정보 고릴라의 이름과 k(1 <= k <= 100000)가 주어지며 이어서 k개의 정보 가치 C1, ..., Ck가 자연수로 주어진다. 모든 Ci는 1 이상 100,000 이하이다. 2로 시작하는 경우에는 호석이가 거래하려는 정보 고릴라의 이름과 구매하려는 정보의 개수 b(1 <= b <= 100000)가 주어진다. 

## 출력
    모든 쿼리가 종료되었을 때에 호석이가 얻게 되는 정보 가치의 총합을 출력하라.

## 문제풀이
    2라는 커맨드를 받았을 때, 계속해서 특정 개수만의 최대값을 뽑아내야 하는 문제였기에 정렬을 가장 먼저 떠올렸다. 하지만, 1과 2를 반복할 때 마다 정렬을 할 수는 없기에 heapq 모듈을 활용하여 문제를 해결했다. 특히, 최대 힙 구조를 만들어야 하기 때문에 음수 값을 집어넣어 마지막에 -1을 곱하였다.
    
## 문제풀이 코드
```python
# 백준 22252. 정보 상인 호석
import sys
import heapq
from collections import defaultdict
input = sys.stdin.readline

# Q : 쿼리의 개수(1 <= Q <= 100000)
Q = int(input().rstrip())

result = 0
dictionary = defaultdict(list)
for _ in range(Q):
    '''
    쿼리
    1로 시작 : 1 고릴라 k k개의정보가치
    2로 시작 : 2 고릴라 구매하려는정보개수
    '''
    lst = list(input().rstrip().split())
    num = int(lst[0])
    name = lst[1]
    if num == 1:
        for i in range(3, len(lst)):
            heapq.heappush(dictionary[name], -int(lst[i]))
            # dictionary[name].append(lst[i])
    elif num == 2:
        b1 = int(lst[2])
        b2 = len(dictionary[name])
        for i in range(min(b1, b2)):
            result += heapq.heappop(dictionary[name])
print(-result)
```