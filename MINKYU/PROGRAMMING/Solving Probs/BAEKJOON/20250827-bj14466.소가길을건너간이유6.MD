# 백준 문제 풀이

## bj . (2025-)

## 문제 유형

1. Breath First Search

## 문제 설명

소가 길을 건너간 이유는 그냥 길이 많아서이다. 존의 농장에는 길이 너무 많아서, 길을 건너지 않고서는 별로 돌아다닐 수가 없다.

존의 농장에 대대적인 개편이 있었다. 이제 작은 정사각형 목초지가 N×N (2 ≤ N ≤ 100) 격자로 이루어져 있다. 인접한 목초지 사이는 일반적으로 자유롭게 건너갈 수 있지만, 그 중 일부는 길을 건너야 한다. 농장의 바깥에는 높은 울타리가 있어서 소가 농장 밖으로 나갈 일은 없다.

K마리의 (1 ≤ K ≤ 100,K ≤ N2) 소가 존의 농장에 있고, 각 소는 서로 다른 목초지에 있다. 어떤 두 소는 길을 건너지 않으면 만나지 못 할 수 있다. 이런 소가 몇 쌍인지 세어보자.

## 입력

첫 줄에 N, K, R이 주어진다. 다음 R줄에는 한 줄에 하나씩 길이 주어진다. 길은 상하좌우로 인접한 두 목초지를 잇고, r c r′ c′의 형태 (행, 열, 행, 열)로 주어진다. 각 수는 1 이상 N 이하이다. 그 다음 K줄에는 한 줄의 하나씩 소의 위치가 행과 열로 주어진다.

## 출력

길을 건너지 않으면 만날 수 없는 소가 몇 쌍인지 출력한다.

## 문제풀이

bfs 문제이다. 건너갈 수 있는 길을 오히려 벽 취급하면 된다. 특정 위치에서 인접한 위치로 갈 때, 그 사이에 길이 있다면, 그 길을 이용하지 않으면 된다(벽이 있다고 생각하고, 해당 위치로 가지 않으면 된다.)

그렇게 각 소의 위치에서 길을 이용하지 않고 갈 수 있는 다른 소들까지의 위치를 구하면 된다.

## 문제풀이 코드

```python
# 백준 14466
import sys
from collections import deque, defaultdict

# N : 목초지의 크기(2 <= N <= 100)
# K : 소의 개수(1 <= K <= min(100, N**2)
# R : 길의 개수(
# loads[(i, j)] : (i, j)와 연결된 위치
# cows[i] = (r, c) : i번 소의 위치
def solution(N, K, R, loads, cows):
    result = 0
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # (y, x)에 위치한 소와 만나는 소들에 대한 정보
    def bfs(c):
        y, x = cows[c]
        que = deque()
        visited = [[0] * (N+1) for _ in range(N+1)]
        que.append((y, x))
        visited[y][x] = 1
        while que:
            i, j = que.popleft()
            for di, dj in dir:
                ni = i + di
                nj = j + dj
                if not (1 <= ni <= N and 1 <= nj <= N):
                    continue
                if visited[ni][nj] == 1:
                    continue
                if (i, j) in loads.keys() and (ni, nj) in loads[(i, j)]:
                    continue
                que.append((ni, nj))
                visited[ni][nj] = 1
        cnt = 0
        for cc in range(c+1, K):
            r, c = cows[cc]
            if visited[r][c] == 0:
                cnt += 1
        return cnt
    for c1 in range(K):
        y1, x1 = cows[c1]
        result += bfs(c1)
    return result


N, K, R = map(int, input().split())
loads = defaultdict(set)
for _ in range(R):
    r1, c1, r2, c2 = map(int, input().split())
    loads[(r1, c1)].add((r2, c2))
    loads[(r2, c2)].add((r1, c1))
cows = [list(map(int, input().split())) for _ in range(K)]
print(solution(N, K, R, loads, cows))
```

```java


```
