# 백준 문제 풀이

## bj . (2025-)

## 문제 유형

1. Dynamic Programming(DP)

## 문제 설명

일렬로 된 보드가 있다. 맨 왼쪽은 시작점이고, 맨 오른쪽에는 별이 있다. 매 턴마다 플레이어는 1부터 S까지의 자연수가 균일한 확률로 나오는 주사위를 굴린 뒤 나온 수만큼 앞으로 이동한다. 플레이어가 멈춘 칸에는 숫자가 쓰여 있는데, 거기에 쓰인 만큼 (양수일 때) 코인을 얻거나 (음수일 때) 잃는다. T턴이 지나면 게임이 종료된다.

예를 들어 보드가 위와 같고, S=4, T=5라고 하자. 주사위를 굴려서 2, 3, 4, 1, 1이 나오면 총 수익은 170코인이 된다. 반면 주사위를 굴려서 1, 3, 2, 4, 1이 나오면 총 수익은 220코인이 된다. 꼭 별이 있는 칸에 정확히 멈출 필요는 없다. 별이 있는 칸을 지나가면 별을 얻을 수 있기 때문이다.

보드가 안 좋아서 총 수익이 음수가 되어야만 별을 얻을 수도 있다. 아래 보드 (S=4, T=5)의 경우 별을 얻을 때의 최대 수익은 -100코인이다. 하지만 별을 많이 얻는 것이 중요하기 때문에, 플레이어는 코인을 잃는 한이 있어도 별을 얻고 싶어한다.

T턴 이내에 별을 얻고자 할 때, 최대 수익은 얼마일까?

## 입력

입력은 20개 이하의 테스트케이스로 구성되어 있고, 맨 끝에 0이 온다. 각 테스트케이스의 첫 줄에는 N (출발점과 별 사이의 칸 수), S, T가 주어진다. 2 ≤ N ≤ 200, 2 ≤ S ≤ 10, N + 1 ≤ ST, T ≤ N + 1이다. 따라서 T턴 이내에 별을 먹는 방법이 꼭 존재한다.

첫 줄 다음에는 여러 줄에 걸쳐 N개의 정수가 주어진다. 각 칸에 도착할 때 얻거나 잃는 코인의 수를 나타낸다. 이 값의 절댓값은 10000보다 작다.

## 출력

각 테스트케이스에 대해 T턴 이내에 별을 얻을 때의 최대 수익을 출력한다.

## 문제풀이

T턴 이하의 턴 내에서 주어진 배열 밖으로 나갔을 때 얻을 수 있는 최대 점수를 구하는 문제이다. 입력 방법이 너무 짜증나는 문제였다.

dp를 i번째 턴에 출발 위치로부터 j만큼 갔을 때의 가능한 최대 점수를 담았다.

초기화는 0번째 턴에 0만큼 갔을 때는 0이므로, dp[0][0]을 0으로 하면 된다.

각 i, j에 대해, 주어진 주사위를 굴려서 나온 1 ~ S 사이의 숫자 s를 활용하여 i-1번째 턴에 j에 위치할 경우의 수가 존재할 경우, 이후 i번째 턴에는 j+s에 위치할 수 있으므로 갱신하면 된다. 이 때, j+s가 주어진 배열 밖으로 나가게 될 경우, 최대값과 비교하며 갱신하면 된다.

오랜만에 보는 top-down dp 형태라서 조금 어려웠다.

## 문제풀이 코드

```python
# 백준 14550
import sys

# N : 출발점과 별 사이의 칸 수(2 <= N <= 200)
# S : 주사위에 적힌 칸의 개수(1 ~ S) (2 <= S <= 10)
# T : 주어진 턴
def solution(N, S, T, arr):
    # dp[i][j] : i턴에 j에 있을 때의 최대 코인
    dp = [[-float("inf")] * (N+2) for _ in range(T+1)]
    dp[0][0] = 0
    # dp[i][j]
    for i in range(1, T+1):
        for j in range(N+1):
            if dp[i-1][j] != -float('inf'):
                for s in range(1, S+1):
                    if j + s >= N+1:
                        dp[i][N+1] = max(dp[i][N+1], dp[i-1][j])
                    else:
                        dp[i][j+s] = max(dp[i][j+s], dp[i-1][j] + arr[j+s])
    result = -float('inf')
    for i in range(T+1):
        result = max(result, dp[i][N+1])

    return result
while True:
    info = list(map(int, input().split()))
    if info[0] == 0:
        break
    N, S, T = info
    arr = [0]
    while len(arr) <= N:
        arr.extend(list(map(int, input().split())))
    print(solution(N, S, T, arr))
```

```java


```
