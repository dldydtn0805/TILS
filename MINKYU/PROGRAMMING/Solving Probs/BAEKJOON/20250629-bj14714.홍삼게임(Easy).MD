# 백준 문제 풀이

## bj 14714. 홍삼 게임 (Easy) (2025-06-29)

## 문제 설명

은하는 술과 게임과 술 게임을 좋아한다. 그중에서도 가장 좋아하는 술 게임은 “홍삼 게임”이다. 이 게임은 N명의 사람이 테이블에 원형으로 둘러앉은 상태에서 하는 게임이고, 규칙은 다음과 같다.

1. 은하가 서로 다른 두 사람을 지목한다.
2. 지목당한 두 사람이 동시에 테이블에 앉은 사람들 중 한 사람씩을 골라서 지목한다.
3. 만약 두 사람이 같은 사람을 지목했을 경우 게임이 끝난다. 그렇지 않을 경우 2번으로 돌아간다.

SNUPC가 끝난 뒤 참가자들은 근처 술집으로 뒤풀이를 하러 갔고, 은하의 주도 아래 홍삼 게임을 하게 되었다. 하지만 사람이 너무 많이 모이는 바람에 누가 누굴 지목하는지 잘 보이지 않아서 게임이 수시로 중단되었다. 이 상황을 보다 못한 은하의 친구 은서는 홍삼 게임의 규칙을 수정한 “질서 있는 홍삼 게임”을 제안하였다. 이 게임의 규칙은 다음과 같다.

1. 은하가 서로 다른 두 사람을 순서대로 지목한다. 먼저 지목당한 사람은 지목권 A, 두 번째로 지목당한 사람은 지목권 B를 갖는다.
2. 지목권 A를 가진 사람이 자신의 왼쪽 또는 오른쪽으로 정확히 DA만큼 떨어진 사람 한 명을 지목하여 자신의 지목권을 넘긴다.
3. 만약 지목당한 사람이 이미 지목권 B를 가지고 있었을 경우 게임이 끝난다.
4. 지목권 B를 가진 사람이 자신의 왼쪽 또는 오른쪽으로 정확히 DB만큼 떨어진 사람 한 명을 지목하여 자신의 지목권을 넘긴다.
5. 만약 지목당한 사람이 이미 지목권 A를 가지고 있었을 경우 게임이 끝난다. 그렇지 않을 경우 2번으로 돌아간다.

은서의 제안 덕분에 참가자들은 질서 있게 홍삼 게임을 즐길 수 있게 되었다. 하지만 은하가 몇 시간 내내 계속 홍삼 게임을 돌리자 참가자들은 지쳐 갔고, 은하가 누구를 지목하고 지목 간격을 어떻게 설정하든 최대한 게임을 빠르게 끝내려고 하게 되었다. 불쌍한 뒤풀이 참가자들을 홍삼 지옥에서 구해 주자.

편의를 위해 참가자들에게는 1번부터 N번까지 반시계방향으로 번호가 붙어 있다고 가정한다. 즉 i번 참가자의 바로 왼쪽에는 i − 1번, 바로 오른쪽에는 i + 1번 참가자가 앉아 있다. 예외로 1번 참가자의 바로 왼쪽에는 N번 참가자가, 마찬가지로 N번 참가자의 바로 오른쪽에는 1번 참가자가 앉아 있다.

## 입력

첫 번째 줄에 “질서 있는 홍삼 게임”의 참가자의 수 N(2 ≤ N ≤ 500), 은하가 먼저 지목한 사람의 번호 A와 두 번째로 지목한 사람의 번호 B(1 ≤ A, B ≤ N, A ≠ B), 각 지목권의 지목 간격을 나타내는 정수 DA, DB(1 ≤ DA, DB ≤ N − 1)이 공백을 사이에 두고 순서대로 주어진다.

## 출력

첫 번째 줄에 입력된 게임을 최대한 빠르게 끝내고자 할 때 필요한 최소 지목 횟수를 출력한다. 만약 끝낼 수 없는 게임일 경우 Evil Galazy를 출력한다.

## 문제풀이

bfs 문제이다. 현재 턴이 누구인지(지목권 A를 넘기는 차례인지, 지목권 B를 넘기는 차례인지)에 따라 다른 로직이 발생함을 인지하고, 현재 A와 B의 두 지목권이 같은 사람에게 갈 때 까지 bfs를 진행하면 되는 문제였다. A를 넘기는 차례인지, B를 넘기는 차례인지에 따라 다른 visited의 상태를 체크하고, 새로운 턴을 갱신하면 된다. 순환 배열 형태임을 인지하고, 적절히 지목권을 새롭게 받는 사람을 갱신하는 것이 중요했다.

## 문제풀이 코드

```python
# 백준 14714
import sys
from collections import deque

# N : 게임 참가자의 수(2 <= N <= 500)
# A, B : 은하가 첫 번째 / 두 번째로 지목한 사람 번호(1 <= A, B <= N)
# DA, DB : 각 지목권의 지목 간격(1 <= DA, DB <= N-1)
def solution(N, A, B, DA, DB):
    que = deque()
    visited_a = [[0] * N for _ in range(N)]
    visited_b = [[0] * N for _ in range(N)]
    que.append((A, B, 'A', 0))
    visited_a[A][B] = 1
    while que:
        a, b, turn, cnt = que.popleft()
        if a == b:
            return cnt
        if turn == 'A':
            for da in (-DA, DA):
                na = (a + da + N) % N
                if visited_b[na][b] == 0:
                    que.append((na, b, 'B', cnt+1))
                    visited_b[na][b] = 1

        elif turn == 'B':
            for db in (-DB, DB):
                nb = (b + db + N) % N
                if visited_a[a][nb] == 0:
                    que.append((a, nb, 'A', cnt+1))
                    visited_a[a][nb] = 1

    return 'Evil Galazy'

N, A, B, DA, DB = map(int, input().split())
print(solution(N, A-1, B-1, DA, DB))
```

```java


```
