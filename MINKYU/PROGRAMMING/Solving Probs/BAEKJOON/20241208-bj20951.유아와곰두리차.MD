# 백준 문제 풀이

## bj 20951. 유아와 곰두리차(2024-12-08)

## 문제 설명

유아는 새해를 맞이하여 V.Nets의 자율 주행 자동차를 구매하였다. 유아는 새 차를 타고 바다로 가서 회를 잔뜩 먹고 올 것이다(유아는 감염병 예방을 위한 정부의 방역지침을 준수한다). 고속도로를 달리던 유아는 놀라 자빠질 수밖에 없었다. V.Nets의 자율 주행 시스템이 형편없었기 때문이다. V.Nets에 큰 배신감을 느낀 유아는 직접 자율 주행 자동차를 설계하기로 결심하였다.

곰두리차는 유아가 설계한 자율 주행 자동차이다. 곰두리차는 항상 인접한 정점 중 임의의 정점으로 이동한다. 유아는 출발점에서 도착점까지의 경로가 존재하고 시간이 무한하다면 곰두리차가 언제나 목적지에 도달할 수 있다고 믿고 있다. 유아는 문득 그래프가 주어졌을 때, 곰두리차가 지날 수 있는 경로가 몇 개인지 궁금해졌다.

하지만 유아는 이 문제를 풀지 못하였다. 문제의 난이도를 낮추기 위하여 유아는 경로상에서 동일한 정점 또는 간선을 재방문하는 것을 허용하였다.

그래프가 주어졌을 때, 곰두리차가 지날 수 있는 경로 중 길이가 7인 경로의 개수를 구하는 프로그램을 작성하시오. 곰두리차는 동일한 정점 또는 간선을 여러 번 지날 수 있다.

## 입력

첫 번째 줄에 정점의 개수 N(2 <= N <= 100,000)과 간선의 개수 M(1 <= M <= min(N(N(N-1)/2, 100,000))이 주어진다.

이후 M개의 줄에 걸쳐 간선이 연결하는 두 정점 번호 u, v(1 <= u, v <= N)가 주어진다. 입력으로 주어진 그래프에는 중복 간선이 존재하지 않는다.
주어지는 간선은 양방향 간선이며, 모든 입력은 공백으로 구분되어 주어진다.

## 출력

첫 번째 줄에 곰두리차가 지날 수 있는 경로 중 길이가 7인 경로의 개수를 출력한다. 답이 매우 커질 수 있으므로 10^9 + 7로 나눈 나머지를 출력한다.

## 문제풀이

처음에는 bfs로 접근해야 하는 문제인 줄 알았다. 하지만, N의 범위와 M의 범위, 또 모든 노드에서 출발하여 구해야 한다는 이유 때문에 사용 알고리즘을 dp로 변경하였다.
dp는 (i, j)가 (i번 이동하였을 때, 노드 j가 마지막일 경우의 수)를 의미하게끔 하였다. 따라서, 모든 노드에 대하여 dp[0][j] = 1로 초기화 후, 각 상황 별로 직전의 상황(i-1)에서 j의 인접 노드들로부터 값을 받아와서 더해주는 방식을 택하였다.(dp[i][j] += dp[i-1][k], k는 j의 인접 노드)

## 문제풀이 코드

```python
# 백준 20951. 유아와 곰두리차
import sys

def dynamic_grograpmming(N, graph):
    # dp[i][j] : 경로의 길이가 i일 때 끝이 j인 경우의 수
    dp = [[0] * (N+1) for _ in range(8)]
    for j in range(N+1):
        dp[0][j] = 1

    '''
    dp[i][j] :
    '''
    for i in range(1, 8):
        for j in range(1, N+1):
            for k in graph[j]:
                dp[i][j] += dp[i-1][k]
            dp[i][j] %= (10**9 + 7)
    result = 0
    for j in range(1, N+1):
        result += dp[7][j]
        result %= (10**9 + 7)
    return result
def solution():
    # N : 정점의 개수(2 <= N <= 100000)
    # M : 간선의 개수(1 <= M <= min(N(N-1)/2, 100000))
    N, M = map(int, input().split())

    graph = [[] for _ in range(N+1)]
    for _ in range(M):
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)

    print(dynamic_grograpmming(N, graph))

solution()
```
