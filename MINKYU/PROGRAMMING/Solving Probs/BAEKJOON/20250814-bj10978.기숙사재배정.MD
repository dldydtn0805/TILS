# 백준 문제 풀이

## bj 10978. 기숙사 재배정(2025-08-14)

## 문제 유형

1. Dynamic Programming
2. Permutation

## 문제 설명

RUNIST 대학교에서는 매 학기마다 재미있는 기숙사 배정을 한다.

RUNIST 대학교에는 N명의 학생이 있고 N개의 기숙사가 있다. 모든 N명의 학생들은 봄학기에 기숙사를 한 명 당 하나씩 배정을 받았고, 모두 각각 다 다른 기숙사에 배정이 되었다.

이제 가을학기가 되어 학생복지팀에서는 기숙사를 다시 배정하려고 한다. 모든 학생들은 본인이 살았던 봄학기 기숙사에서 가을 학기에 다른 기숙사로 배정되면 이사를 해야하므로 기숙사 재배정을 신청하였다. (기숙사 재배정이 된다면 기숙사를 그대로 쓰게 된다.)

이렇게 모든 학생들은 기숙사 재배정을 신청했지만, 학생복지팀에서는 어떤 학생에게도 기숙사 재배정을 해주지 않으려고 한다.

봄학기때 기숙사를 이미 배정받은 상태에서, 가을학기 기숙사에 아무도 재배정이 되지 않는 경우의 수를 구해보자.

## 입력

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 케이스의 첫 번째 줄에 학생 명수(기숙사의 개수) N (1 ≤ N ≤ 20) 이 주어진다.

## 힌트

N이 4인 경우, 봄학기 때 4명의 학생 (민수, 동화, 갑도, 석주)이 각각 기숙사 A,B,C,D에 배정이 되었다면,

(민수-B, 동화-A, 갑도-D, 석주-C), (민수-B, 동화-C, 갑도-D, 석주-A), (민수-B, 동화-D, 갑도-A, 석주-C), (민수-C, 동화-A, 갑도-D, 석주-B), (민수-C, 동화-D, 갑도-A, 석주-B), (민수-C, 동화-D, 갑도-B, 석주-A), (민수-D, 동화-A, 갑도-B, 석주-C), (민수-D, 동화-C, 갑도-A, 석주-B), (민수-D, 동화-C, 갑도-B, 석주-A)

다음과 같은 9가지 경우가 존재한다.

## 출력

각 테스트 케이스 별로 아무도 재배정이 되지 않는 경우의 수를 출력한다.

## 문제풀이

DP 문제이다. 어디서 본 문제다 하고 찾아봤더니, 어릴 적(벌써 10년이 넘은..) 확률과 통계 과목에서 배웠던 순열 문제 중, 교란 순열 알고리즘이다. 예전에는 모자 문제로 배웠었다. N명의 사람이 각 번호가 써진 N개의 모자를 받을 때, 모든 사람이 본인의 번호와 다른 모자를 받을 경우의 수를 구하는 방법이다.

1. 초기화

- dp[1] = 0 (1명이 1개의 모자를 본인의 번호와 다른 모자를 받는 방법의 수는 없음)
- dp[2] = 0 (2명이 받는 방법 : 2 , 1)

2. 점화식

- dp[i] = (i-1) \* (dp[i-1] + dp[i-2])
- 1번 사람이 1번 모자를 제외한 i-1개의 모자를 받을 수 있음
- 2 ~ N번 중, 임의의 k에 대하여
  - 1번 사람이 k번 모자를 받고, k번 사람이 1번 모자를 받는 경우의 수 : dp[i-2]
  - 1번 사람이 k번 모자를 받고, k번 사람은 1번 모자를 받지 못하는 경우의 수 : dp[i-1]

## 문제풀이 코드

```python
# 백준 10978
import sys

dp = [0] * 21
dp[2] = 1
for i in range(3, 21):
    # dp[i] : i명의 학생이 각자 기존 번호를 받지 않는 경우의 수
    # 1번이 받을 수 이는 번호 : 2 ~ i
    # 1번이 임의의 k번을 받았을 경우
    # k도 1번을 받았을 경우 -> dp[i-2](1 <-> k교환, 나머지는 다시)
    # k는 1번을 받지 못했을 경우 -> dp[i-1] (1번을 제외한 나머지가 i-1개 기존 번호 X)
    dp[i] = (dp[i-1] + dp[i-2]) * (i-1)

# N : 학생 명 수(= 기숙사의 개수) (1 <= N <= 20)
def solution(N):
    return dp[N]
T = int(input())
for tc in range(T):
    N = int(input())
    print(solution(N))
```

```java


```
