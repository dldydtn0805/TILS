# 백준 문제 풀이

## bj 16118. 달빛 여우(2025-08-04)

## 문제 유형

1. Graph Search
2. Dijkstra

## 문제 설명

관악산 기슭에는 보름달을 기다리는 달빛 여우가 한 마리 살고 있다. 달빛 여우가 보름달의 달빛을 받으면 아름다운 구미호로 변신할 수 있다. 하지만 보름달을 기다리는 건 달빛 여우뿐만이 아니다. 달빛을 받아서 멋진 늑대인간이 되고 싶어 하는 달빛 늑대도 한 마리 살고 있다.

관악산에는 1번부터 N번까지의 번호가 붙은 N개의 나무 그루터기가 있고, 그루터기들 사이에는 M개의 오솔길이 나 있다. 오솔길은 어떤 방향으로든 지나갈 수 있으며, 어떤 두 그루터기 사이에 두 개 이상의 오솔길이 나 있는 경우는 없다. 달빛 여우와 달빛 늑대는 1번 나무 그루터기에서 살고 있다.

보름달이 뜨면 나무 그루터기들 중 하나가 달빛을 받아 밝게 빛나게 된다. 그러면 달빛 여우와 달빛 늑대는 먼저 달빛을 독차지하기 위해 최대한 빨리 오솔길을 따라서 그 그루터기로 달려가야 한다. 이때 달빛 여우는 늘 일정한 속도로 달려가는 반면, 달빛 늑대는 달빛 여우보다 더 빠르게 달릴 수 있지만 체력이 부족하기 때문에 다른 전략을 사용한다. 달빛 늑대는 출발할 때 오솔길 하나를 달빛 여우의 두 배의 속도로 달려가고, 그 뒤로는 오솔길 하나를 달빛 여우의 절반의 속도로 걸어가며 체력을 회복하고 나서 다음 오솔길을 다시 달빛 여우의 두 배의 속도로 달려가는 것을 반복한다. 달빛 여우와 달빛 늑대는 각자 가장 빠르게 달빛이 비치는 그루터기까지 다다를 수 있는 경로로 이동한다. 따라서 둘의 이동 경로가 서로 다를 수도 있다.

출제자는 관악산의 모든 동물을 사랑하지만, 이번에는 달빛 여우를 조금 더 사랑해 주기로 했다. 그래서 달빛 여우가 달빛 늑대보다 먼저 도착할 수 있는 그루터기에 달빛을 비춰 주려고 한다. 이런 그루터기가 몇 개나 있는지 알아보자.

## 입력

첫 줄에 나무 그루터기의 개수와 오솔길의 개수를 의미하는 정수 N, M(2 ≤ N ≤ 4,000, 1 ≤ M ≤ 100,000)이 주어진다.

두 번째 줄부터 M개의 줄에 걸쳐 각 줄에 세 개의 정수 a, b, d(1 ≤ a, b ≤ N, a ≠ b, 1 ≤ d ≤ 100,000)가 주어진다. 이는 a번 그루터기와 b번 그루터기 사이에 길이가 d인 오솔길이 나 있음을 의미한다.

## 출력

첫 줄에 달빛 여우가 달빛 늑대보다 먼저 도착할 수 있는 나무 그루터기의 개수를 출력한다.

## 문제풀이

다익스트라 골드 1 문제이다. 여우의 이동 방식은 기존 다익스트라 알고리즘을 그대로 활용하면 된다.

문제는 늑대의 이동 방식이다. visited를 2 X (N+1)짜리 2차원 배열로 구현하고, 다음과 같이 값을 저장하면 된다.

- visited[0][i] : 1에서 시작해서 i로 도착할 때, 체력을 보충하며 온 경우
- visited[1][i] : 1에서 시작해서 i로 도착할 때, 빠르게 온 경우

두 가지를 고려하면서 모든 2 ~ N 사이의 값에 대해 visited[0][N], visited[1][N] 중 작은 값을 여우의 최소 이동 시간과 비교하며 여우가 더 빨리 도착한 경우의 개수를 세면 된다.

처음에는 소수점 계산을 진행해서 시간초과가 났다. 따라서, 처음 input을 받을 때 아예 2배 거리로 저장하고, //2를 통해서 정수 유지가 가능하게끔 했다.

## 문제풀이 코드

```python
# 백준 16118
import sys
import heapq

# N : 그루터기의 개수(2 <= N <= 4000)
# M : 오솔길의 개수(1 <= M <= 100000)
# edges[i] = (a, b, d) : a와 b 그루터기 사이 길이가 d인 오솔길이 있다
def solution(N, M, graph):
    def dijkstra_fox(N, graph):
        pq = []
        visited = [int(1e9)] * (N+1)
        heapq.heappush(pq, (0, 1))
        visited[1] = 0
        while pq:
            dist, now = heapq.heappop(pq)
            if visited[now] < dist:
                continue
            for next, d in graph[now]:
                if visited[next] <= dist + d:
                    continue
                heapq.heappush(pq, (dist + d, next))
                visited[next] = dist + d
        return visited

    def dijkstra_wolf(N, graph):
        pq = [(0, 1, 1)]  # (거리, 노드, flag) 1: 빠름, 0: 느림
        visited = [[int(1e9)] * (N + 1) for _ in range(2)]
        visited[1][1] = 0

        while pq:
            dist, now, flag = heapq.heappop(pq)
            if visited[flag][now] < dist:
                continue
            for next, d in graph[now]:
                if flag == 1:
                    new_dist = dist + d // 2
                    if visited[0][next] > new_dist:
                        visited[0][next] = new_dist
                        heapq.heappush(pq, (new_dist, next, 0))
                else:
                    new_dist = dist + d * 2
                    if visited[1][next] > new_dist:
                        visited[1][next] = new_dist
                        heapq.heappush(pq, (new_dist, next, 1))
        return visited
    visited_fox = dijkstra_fox(N, graph)
    visited_wolf = dijkstra_wolf(N, graph)
    # print(visited_fox)
    # for i in range(2):
    #     print(visited_wolf[i])
    # print(visited_wolf)
    result = 0
    # print(visited_fox)
    # for i in range(2):
    #     print(visited_wolf[i])
    for i in range(2, N+1):
        if visited_fox[i] < min(visited_wolf[0][i], visited_wolf[1][i]):
            result += 1
    return result


N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
for _ in range(M):
    a, b, d = map(int, input().split())
    graph[a].append((b, 2*d))
    graph[b].append((a, 2*d))
print(solution(N, M, graph))
```

```java


```
