# 백준 문제 풀이

## bj 16197. 두 동전(2024-11-18)

## 문제 설명

N×M 크기의 보드와 4개의 버튼으로 이루어진 게임이 있다. 보드는 1×1크기의 정사각형 칸으로 나누어져 있고, 각각의 칸은 비어있거나, 벽이다. 두 개의 빈 칸에는 동전이 하나씩 놓여져 있고, 두 동전의 위치는 다르다.
버튼은 "왼쪽", "오른쪽", "위", "아래"와 같이 4가지가 있다. 버튼을 누르면 두 동전이 버튼에 쓰여 있는 방향으로 동시에 이동하게 된다.
동전이 이동하려는 칸이 벽이면, 동전은 이동하지 않는다.
동전이 이동하려는 방향에 칸이 없으면 동전은 보드 바깥으로 떨어진다.
그 외의 경우에는 이동하려는 방향으로 한 칸 이동한다.이동하려는 칸에 동전이 있는 경우에도 한 칸 이동한다.
두 동전 중 하나만 보드에서 떨어뜨리기 위해 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 20)
둘째 줄부터 N개의 줄에는 보드의 상태가 주어진다.
o: 동전
.: 빈 칸
#: 벽
동전의 개수는 항상 2개이다.

## 출력

첫째 줄에 두 동전 중 하나만 보드에서 떨어뜨리기 위해 눌러야 하는 버튼의 최소 횟수를 출력한다. 만약, 두 동전을 떨어뜨릴 수 없거나, 버튼을 10번보다 많이 눌러야 한다면, -1을 출력한다.

## 문제풀이

처음에는 백트래킹 방식으로 푸는 것이 맞을까 싶었다. 주어진 N, M의 범위가 작았기 때문인데, 결국, 최소 횟수를 구하는 문제이기에 적합하지 않다고 느꼈다. 따라서, bfs로 해결하고자 했다.

문제는 visited를 어떻게 구성하는가 였다. 결국 두 동전의 상태((i1, j1)과 (i2, j2))를 알아야 하기 때문에 4차원 배열로 만들어서 visited[i1][j1][i2][j2]에 방문여부를 파악하기로 했다.
결국 하나의 동전만 주어진 범위를 벗어나는 경우를 파악해야 했기 때문에, que에는 두 동전이 모두 보드 위에 있는 상태에 대한 위치정보와 횟수를 담아야 했다(que의 원소 형태 : (i1, j1, i2, j2, cnt))

while 내부에서 인접한 위치로 이동할 때, 동전이 모두 떨어지는 경우, 동전이 하나만 떨어지는 경우, 동전이 떨어지지 않는 경우를 파악하여 각 if문에 대해 처리했다.

동전이 모두 떨어지는 경우는 더 이상 게임을 진행할 수 없는 상황이기 때문에 continue를 사용하였다.

동전이 하나만 떨어지는 경우가 우리가 원하는 경우이기 때문에, 주어진 cnt의 값에 1을 더하여 반환하였다.

동전이 떨어지지 않는 경우에는 다음 위치를 갱신하였고(벽인지에 대한 여부를 통해), 방문 여부를 파악하여 방문하지 않았을 경우 que에 값을 넣어주었다.

que에서 새로운 위치정보를 빼낼 때, 횟수가 10인 경우(cnt == 10), 아직 결과가 반환되지 않은 상황에서 문제를 해결할 수 없기 때문에 -1을 반환해 주었다.

문제 자체는 어렵지 않아 보였으나, visited 구성방식, que에 넣을 값, 다음 위치 정보에 대한 조건식 구성 등 다양한 고민이 필요하였다.

## 문제풀이 코드

```python
# 백준 16197. 두 동전
import sys
from collections import deque

def bfs(N, M, arr, coins, dir):
    que = deque()
    # visited[i1][j1][i2][j2] : 동시 방문 여부
    visited = [[[[0] * M for _ in range(N)] for _ in range(M)] for _ in range(N)]
    coin1 = coins[0]
    coin2 = coins[1]

    que.append((coin1[0], coin1[1], coin2[0], coin2[1], 0))
    while que:
        i1, j1, i2, j2, cnt = que.popleft()
        # que에 들어오는 것 : 둘 다 안떨어진 경우
        # 따라서 cnt == 10만 되더라도 이제 더이상 못함 끝
        if cnt == 10:
            return -1

        for di, dj in dir:
            ni1 = i1 + di
            nj1 = j1 + dj
            ni2 = i2 + di
            nj2 = j2 + dj

            flag1 = (0 <= ni1 < N and 0 <= nj1 < M)
            flag2 = (0 <= ni2 < N and 0 <= nj2 < M)
            # 둘다 안떨어짐
            if flag1 and flag2:
                # 벽 -> 이동 X
                if arr[ni1][nj1] == "#":
                    ni1 = i1
                    nj1 = j1
                # 벽 -> 이동 X
                if arr[ni2][nj2] == "#":
                    ni2 = i2
                    nj2 = j2

                if visited[ni1][nj1][ni2][nj2] == 0:
                    que.append((ni1, nj1, ni2, nj2, cnt+1))
                    visited[ni1][nj1][ni2][nj2] = 1
            # 둘다 떨어짐
            elif not flag1 and not flag2:
                continue
            # 하나만 떨어짐 -> 끝
            else:
                return cnt + 1

    return -1



def solution():
    # N, M : 보드의 세로, 가로 크기(1 <= N, M <= 20)
    N, M = map(int, input().split())
    # arr[i][j] = o : 동전
    # arr[i][j] = . : 빈칸
    # arr[i][j] = # : 벽
    arr = []
    coins = []
    for i in range(N):
        lst = list(input())
        for j in range(M):
            if lst[j] == "o":
                coins.append((i, j))
        arr.append(lst)
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    print(bfs(N, M, arr, coins, dir))

  solution()
```
