# 백준 문제 풀이

## bj 2159. 케익 배달(2025-08-06)

## 문제 유형

1. Dynamic Programming
2. Coordinate Compression

## 문제 설명

프랑스에서 공부를 하고 돌아온 선아는 자신이 그렇게도 되고 싶어 했던 파티셰가 되었다. 케익 배달 전문업체 보나뻬띠에 취직한 선아는 친절하게도 자신이 만든 케익을 고객들에게 직접 배달을 하려 한다. N명의 고객에게 케익을 배달하는데 주문이 들어온 순서대로 배달하기를 원하며 고객이 케익을 받을 수 있을 만큼 충분히 가까이까지 배달한다.

N명의 고객의 위치는 순서대로 100,000×100,000 격자의 정수 좌표로 주어지고 처음 출발하게 되는 보나뻬띠의 위치도 정수 좌표로 주어진다. 선아는 격자 위에서 상하좌우로만 움직이며 고객에게 케익을 전달하기 위해서는 그 고객의 위치까지 가거나 고객의 상하좌우 인접 격자점에 가야 한다. 이때 선아가 최단거리를 이동하여 입력된 순서대로 배달을 끝낼 수 있는 거리를 계산하는 프로그램을 작성하시오. 여기서 거리는 격자 상의 칸 수를 말한다.

위의 예에서 선아는 11칸을 움직여서 세 명의 고객에게 배달을 마칠 수 있다. 선아는 반드시 고객들에게 순서대로 배달을 하며 순서에 어긋난 사람에게 배달을 할 수 있는 위치에 있더라도 케익을 주지 않고 순서대로 배달을 한다. 고객의 위치는 중복이 될 수도 있다.

## 입력

첫째 줄에 N이 주어지고 둘째 줄에는 선아가 일하는 레스토랑의 위치가, 셋째 줄부터는 N명의 위치가 X와 Y로 주어진다. 두 좌표 사이에는 공백이 하나 이상 있다. (1 ≤ N, X, Y ≤ 100,000)

## 출력

첫째 줄에 최단 거리를 출력한다.

## 문제풀이

애초에 격자판이 100000 X 100000이기 때문에, 좌표를 인덱스로 압축하여 풀어야 하는 문제이다.

각 케익을 받을 수 있는 위치는 케익 기준 상하좌우, 그리고 본인의 좌표 총 5개이다. 따라서, 처음 레스토랑에서 첫 번째 케익 배달 위치까지만 초기화를 한 후, dp[i][j]에 i-1번째 위치에서 i번째 위치의 j번 방향(0 : 상, 1 : 하, 2 : 좌, 3 : 우, 4 : 가운데)에 전달할 경우 최소 거리 합을 저장하면 된다.

## 문제풀이 코드

```python
# 백준 2159
import sys

# N : 고객의 수(1 <= N <= 100000)
# arr[0] : 레스토랑 위치
# arr[i] : i번째 고객 위치
def solution(N, arr):
    # dp[i][0] : 상
    # dp[i][1] : 하
    # dp[i][2] : 좌
    # dp[i][3] : 우
    # dp[i][4] : 자기 자신
    dp = [[float('inf')] * 5 for _ in range(N+1)]
    y1, x1 = arr[1]
    y2, x2 = arr[0]
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)]
    for d in range(5):
        ny1 = y1 + dir[d][0]
        nx1 = x1 + dir[d][1]
        if not (1 <= ny1 <= 100000 and 1 <= nx1 <= 100000):
            continue
        dist = abs(ny1 - y2) + abs(nx1 - x2)
        dp[1][d] = dist
    for k in range(2, N+1):
        i1, j1 = arr[k]
        i2, j2 = arr[k-1]
        for d1 in range(5):
            ni1 = i1 + dir[d1][0]
            nj1 = j1 + dir[d1][1]
            if not (1 <= ni1 < 100000 and 1 <= nj1 <= 100000):
                continue
            for d2 in range(5):
                ni2 = i2 + dir[d2][0]
                nj2 = j2 + dir[d2][1]
                if not (1 <= ni2 < 100000 and 1 <= nj2 <= 100000):
                    continue
                dist = abs(ni2 - ni1) + abs(nj2 - nj1)
                dp[k][d1] = min(dp[k][d1], dp[k-1][d2] + dist)
    result = float('inf')
    for j in range(5):
        result = min(result, dp[N][j])
    return result


N = int(input())
arr = [list(map(int, input().split())) for _ in range(N+1)]
print(solution(N, arr))
```

```java


```
