# 백준 문제 풀이
## bj 2866. 문자열 잘라내기(2024-10-13)

## 문제 설명
    R개의 행과 C개의 열로 이루어진 테이블이 입력으로 주어진다. 이 테이블의 원소는 알파벳 소문자이다.
    각 테이블의 열을 위에서 아래로 읽어서 하나의 문자열을 만들 수 있다. 예제 입력에서

    dobarz
    adatak
    
    이 주어지는 경우 "da", "od", "ba", "at", "ra", "zk"와 같이 6개의 문자열들이 만들어지게 된다.

    만약 가장 위의 행을 지워도 테이블의 열을 읽어서 문자열이 중복되지 않는다면, 가장 위의 행을 지워주고, count의 개수를 1 증가시키는, 이 과정을 반복한다. 만약 동일한 문자열이 발견되는 경우, 반복을 멈추고 count의 개수를 출력 후 프로그램을 종료한다.

    테이블이 주어질 경우 count의 값을 구해보자.

## 입력
    첫 번째 줄에는 테이블의 행의 개수와 열의 개수인 R과 C가 주어진다. (2 ≤ R, C ≤ 1000)
    이후 R줄에 걸쳐서 C개의 알파벳 소문자가 주어진다. 가장 처음에 주어지는 테이블에는 열을 읽어서 문자열을 만들 때, 동일한 문자열이 존재하지 않는 입력만 주어진다.

## 출력
    문제의 설명과 같이 count의 값을 출력한다.

## 문제풀이
    처음에는 문제 자체를 이해를 못해서 시작을 못했었다. 문제 관련 설명문을 읽다보니, 주어진 행(r)에서 끝 행(R-1)까지 같은 열(c)로 이루어진 문자열을 비교했을 때, 하나라도 중복되는 문자열이 나올 경우, 계속 한 칸씩 r을 밑으로 내리는 방식이었다.
    이 문제의 핵심은, r ~ R-1 사이에서 중복이 발생할 경우, r보다 큰 r'에 대해서도 반드시 중복이 발생한다는 것이다. 즉, 그 아래로는 볼 필요가 없다는 뜻이었다.
    결국, 적절한 r을 시간 제한 내에 찾는 것이 목표인데, 이를 위해 적절한 알고리즘인 이분 탐색을 사용했다.
    시작 인덱스(s = 0)과 끝 인덱스(e = N-1)을 설정 후, 중간 값(m = (s+e)//2)를 기준으로 앞서 말한 문자열들을 파악하여 중복 여부를 파악 후, 중복이 발생했을 경우, 즉 m이후의 값을 볼 필요가 없을 경우에는 결과값을 갱신하고 e를 m-1로 설정했다. 중복이 발생하지 않았을 경우, 더 작은 범위에서 탐색하기 위해 s를 m+1로 설정했다.
    처음 푼 방식으로는 약 800ms의 시간이 나왔는데, 해결 이후 여러 풀이를 찾아보다가 170ms 정도의 풀이방법을 찾아서 이를 내 방식으로 재풀이하여 공유하려 한다.
    
## 문제풀이 코드
```python
# 백준 2866. 문자열 잘라내기
import sys
input = sys.stdin.readline 

def binary_search(N, M, arr):
    s = 0
    e = M-1

    result = M
    while s <= e:
        m = (s+e) // 2
        strings = set()
        for string in arr:
            strings.add(string[m:])
        # 중복 없음
        if len(strings) == N:
            s = m + 1
        # 중복 있음 -> 결과 갱신
        else:
            e = m - 1
            result = min(result, m)
    return result - 1

def solution():
    M, N = map(int, input().rstrip().split())
    arr = ["" for _ in range(N)]
    for j in range(M):
        string = input().rstrip()
        for i in range(N):
            arr[i] += string[i]

    print(binary_search(N, M, arr))

solution()
```