# 백준 문제 풀이

## bj 2157. 여행(2024-12-15)

## 문제 설명

N개의 도시가 동쪽에서 서쪽으로 순서대로 위치해 있다. 제일 동쪽에 있는 도시는 1번 도시이며, 제일 서쪽에 있는 도시는 N번 도시이다.

당신은 이와 같은 도시 중에서 M개 이하의 도시를 지나는 여행을 계획하려 한다. 여행 경로는 반드시 1번 도시에서 시작해서 N번 도시에서 끝나야 한다. 물론 이 두 도시도 M개의 도시에 포함된다. 당신은 시차에 매우 민감하기 때문에, 한 번 서쪽으로 이동했다가 다시 동쪽으로 이동하면 몸이 대단히 아프다. 그래서 당신은 계속 서쪽으로만, 즉 도시 번호가 증가하는 순서대로만 이동하기로 하였다.

한편, 모든 도시에서 다른 모든 도시로 이동할 수 있는 건 아니다. 각각의 도시에서 다른 도시로 이동할 때에는 비행기를 타고 이동해야 하는데, 때로는 비행 항로가 개설되지 않았을 수도 있다. 또한 당신은 비행기를 아무렇게나 타려는 것이 아니라, 최대한 맛있는 기내식만 먹으면서 이동하려 한다(사실 이게 여행의 목적이다).

항로 개설 여부와 해당 항로에서 제공되는 기내식의 점수가 주어졌을 때, 먹게 되는 기내식의 점수의 총 합이 최대가 되도록 하시오.

## 입력

첫째 줄에 N(1 ≤ N ≤ 300), M(2 ≤ M ≤ N), K(1 ≤ K ≤ 100,000)가 주어진다. K는 개설된 항공로의 개수이다. 다음 K개의 줄에는 각 항공로에 대한 정보를 나타내는 세 정수 a, b, c(1 ≤ a, b ≤ N, 1 ≤ c ≤ 10,000)가 주어진다. 이는 a번 도시에서 b번 도시로 이동하는 항로가 있고, 서비스되는 기내식의 점수가 c점이라는 의미이다. 서쪽에서 동쪽으로 이동하는 항로가 입력될 수도 있고, 같은 도시 쌍 사이에 항로가 여러 개 있을 수도 있지만, 날아다니다 다시 원래 도시로 돌아오는 a=b 와 같은 입력은 없다.

## 출력

첫째 줄에 기내식 점수의 총 합의 최댓값을 출력한다.

## 문제풀이

처음에는 시작 - 끝, 최대(=> 음수로 표현하여 최소)라는 생각으로 dijkstra로 접근했다. 하지만, K의 범위 때문에 시간 초과가 날 듯 했다. 따라서, N \* M 형태의 dp로 접근했다. dp[i][j]를 i번 도시까지 도착했을 때, 지금까지 지나온 도시의 개수가 j일 경우 최대 기내식 점수 합을 의미하도록 하여 1번(시작점)과 연결된 다음 도시들에 대하여 초기화를 진행했다. 이후, 갈 수 있는 경우에 대해 dp를 갱신해줬다.

## 문제풀이 코드

```python
# 백준 2157. 여행
import sys
def solution():
    # N : 도시의 개수(1 <= N <= 300)
    # M : 여행 계획에 포함되는 도시 최대 개수(2 <= M <= N)
    # K : 여행 경로의 개수(1 <= K <= 100000)
    N, M, K = map(int, input().split())
    arr = [[0] * (N+1) for _ in range(N+1)]
    for _ in range(K):
        a, b, c = map(int, input().split())
        if a > b:
            continue
        arr[a][b] = max(arr[a][b], c)
    '''
    여행 경로는 반드시 1번 도시 -> N번 도시
    도시 번호가 증가하는 순서대로만 이동
    먹게 되는 기내식의 점수 합이 최대가 되도록
    '''
    # dp[i][j] : j개의 도시를 포함한 여행, 마지막 도시는 i번 -> 최대 점수
    dp = [[0] * (M+1) for _ in range(N+1)]
    for i in range(2, N+1):
        dp[i][2] = arr[1][i]
    for i in range(2, N+1):
        for j in range(3, M+1):
            for k in range(1, i):
                if arr[k][i] > 0 and dp[k][j-1] > 0:
                    dp[i][j] = max(dp[i][j], dp[k][j-1] + arr[k][i])
    print(max(dp[N]))
solution()

```
