# 백준 문제 풀이
## bj 3933. 라그랑주의 네 제곱수 정리(2024-10-21)

## 문제 설명
    양의 정수는 많아야 4개의 제곱수로 표현할 수 있다고 한다. 이 이론을 라그랑주의 네 제곱수 정리라고 한다. 이 정리는 조제프루이 라그랑주가 1770년에 증명했다.
    우리는 이 이론을 증명하거나 새로운 이론을 발견할 필요는 없고, n이 주어졌을 때 4개 이하의 양의 제곱수의 합으로 n을 만들 수 있는 경우의 수를 구하려고 한다. 경우의 수를 구할 때 제곱수의 순서가 바뀌는 경우는 같은 경우로 본다. 따라서 32 + 42 과 42 + 32는 같은 경우이다.
    N이 25일 때 4개 이하의 제곱수의 합으로 표현 할 수 있는 경우는 12 + 22 + 22 + 42, 32 + 42, 52 이렇게 3가지이다.

## 입력
    입력은 최대 255줄이다. 각 줄에는 215보다 작은 양의 정수가 하나씩 주어진다. 마지막 줄에는 0이 하나 있고, 입력 데이터가 아니다.

## 출력
    각 테스트 케이스에 대해서 입력으로 주어진 n을 많아야 4개의 제곱수로 나타내는 경우의 수를 출력한다.

## 문제풀이
    처음에 보고 단순한 DP 문제인 줄 알았는데, 계속 코드 풀이 과정이 꼬이고 답이 안나왔다. 결국 다른 사람들의 풀이과정을 참조하여 문제를 해결하였다. 
    우선, 주어진 범위(2**15)를 저장하는 변수 MAX를 기준으로, MAX보다 작은 모든 제곱수들을 squares에 저장하였다. 이후, dp[i][j]가 j를 i개의 제곱수들의 합으로 표현한 방법을 의미하는 dp를 생성했다. 이를 활용하여, 주어진 오름차순 정렬된 제곱수들을 기준으로 현재 제곱수(square)가 최대 범위(MAX)를 넘어설 때 까지 dp를 갱신했다.
    MAX - square 내에 있는 모든 수(num)들에 대해 반복문을 통해 현재 num을 j-1개의 제곱수들을 만드는 방법을 더해주었다.

## 문제풀이 코드
```python
# 백준 3933. 라그랑주의 네 제곱수 정리
import sys

def make_squares(max_num):
    num = 1
    squares = []
    while num ** 2 <= max_num:
        squares.append(num ** 2)
        num += 1
    return squares
def solution():
    MAX = 2**15
    squares = make_squares(MAX)

    dp = [[0] * MAX for _ in range(5)]
    dp[0][0] = 1

    for square in squares:
        for j in range(1, 5):
            if MAX-square <= 0:
                break
            for num in range(MAX-square):
                dp[j][num+square] += dp[j-1][num]
       # N : 주어진 양의 정수(1 <= N <= 2^15)
    N = int(input())
    while True:
        if N == 0:
            break
        '''
        N을 네 개 이하의 제곱수의 합으로 표현하는 방법
        '''
        print(dp[1][N] + dp[2][N] + dp[3][N] + dp[4][N])
        N = int(input())
solution()
```