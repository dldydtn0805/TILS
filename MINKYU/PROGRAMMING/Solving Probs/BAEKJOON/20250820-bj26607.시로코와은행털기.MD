# 백준 문제 풀이

## bj 26607. 시로코와 은행털기(2025-08-20)

## 문제 유형

1. Math
2. Dynamic Programming
3. 0-1 Knapsack Problem

## 문제 설명

블루아카이브에 있는 아비도스 고등학교 학생, 스나오오카미 시로코는 은행 터는 것을 자주 시뮬레이션한다.

게임의 마스코트, 스나오오카미 시로코이다.

어느 날, 정말로 은행을 털어보고 싶다는 생각이 든 시로코는 은행을 털 준비를 하기 시작했다. 우선, 은행 터는 것을 함께 할 팀을 만들 것인데, 경쟁을 뚫고 마지막까지 살아남은 n명 중에서 최종적으로 k명을 팀원으로 선발할 계획이다. 지원자들은 각각 힘과 스피드 수치 a, b가 주어지는데, 쟁쟁한 경쟁을 뚫고 살아남은 자들답게 a+b가 모두 동일하다.

i번째 팀원으로 선발한 사람의 능력치가 각각 a*{i}, b*{i}라 할 때, 그 팀의 종합 능력치는(sum(a(i) ~ a(i+k-1)) X (sum(b(i) ~ b(i+k-1))))이다. 팀의 능력치를 최대화하게 지원자들을 선발하려 할 때 그때 그 팀의 능력치를 출력하라.

## 입력

첫 번째 줄에 사람의 수 n와 뽑을 인원 k, 그리고 힘과 스피드 수치의 합 x가 공백으로 구분되어 주어진다.

그 다음줄부터 n개의 줄에는 각 사람들이 지닌 힘과 스피드 능력치 a b가 주어진다.

## 제한

1 <= n <= 80

1 <= k <= n

1 <= x <= 200

0 <= a, b

## 출력

팀의 능력치를 최대화하게 인원을 선발할 때, 그 팀의 능력치를 출력하라.

## 문제풀이

0-1 knapsack을 활용한 dp 문제이다. 주어진 값들을 활용하면서 선택한 k개의 값에 대해 sum(ai for i in range(K)) X (K \* X - sum(ai for i in range(K)))를 구하는 문제이다. 즉, 각 상황에 대해 최적의 K개의 힘(a)의 합을 구하고, 위의 값이 최대가 되는 경우를 구하면 된다.

이 문제는 최적화를 위해서 dp를 set으로 구현해야 했다. dp를 (K+1) 크기의 일차원 배열로 구현하고, dp[i]에 i개를 골랐을 때 가능한 힘의 합의 경우들을 넣으면 된다.

0개를 골랐을 때 합이 0이 되는 경우가 존재한다. 따라서, dp[0]에는 set(0)이 들어가게 된다.

이후, 각 팀원의 능력치를 순회하며 K에서부터 역으로 앞선 개수에서 가능한 경우에 해당 힘을 더한 값을 넣어주면 된다(dp[i].add(dp[i-1] + a))

처음에는 dp를 (K+1) X (K\*X+1)인 이차원 배열로 구성하여, dp[i][j]에 i개를 골랐을 때 합이 j가 되는 경우가 가능한지에 대한 여부를 담았다. 이렇게 푸니, 최적화를 실패했다(정답 처리는 되었지만..)

다른 사람들의 코드를 찾아보니 set으로 dp를 구현한다는 신박한 방법이 있어서 차용하게 되었다.

## 문제풀이 코드

```python
# 백준 26607
import sys
# N : 사람의 수(1 <= N <= 80)
# K : 뽑을 인원(1 <= K <= N)
# X : 힘과 스피드 수치 합(1 <= X <= 200)
# arr[i] = a, b : i번 사람의 힘(a), 스피드(b)
def solution(N, K, X, arr):
    arr.sort()
    # dp[i] : i개를 뽑았을 때 가능한 합을 모아놓은 집합
    dp = [set() for _ in range(K+1)]
    dp[0].add(0)
    for a, b in arr:
        # i개를 뽑았을 때 가능한 합 넣어주기
        for i in range(K, 0, -1):
            for j in dp[i-1]:
                dp[i].add(j+a)
    result = 0
    # print(dp)
    if dp[K]:
        for v in dp[K]:
            result = max(result, v * (K * X - v))
    return result

N, K, X = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
print(solution(N, K, X, arr))
```

```java


```
