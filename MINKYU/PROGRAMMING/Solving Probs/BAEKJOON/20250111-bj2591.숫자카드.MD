# 백준 문제 풀이

## bj 2591. 숫자가드(2025-01-11)

## 문제 설명

1부터 34까지 수가 적힌 카드가 충분히 많이 있다. 이들 중 몇 장을 일렬로 늘어놓고, 그 숫자를 차례로 적었다.
나중에, 적어 놓은 것에 맞게 다시 카드를 늘어놓으려고 보니, 방법이 여러 가지일 수 있다는 것을 알았다.
카드의 숫자를 차례로 적어 놓은 것이 주어질 때, 위와 같이 그것을 가지고 거꾸로 카드의 배열을 찾으려고 한다. 가능한 카드의 배열이 모두 몇 개인지 구하는 프로그램을 작성하시오.

## 입력

첫 줄에 카드의 숫자를 차례로 적어 놓은 것이 주어지며, 이것은 최대 40자 이하의 숫자로 이루어진다.

## 출력

첫 줄에 가능한 카드 배열이 몇 개인지를 출력한다.

## 문제풀이

모든 경우의 수를 구해야 하기 때문에 dp로 해결하였다. dp[i][j]를 i번 카드까지 확인했을 때, j가 0인 경우 i번 카드는 독립적으로 숫자가 되는 경우의 수, j가 1인 경우 i번 카드는 i-1번 카드와 붙어서 숫자가 되는 경우의 수이다.
다음과 같은 고려사항이 있다.

- 현재 숫자가 0인 경우 : 해당 경우는 반드시 앞과 붙어야 한다 -> 즉, 앞은 독립적인 상황에서 0과 붙어야 하기 때문에 dp[i][1] = dp[i-1][0]이다.
- 앞의 숫자가 0인 경우 : 해당 경우는 앞의 숫자는 그 앞과 함께 움직이기 때문에 무조건 현재 숫자는 독립적이다. 따라서, dp[i][0] = dp[i-1][1]이다.
- 앞의 숫자와 합쳐졌을 경우, 34가 넘어갈 때 : 이 경우는 반드시 현재 숫자가 독립적이어야 한다. 따라서, dp[i][0] = dp[i-1][0] + dp[i-1][1]이다.
- 앞의 숫자와 합쳐졌을 경우, 34를 넘지 않을 때 : 이 경우는 모든 앞의 경우를 더해주면 된다. 따라서, dp[i][0] = dp[i-1][0] + dp[i-1][1], dp[i][1] = dp[i-1][0]이다.
  조건별로 분기를 만들어서 점화식을 구성하면 쉬운 문제였다.

## 문제풀이 코드

```python
# 백준 2591. 숫자카드
import sys
sys.stdin = open("input.txt")

def solution():
    MIN = 1
    MAX = 34
    arr = [0] + list(map(int, input()))
    N = len(arr)

    # print(arr)
    # dp[i][0] : i번까지 봤을 때, i번은 앞이랑 독립적으로
    # dp[i][1] : i번까지 봤을 때, (i-1) * 10 + i가 1 ~ 34사이일 경우 붙이기
    '''
    1. 앞의 숫자가 0인 경우
    - 앞의 숫자는 그 앞과 묶여서 움직임
    - 현재 숫자는 앞의 숫자와 독립적
    2. 현재 숫자가 0인 경우
    - 현재 숫자는 앞의 숫자와 묶여서 움직임
    3. 앞의 숫자와 합쳤을 때 34를 넘어가는 경우
    - 현재 숫자는 앞의 숫자와 독립적
    4. 위의 조건을 벗어나는 경우
    - 현재 숫자가 독립적일 경우, 앞의 0번, 1번 케이스를 다 더해줌
    - 현재 숫자가 앞의 숫자와 묶일 경우, 앞이 독립적인 케이스
    '''
    dp = [[0] * 2 for _ in range(N)]

    dp[1][0] = 1
    for i in range(2, N):
        # 앞이 0임 -> 무조건 독립
        if arr[i-1] == 0:
            dp[i][0] = dp[i-1][1]
        # 0임 -> 무조건 붙이기
        if arr[i] == 0:
            dp[i][1] = dp[i-1][0]
        else:
            if arr[i-1] * 10 + arr[i] <= MAX:
                dp[i][0] = dp[i-1][0] + dp[i-1][1]
                dp[i][1] = dp[i-1][0]
            else:
                dp[i][0] = dp[i-1][0] + dp[i-1][1]
    print(sum(dp[N-1]))


solution()
```
