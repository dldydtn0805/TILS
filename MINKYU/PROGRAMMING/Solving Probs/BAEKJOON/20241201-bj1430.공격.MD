# 백준 문제 풀이

## bj 1430. 공격(2024-12-01)

## 문제 설명

다솜이는 누구나 쉽게 게임을 만들 수 있도록 하기 위해 Microsoft에서 출시한 XNA Game Studio Express를 가지고 게임을 만들었다.

다솜이의 게임은 적의 공격에 대비해서 도시를 방어하는 게임이다. 도시에는 탑이 N개가 있다. 각각의 탑은 X-Y좌표 평면위에 존재한다. 또, 탑은 맨 처음에 D의 에너지를 가지고 있고, 탑의 사정거리는 R이다.

탑 주변에 적이 나타나면, 탑은 적을 다음과 같은 방법으로 공격할 수 있다.

일단, 탑은 자신의 에너지를 재분배할 수 있다. 만약 서로 다른 두 탑의 거리가 R보다 작거나 같다면, 둘 중에 한 탑은 다른 탑에게 에너지를 자기가 가지고 있는 한도내에서 자유롭게 전송할 수 있다. 하지만, 에너지를 전송할 때는, 절반을 잃는다. (탑 1이 탑 2에게 에너지를 10 전송하면, 탑 1은 에너지를 10을 잃고, 탑 2는 에너지를 5 얻는다.)

탑이 적을 공격할 때는, 적과 탑의 거리가 R보다 작거나 같아야한다. 탑에서 적을 공격할 때는, 자신의 모든 에너지를 적을 공격하는데 쓴다. 이때 적이 받는 데미지는 에너지의 양과 같다.

적이 받을 수 있는 에너지의 최댓값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 탑의 개수 N, 사정 거리 R, 초기 에너지 D, 적의 X좌표 X, 적의 Y좌표 Y가 주어진다. 둘째 줄부터는 탑의 위치가 한 줄에 하나씩 X좌표 Y좌표 순으로 주어진다. N은 50보다 작거나 같은 자연수이고, R은 500보다 작거나 같은 자연수, D는 100보다 작거나 같은 자연수이다. 모든 X좌표와 Y좌표는 1,000보다 작거나 같은 음이 아닌 정수이다. 탑의 위치가 같은 경우는 없고, 적과 탑의 위치가 같은 경우도 입력으로 주어지지 않는다.

## 출력

첫째 줄에 적이 받는 데미지의 최댓값을 출력한다. 절대/상대 오차는 10-2까지 허용한다.

## 문제풀이

처음에는 가장 먼 위치에서부터 차례대로 쌓아와서 적에게 공격을 하는 방식을 선택했지만, 실패했다... 그러다가 결국 주어진 에너지의 반을 계속 더해주는 방식을 사용하면 되겠다고 생각했다. 따라서, 시작 위치를 적의 위치로 하여(모든 위치는 인덱스로 파악) 해당 위치와 가까운(거리가 R 이하인) 방문하지 않은 탑들을 찾아가며 결과값에 더해주었다. bfs로 풀었는데 너무 어려웠던 것 같다 ....

## 문제풀이 코드

```python
# 백준 1430. 공격
import sys
from collections import deque

def bfs(N, D, graph):
    que = deque()
    que.append((0, 0))
    visited = [0] * (N+1)
    visited[0] = 1

    result = 0
    while que:
        i, cnt = que.popleft()
        # i와 이웃한(거리가 R보다 작거나 같은) j들
        for j in graph[i]:
            if visited[j] == 0:
                que.append((j, cnt+1))
                visited[j] = 1
                result += D * (0.5**cnt)
    return result

def solution():
    # N : 탑의 개수(1 <= N <= 50)
    # R : 사정 거리(1 <= R <= 500)
    # D : 초기 에너지(1 <= D <= 100)
    # X, Y : 적의 좌표(0 <= X, Y <= 1000)
    N, R, D, X, Y = map(int, input().split())
    '''
    탑 주변에 적이 나타날 경우 탑이 공격하는 방법
    1. 탑은 자신의 에너지를 재분배할 수 있다
    - 서로 다른 두 탑의 거리가 R보다 작거나 같을 경우
    - 다른 탑에게 에너지를 자기가 가지고 있는 한도 내에서 자유롭게 전송 가능
    - 주는 탑 : 준 만큼 잃음
    - 받는 탑 : 받은거 // 2 만큼 얻음
    2. 탑이 적을 공격할 때는 적과 탑의 거리가 R보다 작거나 같음
    - 공격 시, 자신의 모든 에너지를 사용
    - 적이 받는 데미지는 에너지의 양과 같음
    '''
    arr = [list(map(int, input().split())) for _ in range(N)]
    arr.insert(0, [X, Y])
    # print(arr)

    graph = [[] for _ in range(N+1)]
    for i in range(N+1):
        x1, y1 = arr[i]
        for j in range(i+1, N+1):
            x2, y2 = arr[j]
            dist = ((x1-x2)**2 + (y1-y2)**2)**0.5
            if dist <= R:
                graph[i].append(j)
                # graph[i].append((dist, j))
                graph[j].append(i)
    print(bfs(N, D, graph))

solution()
```
