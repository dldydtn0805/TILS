# 백준 문제 풀이

## bj 25795. 예쁜 초콜릿과 숫자놀이(2025-07-28)

## 문제 유형

1. Dynamic Programming(DP)
2. Backtracking

## 문제 설명

코코는 화이트와 다크 초콜릿을 가지고 놀고 있다. 화이트 초콜릿 N개와 다크 초콜릿 N개를 배열했을 때, 다음의 조건을 만족하는 배열을 "예쁜 초콜릿"이라고 한다. (X_1,X_2, ..., X_n)은 초콜릿 배열 X_1, X_2, ..., X_n을 순서대로 이어 붙인 것을 뜻한다.

1. (화이트, 다크)는 예쁜 초콜릿이다.
2. (화이트, 예쁜 초콜릿, 다크)는 예쁜 초콜릿이다.
3. (예쁜 초콜릿, 예쁜 초콜릿)은 예쁜 초콜릿이다.
4. 위의 3가지 규칙으로 만들 수 없는 초콜릿 배열은 예쁜 초콜릿이 아니다.

어떤 초콜릿 배열의 "점수"는 다음과 같이 계산한다. 특정한 정수 a에서 시작해서, 왼쪽부터 순서대로 화이트 초콜릿이 있으면 b를 더하고, 다크 초콜릿이 있으면 c를 곱한다. 마지막에 얻은 값을
10^5로 나눈 나머지가 이 초콜릿 배열의 점수이다.

코코는 예쁜 초콜릿 중에서 가장 점수가 높은 초콜릿 배열을 찾고 싶다. 코코를 위해 코코가 얻을 수 있는 가장 높은 점수를 계산해주자.

## 입력

첫 줄에 정수 N, a, b, c가 순서대로 주어진다.

## 제한

1 <= N <= 15

1 <= a, b, c < 10^5

## 출력

화이트 초콜릿 N개와 다크 초콜릿 N개를 사용해 만들 수 있는 예쁜 초콜릿들의 점수의 최댓값을 한 줄에 출력한다.

## 문제풀이

dp 문제이다. 화이트 초콜릿 i개, 다크 초콜릿 j개로 k짜리 값의 예쁜 초콜릿 배열을 가질 수 있는지에 대한 여부를 (N+1) X (N+1) X 100000 3차원 배열에 담았다.

각 (i, j, k)에 대해

- i가 N보다 작을 경우, 다음 값으로 화이트 초콜릿을 추가하면 dp[i+1][j][(k+b)%MOD]의 값이 활성화 된다
- j가 i보다 작을 경우, 다음 값으로 다크 초콜릿을 추가하면 dp[i][j+1][(k*c)%MOD]의 값이 활성화 된다

해당 과정을 통해 (N+1) X (N+1)를 사용하여 얻을 수 있는 값들 중 최대 값을 찾으면 된다.

## 문제풀이 코드

```python
# 백준 25795
import sys

# N : 화이트 초콜릿, 다크 초콜릿의 개수(1 <= N <= 15)
# a, b, c : 점수 계산을 위한 값(1 <= a, b, c < 10**5)
# a : 시작 정수
# b : 화이트 초콜릿일 경우 더할 값
# c : 다크 초콜릿일 경우 곱할 값
def solution(N, a, b, c):
    MOD = 100000
    dp = [[[0] * MOD for _ in range(N+1)] for _ in range(N+1)]
    dp[0][0][a] = 1

    for i in range(N+1):
        for j in range(i+1):
            for k in range(MOD):
                if dp[i][j][k] == 1:
                    if i+1 <= N:
                        dp[i+1][j][(k+b)%MOD] = 1
                    if j+1 <= i:
                        dp[i][j+1][(k*c)%MOD] = 1
    for k in range(MOD-1, -1, -1):
        if dp[N][N][k] == 1:
            return k
    return (a+b)*c % MOD

N, a, b, c = map(int, input().split())
print(solution(N, a, b, c))
```

```java


```
