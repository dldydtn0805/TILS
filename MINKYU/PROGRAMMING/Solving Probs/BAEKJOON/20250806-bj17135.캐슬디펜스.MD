# 백준 문제 풀이

## bj 17135. 캐슬 디펜스(2025-08-06)

## 문제 유형

1. Simulation
2. Brute Force
3. Breadth First Search(BFS)

## 문제 설명

캐슬 디펜스는 성을 향해 몰려오는 적을 잡는 턴 방식의 게임이다. 게임이 진행되는 곳은 크기가 N×M인 격자판으로 나타낼 수 있다. 격자판은 1×1 크기의 칸으로 나누어져 있고, 각 칸에 포함된 적의 수는 최대 하나이다. 격자판의 N번행의 바로 아래(N+1번 행)의 모든 칸에는 성이 있다.

성을 적에게서 지키기 위해 궁수 3명을 배치하려고 한다. 궁수는 성이 있는 칸에 배치할 수 있고, 하나의 칸에는 최대 1명의 궁수만 있을 수 있다. 각각의 턴마다 궁수는 적 하나를 공격할 수 있고, 모든 궁수는 동시에 공격한다. 궁수가 공격하는 적은 거리가 D이하인 적 중에서 가장 가까운 적이고, 그러한 적이 여럿일 경우에는 가장 왼쪽에 있는 적을 공격한다. 같은 적이 여러 궁수에게 공격당할 수 있다. 공격받은 적은 게임에서 제외된다. 궁수의 공격이 끝나면, 적이 이동한다. 적은 아래로 한 칸 이동하며, 성이 있는 칸으로 이동한 경우에는 게임에서 제외된다. 모든 적이 격자판에서 제외되면 게임이 끝난다.

게임 설명에서 보다시피 궁수를 배치한 이후의 게임 진행은 정해져있다. 따라서, 이 게임은 궁수의 위치가 중요하다. 격자판의 상태가 주어졌을 때, 궁수의 공격으로 제거할 수 있는 적의 최대 수를 계산해보자.

격자판의 두 위치 (r1, c1), (r2, c2)의 거리는 |r1-r2| + |c1-c2|이다.

## 입력

첫째 줄에 격자판 행의 수 N, 열의 수 M, 궁수의 공격 거리 제한 D가 주어진다. 둘째 줄부터 N개의 줄에는 격자판의 상태가 주어진다. 0은 빈 칸, 1은 적이 있는 칸이다.

## 제한

3 ≤ N, M ≤ 15

1 ≤ D ≤ 10

## 출력

첫째 줄에 궁수의 공격으로 제거할 수 있는 적의 최대 수를 출력한다.

## 문제풀이

bfs를 활용한 구현 문제이다. 한 번에 한 칸씩 내려가는 구조이기 때문에 N번 -> 1번 역순으로 방문하며 bfs를 진행했다.

주어진 위치는 3곳이기 때문에, M개의 위치(0 ~ M-1) 중 3개를 조합으로 선택한 후, N-1부터 0까지의 y와 조합하여 시작점들을 구성하고, 해당 위치(y, x)에서 위쪽에 배치된 적들 중 배치한 궁수와 가장 가까운 위치에 있는 적을 선별해야 했다. 그렇게 될 경우, 최대 3개의 적 좌표를 얻을 수 있다.

이 때, 각 궁수들이 동일한 적을 공격할 수 있다는 점을 의식해야 하기 때문에, 해당 적들을 모아서 마지막에 공격(1 -> 0 처리)를 진행해야 한다. 또한, 궁수들의 위치를 조합으로 선택하며 최대값을 갱신하기 때문에, deepcopy를 통해 원본을 보존하며 새로 복제한 배열만 변경해야 했다.

두 가지 조건을 고려하며 문제를 해결하면 쉽게 아이디어를 떠올릴 수 있는 구현 문제이다.

## 문제풀이 코드

```python
# 백준 17135
import sys
from itertools import combinations
from collections import deque
from copy import deepcopy

# N, M : 격자판의 크기(3 <= N, M <= 15)
# D : 궁수의 공격 거리 제한(1 <= D <=10)
# arr[i][j] = 0 : 빈 칸
# arr[i][j] = 1 : 적이 있는 칸
def solution(N, M, D, arr):
    def bfs(y, x, copied):
        que = deque()
        visited = [[0] * M for _ in range(y+1)]
        que.append((y, x, 1))
        visited[y][x] = 1

        while que:
            i, j, d = que.popleft()
            if copied[i][j] == 1:
                return i, j

            if d < D:
                for di, dj in dir:
                    ni = i + di
                    nj = j + dj
                    if 0 <= ni < N and 0 <= nj < M and visited[ni][nj] == 0:
                        que.append((ni, nj, d + 1))
                        visited[ni][nj] = 1
        return -1, -1
    def simulation(combi):
        copied = deepcopy(arr)
        cnt = 0
        for y in range(N-1, -1, -1):
            killed = set()
            for x in combi:
                i, j = bfs(y, x, copied)
                if i != -1 and j != -1:
                    killed.add((i, j))
            for ii, jj in killed:
                copied[ii][jj] = 0
                cnt += 1
        return cnt


    result = 0
    dir = [(0, -1), (-1, 0), (0, 1)]

    for combi in combinations(range(M), 3):
        result = max(result, simulation(combi))
    return result
N, M, D = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
print(solution(N, M, D, arr))
```

```java


```
