# 백준 문제 풀이

## bj 11881. 지우개(2025-09-05)

## 문제 유형

1. Count Array
2. Dynamic Programming

## 문제 설명

승현이는 우리에게 지우개를 훼손당할 수 있다는 생각에, 직접 지우개를 만들어 보기로 했습니다.

승현이는 자신이 좋아하는 자연수들로 구성된 수열 a1, a2, ⋯, an을 생각해 냅니다. 그리고, 이 수열에서 서로 다른 세 원소 ai, aj, ak를 선택한 뒤, 이들을 가로, 세로, 높이로 하는 직육면체 모양의 지우개를 만들고 이를 i−j−k 지우개라고 명명하기로 했습니다. 단 승현이는 위로 길쭉한 지우개를 좋아하므로, ai < aj < ak를 만족해야 합니다.

위 그림을 한 번 살펴봅시다. 승현이가 만든 수열을 a1=3, a2=1, a3=1, a4=2라고 둡시다. 1−2−3 지우개는 만들 수 없는데, 3<1<1은 성립하지 않기 때문입니다. 반면 2−4−1 지우개는 1 < 2 < 3이 성립하므로 만들 수 있습니다. 이 수열에서 만들 수 있는 지우개는 2−4−1 지우개와 3−4−1 지우개뿐입니다.

이때 승현이는 만들 수 있는 모든 지우개들의 부피의 합을 갑자기 알고 싶어집니다. (지우개의 부피는 가로 길이, 세로 길이와 높이의 곱입니다.) 아마 창고에 지우개를 쌓아 놓아야 하니 그렇겠죠? 승현이가 지우개를 보관할 창고를 설계할 수 있도록 우리가 도와줍시다.

## 입력

첫 번째 줄에 수열의 크기 n이 주어집니다. (1 ≤ n ≤ 100,000)

두 번째 줄에 a1, a2, ⋯, an이 공백을 사이로 두고 차례대로 주어집니다. (1 ≤ ai ≤ 100,000)

## 출력

첫 번째 줄에 만들 수 있는 지우개들의 부피의 합을 출력합니다. 승현이는 프로그램이 제대로 동작하는 것부터 검증하기를 원하므로, 1,000,000,007 (109+7)로 나눈 나머지를 출력합시다.

## 문제풀이

dp로 해결하는 문제이다. 예시를 활용하면 쉽다

1, 1, 2, 3으로 구성되어 있을 때, 각 요소에 대한 개수를 defaultdict으로 정리한 후, 정렬된 요소를 기준으로 dp를 구현하면 된다.

dp[i][j]는 1번 요소(가장 작은 값)부터 i번 요소(i번으로 작은 값)까지 중 3개를 선택하여 만들 수 있는 부피의 합을 의미한다. 따라서, 모든 dp[i][0]은 1이 된다(0개를 선택하여 만들 수 있는 경우는 1)

모든 i, j쌍에 대해 이전 dp값, 현재 i번 요소(v)와 해당 요소의 개수(c)를 활용하여 문제를 해결해야 한다.

i번까지 활용했을 때 j개를 선택해서 만들 수 있는 합은 다음과 같다

- i-1번까지 j개를 선택한 경우(dp[i-1][j])
- i-1번까지 j-1개를 선택하고, i번을 선택한 경우(dp[i-1][j-1] _ v _ c)

따라서, dp 점화식은 다음과 같다.

- dp[i][j] = (dp[i-1][j] + dp[i-1][j-1] _ v _ c)

## 문제풀이 코드

```python
# 백준 11881. 지우개
import sys
from collections import defaultdict

# N : 수열의 크기(1 <= N <= 100000)
# arr[i] : ai(1 <= ai <= 100000)
def solution(N, arr):
    MOD = 10 ** 9 + 7
    MAX = 100000

    case = set()
    counts = defaultdict(int)
    for n in arr:
        case.add(n)
        counts[n] += 1
    case = [0] + list(sorted(case))
    L = len(case)
    # dp[i][j] : 1번부터 i번까지 중 j개를 선택해서 곱했을 때의 경우의 합
    dp = [[0] * 4 for _ in range(L)]
    for i in range(L):
        dp[i][0] = 1

    for i in range(1, L):
        v = case[i]
        c = counts[v]

        for j in range(1, 4):
            dp[i][j] = (dp[i-1][j] + (dp[i-1][j-1] * v * c)) % MOD
    return dp[L-1][3]


N = int(input())
arr = list(map(int, input().split()))
print(solution(N, arr))
```

```java


```
