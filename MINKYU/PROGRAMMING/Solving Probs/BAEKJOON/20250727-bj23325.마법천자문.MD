# 백준 문제 풀이

## bj . (2025-)

## 문제 유형

1. Dynamic Programming(DP)
2. String

## 문제 설명

최근最近 만화漫畫 마법천자문魔法千字文을 감명感銘 깊게 읽은 연두然斗는, 모든 수數를 한자漢字로 적기 시작始作했다. 그런데 수업授業을 들으면서 필기筆記 해놓은 내용內容을 복습復習하던 도중途中, 도저到底히 알아볼 수 없는 식式을 발견發見했다.

+----+-+-

알고 보니 이 식은 숫자 10을 나타내는 "열 십 (十)"과 더하기를 나타내는 +, 숫자 1을 나타내는 "한 일 (一)"과 빼기를 나타내는 -가 뒤섞여 있어 알아볼 수 없던 것이었다. 이 식은 수많은 해석이 가능해서, 이왕이면 식의 계산 결과가 가장 큰 해석을 찾아보기로 했다. 마법천자문 정주행에 바쁜 연두를 대신해 여러분이 그 결과를 대신 찾아주자.

올바른 해석의 정의는 다음과 같다.

올바른 해석은 <수>, <수><연산자><수>, <수><연산자><수><연산자><수>, … 의 꼴이어야 한다.
즉, <수>로 시작해서 <수>로 끝나며, <수>와 <연산자>가 번갈아가며 위치해야 한다.
<수>는 +-, +, - 중 하나이며, 각각 11, 10, 1로 해석된다.
<연산자>는 +, - 중 하나이며, 각각 더하기, 빼기로 해석된다. -를 음의 부호로는 쓸 수 없는 것에 주의하자. 예를 들어, --는
$-1$이 될 수 없다.

## 입력

첫 번째 줄에 +, -로 이루어진 길이가 200,000이하인 문자열이 주어진다.

반드시 하나 이상의 올바른 해석이 존재하는 입력만 주어진다.

## 출력

주어진 문자열의 올바른 해석 중, 가장 큰 계산 결과를 출력한다.

## 문제풀이

dp 문제이다. 결국 수로 시작해서 수로 끝나는 연산식이기 때문에, 이를 고려하면 된다.

각 문자는 다음과 같이 해석 가능하다

1. 피연산자

- `-` : 1
- `+` : 10
- `+-` : 11

2. 연산자

- `+` : 덧셈
- `-` : 뺄셈

따라서, 각 인덱스에 저장된 문자에 대해, 해당 문자가 연산자로 계산될 때 지금까지 저장되었던 최대값을, 해당 문자가 피연산자로 계산될 때 앞선 문자가 연산자로 계산된 경우에 대한 추가 계산 결과의 최대값을 저장해야 한다

이에 앞서, 초기 경우에 대해 분기를 나누어야 한다.

문제 조건에 따르면, 반드시 해석 가능한 입력이 주어진다고 했다.

따라서

1. N = 1일 경우, <수>의 형태이다.

- 주어진 입력이 `-`일 경우, 1을 반환
- 주어진 입력이 `+`일 경우, 10을 반환

2. N = 2일 경우, <수><연산자>는 불가능하기 때문에, +-만 주어진다

- 11을 반환

3. N >= 3일 경우

- dp[i][0]에는 i번 인덱스에 저장된 문자열이 피연산자로 취급될 경우에 대한 최대값을 저장한다
- dp[i][1]에는 i번 인덱스에 저장된 문자열이 연산자로 취급될 경우 앞서 저장된 최대값을 저장한다
- 각 i에 대해, dp[i][1]에 dp[i-1][0]에 저장된 값을 할당한다
- 입력값이 `+`인 경우
  - -+인 경우, dp[i-1][1] - 10
  - ++인 경우, dp[i-1][1] + 10
- 입력값이 `-`인 경우
  - --인 경우, dp[i-1][1] - 1
  - +-인 경우(피연산자로 묶을 경우 ++- : +11, -+- : -11, 연산자로 묶을 경우 + 1)dp[i-2][1] + 11 또는 dp[i-2][1] - 11 또는 dp[i-1][1] + 1

이처럼 모든 인덱스에 대한 계산을 완료하고, N-1번 문자열이 피연산자로 계산될 경우에 대한 최대값(dp[N-1][0])을 반환해 주면 된다.

## 문제풀이 코드

```python
# 백준 23325
import sys

# string : +, -로 이루어진 문자열(1 <= len(string) <= 200000)
# string의 구조
# 피연산자 : +-(11), +(10), -(1)
# 연잔자 : +(plus), -(minus)
def solution(string):
    N = len(string)

    # for i in range(N):
    #     print(flags[i])
    if N == 1:
        if string[0] == '+':
            return 10
        if string[0] == '-':
            return 1
    elif N == 2:
        return 11

    # dp[i][0] : i번 값을 피연산자 취급 시 최대값
    # dp[i][1] : i번 값을 연산자 취급 시 최대값
    dp = [[-int(1e9)] * 2 for _ in range(N)]
    if string[0] == '-':
        dp[0][0] = 1
        dp[1][1] = 1
    elif string[0] == '+':
        dp[0][0] = 10
        dp[1][1] = 10
        if string[1] == '-':
            dp[1][0] = 11
    for i in range(2, N):
        dp[i][1] = dp[i-1][0]
        if string[i] == '+':
            if string[i-1] == '+':
                dp[i][0] = max(dp[i][0], dp[i-1][1] + 10)
            elif string[i-1] == '-':
                dp[i][0] = max(dp[i][0], dp[i-1][1] - 10)
        elif string[i] == '-':
            if string[i-1] == '+':
                dp[i][0] = max(dp[i][0], dp[i-1][1] + 1)
                if string[i-2] == '+':
                    dp[i][0] = max(dp[i][0], dp[i-2][1] + 11)
                elif string[i-2] == '-':
                    dp[i][0] = max(dp[i][0], dp[i-2][1] - 11)
            elif string[i-1] == '-':
                dp[i][0] = max(dp[i][0], dp[i-1][1] - 1)
    # for i in range(N):
    #     print(dp[i])
    return dp[N-1][0]

string = input()
print(solution(string))
```

```java


```
