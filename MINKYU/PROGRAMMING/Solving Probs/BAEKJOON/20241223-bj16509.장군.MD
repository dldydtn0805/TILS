# 백준 문제 풀이

## bj 16509. 장군(2024-12-23)

## 문제 설명

오랜만에 휴가를 나온 호근이는 문득 동아리방에 있는 장기가 하고 싶어졌다. 하지만 장기를 오랫동안 하지 않은 탓인지 예전에는 잘 쓰던 상을 제대로 쓰는 것이 너무 힘들었다. 호근이를 위해 상을 어떻게 써야 할지 도와주자.

만약 상이 이동하는 경로에 위 그림과 같이 다른 기물이 있다면 상은 그쪽으로 이동할 수 없다. 또한, 상이 장기판을 벗어날 수도 없다.

10×9 크기의 장기판 위에 상과 왕의 처음 위치가 주어졌을 때, 상이 왕에게 도달할 수 있는 최소 이동 횟수를 구하여라.

## 입력

첫 번째 줄에는 상의 위치를 의미하는 정수 R1, C1이 주어진다.

두 번째 줄에는 왕의 위치를 의미하는 정수 R2, C2가 주어진다. 장기판에서 Ri (0 ≤ Ri ≤ 9)는 행을, Ci (0 ≤ Ci ≤ 8)는 열을 의미한다.

왕은 항상 궁성에 자리 잡고 있으며, 상과 왕의 위치는 겹치지 않는다.

## 출력

상이 왕에게 도달할 수 있는 최소 이동 횟수를 출력한다. 만약 도달할 수 없다면 -1을 출력한다.

## 문제풀이

필요없는 조건이 좀 있어서 오히려 방해가 되었던 문제이다. bfs로 해결하였다. dir을 두 개로 분리해서 접근해야 한다는 것이 신박했던 문제였다.

## 문제풀이 코드

```python
# 백준 16509. 장군
import sys
from collections import deque

def bfs(R1, C1, R2, C2, dir1, dir2):
    que = deque()
    # visited[i][j] : (R1, C1) -> (i, j)로 가기위한 최소 횟수
    visited = [[-1] * 9 for _ in range(10)]
    que.append((R1, C1))
    visited[R1][C1] = 0

    while que:
        i, j = que.popleft()
        if i == R2 and j == C2:
            return visited[i][j]
        for d in range(8):
            di, dj = dir1[d]
            # 최종 경로
            ni = i + di
            nj = j + dj
            # 최종 경로 불가능 -> continue
            if not (0 <= ni < 10 and 0 <= nj < 9) or visited[ni][nj] != -1:
                continue
            flag = 1

            for ddi, ddj in dir2[d]:
                # 중간 경로
                nni = i + ddi
                nnj = j + ddj
                # 중간 경로에 왕 있음 -> 못넘어감
                if nni == R2 and nnj == C2:
                    flag = 0
                    break
            # 중간 경로에 왕이 있는 경우 continue
            if not flag:
                continue

            que.append((ni, nj))
            visited[ni][nj] = visited[i][j] + 1

    return -1

def solution():
    # R1, C1 : 상의 위치(0 <= R1 <= 9, 0 <= C1 <= 8)
    R1, C1 = map(int, input().split())
    # R2, C2 : 왕의 위치(0 <= R2 <= 9, 0 <= C2 <= 8)
    R2, C2 = map(int, input().split())
    '''
    (-1, 0) -> (-1, -1) -> (-1, -1)
    (-1, 0) -> (-1, 1) -> (-1, 1)

    (1, 0) -> (1, -1) -> (1, -1)
    (1, 0) -> (1, 1) -> (1, 1)

    (0, -1) -> (-1, -1) -> (-1, -1)
    (0, -1) -> (1, -1) -> (1, -1)

    (0, 1) -> (-1, 1) -> (-1, 1)
    (0, 1) -> (1, 1) -> (1, 1)
    '''
    dir1 = [(-3, -2), (-3, 2), (3, -2), (3, 2), (-2, -3), (2, -3), (-2, 3), (2, 3)]
    dir2 = {
        0 : [(-1, 0), (-2, -1)],
        1 : [(-1, 0), (-2, 1)],
        2 : [(1, 0), (2, -1)],
        3 : [(1, 0), (2, 1)],
        4 : [(0, -1), (-1, -2)],
        5 : [(0, -1), (1, -2)],
        6 : [(0, 1), (-1, 2)],
        7 : [(0, 1), (1, 2)],
    }
    print(bfs(R1, C1, R2, C2, dir1, dir2))

solution()
```
