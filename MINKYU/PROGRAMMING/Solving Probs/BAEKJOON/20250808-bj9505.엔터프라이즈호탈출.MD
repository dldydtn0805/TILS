# 백준 문제 풀이

## bj 9505. 엔터프라이즈호 탈출(2025-08-08)

## 문제 유형

1. Graph Search
2. Dijkstra

## 문제 설명

엔터프라이즈호가 클링온에게 포위되었다! 가장 빠른 시간 내에 나갈 수 있는 탈출 루트를 찾고 그 시간을 출력하라.

직사각형의 평면이 입력으로 주어지며, 이는 엔터프라이즈호와 클링온 전투선들의 위치들을 의미한다. 클링온 전투선은 몇 가지의 클래스로 나누어지며, 각 클래스의 클링온 전투선을 엔터프라이즈호가 무력화 시키는 데에 걸리는 시간도 입력으로 주어진다. 엔터프라이즈호는 탈출하는 경로에 있는 모든 클링온 전투선을 무력화 시키며 입력된 평면의 가장자리로 탈출한다. 입력된 평면의 단위 사각형은 꼭짓점이 아닌 가장자리로만 연결된다. (즉, 각 단위 사각형은 4개의 이웃 단위 사각형을 갖는다.)

## 입력

첫째 줄에 테스트 케이스의 개수 T (2 ≤ T ≤ 100)가 주어진다.

각 케이스는 첫 줄에 세개의 숫자 K, W, H가 주어진다.

K (1 ≤ K ≤ 25)는 클링온 전투선의 클래스 개수를 의미한다.

W (1 ≤ W ≤ 1000)는 평면의 폭을 의미한다.

H (1 ≤ H ≤ 1000)는 평면의 높이를 의미한다.

다음 K 줄에는 클링온 전투선의 클래스 이름과 무력화시키는 데에 걸리는 시간이 주어진다.

클링온 전투선의 클래스 이름은 알파벳 대문자로 주어지며, "E" 가될 수 없다. 클래스의 이름은 겹칠 수 없다.

무력화시키는 데에 걸리는 시간은 '분'을 나타내며 0 이상, 100,000 이하이다.

다음 H 줄에는 W 개의 알파벳 대문자가 주어진다. (각 문자 사이에는 공백이 없다.)

H 줄의 W 개 문자 중,

"E"는 엔터프라이즈호의 위치를 의미하며, 반드시 하나만 주어진다.

"E"가 아닌 다른 모든 문자는 해당 단위 평면에 위치한 클링온 전투선의 클래스이고, 반드시 위 K 줄에서 무력화시키는 데에 걸리는 시간과 함께 주어진다.

## 출력

엔터프라이즈호가 탈출하는 데에 걸리는 최소 시간을 정수로 출력하라.

## 문제풀이

다익스트라로 해결하는 문제이다. 그냥 대문자에 대응하는 숫자로 연결해서 다익스트라로 변환하면 된다. 딱히 이외의 것을 고려할 필요는 없는 문제라서 설명할 부분이 크게 없는 듯 하다

## 문제풀이 코드

```python
# 백준 9505
import sys
import heapq


# N, M : 평면의 높이, 너비(1 <= N, M <= 1000)
# K : 전투선 클래스 개수(1 <= K <= 25)
# info[i] : i번 전투선을 무력화시키는 데 걸리는 시간
# enterprize : 엔터프라이즈 호의 위치
#
def solution(N, M, K, info, enterprize, arr):
    pq = []
    visited = [[float('inf')] * M for _ in range(N)]
    heapq.heappush(pq, (0, enterprize[0], enterprize[1]))
    visited[enterprize[0]][enterprize[1]] = 0
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    while pq:
        dist, i, j = heapq.heappop(pq)
        if i == 0 or i == N-1 or j == 0 or j == M-1:
            return dist
        if visited[i][j] < dist:
            continue
        for di, dj in dir:
            ni = i + di
            nj = j + dj
            if not (0 <= ni < N and 0 <= nj < M):
                continue
            num = arr[ni][nj]
            d = info[num]
            if visited[ni][nj] <= dist + d:
                continue
            heapq.heappush(pq, (dist+d, ni, nj))
            visited[ni][nj] = dist+d
    result = float('inf')
    for i in range(N):
        for j in range(M):
            if i == 0 or i == N-1 or j == 0 or j == M-1:
                result = min(result, visited[i][j])
    return result
T = int(input())
for _ in range(T):
    K, M, N = map(int, input().split())
    info = [0] * 26
    for _ in range(K):
        cls = list(map(str, input().split()))

        name = ord(cls[0]) - ord('A')
        time = int(cls[1])
        info[name] = time
    arr = [[0] * M for _ in range(N)]
    enterprize = []
    for i in range(N):
        string = input()
        for j in range(M):
            s = string[j]
            if s == 'E':
                enterprize = [i, j]
            arr[i][j] = ord(string[j]) - ord('A')
    print(solution(N, M, K, info, enterprize, arr))
```

```java


```
