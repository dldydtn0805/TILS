# 백준 문제 풀이

## bj 14621. 나만 안되는 연애(2025-08-10)

## 문제 유형

1. Graph Theory
2. Mininum Spanning Tree(MST)
3. Union-Find

## 문제 설명

깽미는 24살 모태솔로이다. 깽미는 대마법사가 될 순 없다며 자신의 프로그래밍 능력을 이용하여 미팅 어플리케이션을 만들기로 결심했다. 미팅 앱은 대학생을 타겟으로 만들어졌으며 대학교간의 도로 데이터를 수집하여 만들었다.

이 앱은 사용자들을 위해 사심 경로를 제공한다. 이 경로는 3가지 특징을 가지고 있다.

사심 경로는 사용자들의 사심을 만족시키기 위해 남초 대학교와 여초 대학교들을 연결하는 도로로만 이루어져 있다.
사용자들이 다양한 사람과 미팅할 수 있도록 어떤 대학교에서든 모든 대학교로 이동이 가능한 경로이다.
시간을 낭비하지 않고 미팅할 수 있도록 이 경로의 길이는 최단 거리가 되어야 한다.
만약 도로 데이터가 만약 왼쪽의 그림과 같다면, 오른쪽 그림의 보라색 선과 같이 경로를 구성하면 위의 3가지 조건을 만족하는 경로를 만들 수 있다.

이때, 주어지는 거리 데이터를 이용하여 사심 경로의 길이를 구해보자.

## 입력

입력의 첫째 줄에 학교의 수 N와 학교를 연결하는 도로의 개수 M이 주어진다. (2 ≤ N ≤ 1,000) (1 ≤ M ≤ 10,000)

둘째 줄에 각 학교가 남초 대학교라면 M, 여초 대학교라면 W이 주어진다.

다음 M개의 줄에 u v d가 주어지며 u학교와 v학교가 연결되어 있으며 이 거리는 d임을 나타낸다. (1 ≤ u, v ≤ N) , (1 ≤ d ≤ 1,000)

## 출력

깽미가 만든 앱의 경로 길이를 출력한다. (모든 학교를 연결하는 경로가 없을 경우 -1을 출력한다.)

## 문제풀이

처음에는 dijkstra를 활용하려고 했다. 하지만, visited를 구성할 때 모든 경우가 시간초과에 걸릴 듯 했다.

문제 분류를 보니 MST였다. 결국, 주어진 edges들을 가중치를 기준으로 정렬하며 하나씩 union-find를 진행해야 했다.

두 대학교(u, v)가 서로 다르고(남 - 여 또는 여 - 남), 루트 노드가 다를 경우(find) union을 진행할 수 있다. 두 대학교를 묶어줄 경우, 해당 가중치를 결과값에 더해주고 연결된 대학교 개수를 추가한다.

모든 정보에 대해 완료한 후, 대학교 개수가 N-1일 경우 모든 대학교가 연결되었다는 뜻이다. 따라서, 최소값을 리턴한다. N-1보다 부족할 경우, -1을 출력한다

## 문제풀이 코드

```python
# 백준 14621
import sys
import heapq

# N : 대학교 수(2 <= N <= 1000)
# M : 길의 수(1 <= M <= 10000)
# univ[i] : i번 학교가 남초인지 여초인지(M, W)
# loads[i] : i번 학교와 연결된 학교 번호, 거리
def solution(N, M, univ, loads):
    parents = [i for i in range(N)]
    def find(x):
        if parents[x] != x:
            parents[x] = find(parents[x])
        return parents[x]
    def union(x, y):
        x = find(x)
        y = find(y)
        if x < y:
            parents[y] = x
        else:
            parents[x] = y
    edges.sort()
    cnt = 0
    result = 0
    for d, u, v in edges:
        if univ[u] == univ[v]:
            continue
        if find(u) == find(v):
            continue
        union(u, v)
        result += d
        cnt += 1
    if cnt == N-1:
        return result
    return -1

N, M = map(int, input().split())
univ = list(map(str, input().split()))
edges = []
for _ in range(M):
    u, v, d = map(int, input().split())
    edges.append((d, u-1, v-1))
print(solution(N, M, univ, edges))
```

```java


```
