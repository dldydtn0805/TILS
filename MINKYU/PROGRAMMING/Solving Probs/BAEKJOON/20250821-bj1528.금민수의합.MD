# 백준 문제 풀이

## bj 1528. 금민수의 합(2025-08-21)

## 문제 유형

1. Breadth First Search
2. Dynamic Programming

## 문제 설명

은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 4와 7로만 이루어진 수를 말한다.

N이 주어졌을 때, N을 금민수의 합으로 나타내는 프로그램을 작성하시오. 만약 여러 가지 방법이 존재하면, 수의 개수가 적은 것을 출력한다. 그러한 방법도 여러 개일 경우에는 사전순으로 가장 앞서는 것을 출력한다. 만약 N을 금민수의 합으로 표현할 수 없다면 -1을 출력한다.

N = a1+a2+...+ak가 N = b1+b2+...+bk보다 앞선다는 것은, ai ≠ bi인 가장 작은 i에 대해 ai < bi가 성립한다는 뜻이다.

## 입력

첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같다.

## 출력

첫째 줄에 정답을 공백을 사이에 두고 출력한다.

## 문제풀이

bfs를 활용하여 visited를 Memoization으로 사용하는 dp 문제이다.

금민수는 4, 7, 44, 47, ... 등 4와 7로만 이루어진 수이다. N을 금민수의 합 중 최소 개수로 구성된 경우, 사전순으로 나열 시 가장 먼저 오는 경우를 출력해 주어야 한다.

que에는 현재 저장된 수(금민수의 합으로 이루어진 수)를, visited에는 해당 값을 방문하기 직전 방문한 값(가장 가까운 금민수의 합)을 담아준다. 이렇게 될 경우, visited를 통해 역추적이 가능해진다.

만약 visited[N]이 -1일 경우, 금민수의 합으로는 N을 만들 수 없기에 -1을 리턴한다. -1이 아닐 경우, N에서 시작해서 직전 금민수의 합들을 역추적하며 해당 값을 만들기 위해 직전 금민수의 합들로 만든 수에 더해준 금민수를 넣어준다.

이렇게 만들어진 금민수 배열을 뒤집어 리턴해주면 해결할 수 있다.

## 문제풀이 코드

```python
# 백준 1528
import sys
from collections import deque

def get_gold_number():
    que = deque()
    gold_number = set()
    for n in (4, 7):
        que.append(n)
        gold_number.add(n)
    while que:
        now = que.popleft()
        for n in (4, 7):
            next = now * 10 + n
            if next > 1000000:
                continue
            if next in gold_number:
                continue
            que.append(next)
            gold_number.add(next)
    return sorted(list(gold_number))
gold_number = get_gold_number()
# print(gold_number)
# N : 4와 7로만 이루어진 수(금민수)의 합으로 나타낼 수(N <= 1000000)
def solution(N):
    def bfs(N):
        que = deque()
        visited = [-1] * (N+1)
        que.append(0)
        visited[0] = 0

        while que:
            now = que.popleft()
            if now == N:
                return visited
            for n in gold_number:
                next = now + n
                if next > N:
                    continue
                if visited[next] != -1:
                    continue
                que.append(next)
                visited[next] = now
        return visited
    backtracking = bfs(N)
    if backtracking[N] == -1:
        return [-1]

    result = []
    now = N
    while now > 0:
        next = backtracking[now]
        result.append(now-next)
        now = next
    return reversed(result)

N = int(input())
print(*solution(N))
```

```java


```
