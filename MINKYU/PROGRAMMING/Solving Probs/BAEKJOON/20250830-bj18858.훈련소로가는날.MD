# 백준 문제 풀이

## bj 18858. 훈련소로 가는 날(2025-08-30)

## 문제 유형

1. Dynamic Programming

## 문제 설명

훈련소로 가는 날 욱제는 문득 떠올렸다. 훈련소가 논산에 있는 이유는 무엇일까? 왜 why?

그것은 바로…

논산(non-산)은 산이 아니기 때문이다. 길이가 3인 수열 a1, a2, a3가 산임은 a1 < a2 > a3임을 의미한다. 어떤 수열이 논산임은 수열의 인접한 세 항이 산인 경우가 없음을 의미한다. 다시 말해, 길이 N의 수열 a에 대해 2 ≤ i < N 이고 ai-1 < ai > ai+1인 경우가 없다.

논산인 수열이 몇 개가 있는지 알아보자.

## 입력

첫째 줄에 N과 M이 주어진다.

## 제한

1 ≤ N ≤ 1,000

1 ≤ M ≤ 100

## 출력

1 이상 M 이하의 정수로 이루어진 길이 N의 수열 중 논산인 것의 개수를 998,244,353으로 나눈 나머지를 출력한다.

## 문제풀이

dp로 풀 수 있는 문제이다. 결국 사용 가능한 것은 다음과 같다.

1. 오르막 - 오르막
2. 오르막 - 평지
3. 평지 - 오르막
4. 평지 - 평지
5. 평지 - 내리막
6. 내리막 - 오르막
7. 내리막 - 평지
8. 내리막 - 내리막

즉, 오르막 - 내리막인 구조만 제외하면 된다.

따라서, dp를 다음과 같이 구성했다.

- dp[i][j][k] : 수열의 i번 수가 j일 때, 직전에 k일 경우(0 : 내리막, 1 : 평지, 2 : 오르막)

만약 N이 1 또는 2일 경우, 산 구조를 만들 수 없기 때문에(논산) 모든 경우가 가능하다

N이 3보다 클 경우, dp[2][j][k]에 대해

- k = 0일 경우, j-1개
- k = 1일 경우, 1개
- k = 2일 경우, M-j개

로 구성할 수 있다.

모든 i, j, k에 대해, 초기화 과정과 같이 반복해 주면 된다.

## 문제풀이 코드

```python
# 백준 18858
import sys

# N : 수열의 길이(1 <= N <= 1000)
# M : 수열에 포함되는 정수의 최대값(1 <= M <= 100)
def solution(N, M):
    MOD = 998244353
    if N == 1:
        return M
    if N == 2:
        return M**2
    # dp[i][j][0] : 수열의 i번 수가 j일 때 < 일 경우 논산인 경우의 수
    # dp[i][j][1] : 수열의 i번 수가 j일 때 > 일 경우 논산인 경우의 수
    # dp[i][j][2] : 수열의 i번 수가 j일 때 = 일 경우 논산인 경우의 수
    dp = [[[0] * 3 for _ in range(M+1)] for _ in range(N+1)]

    # j 기준 <  ==> j-1개
    # j 기준 =  ==> 1개
    # j 기준 >  ==> M-j개
    for j in range(1, M+1):
        dp[2][j][0] = j - 1
        dp[2][j][1] = 1
        dp[2][j][2] = M - j


    for i in range(2, N+1):
        for j in range(1, M+1):
            # j보다 작은 값들이 이전에 왔을 경우 : <
            # < <, = <, > <
            for k in range(1, j):
                for l in range(3):
                    dp[i][j][0] += dp[i-1][k][l]
                dp[i][j][0] %= MOD
            # j보다 큰 값들이 이전에 왔을 경우 : >
            # = >, > >
            for k in range(M, j, -1):
                for l in range(1, 3):
                    dp[i][j][2] += dp[i-1][k][l]
                dp[i][j][2] %= MOD
            # j와 같은 값이 이전에 왔을 경우
            # < =, = =, > =
            for l in range(3):
                dp[i][j][1] += dp[i-1][j][l]
            dp[i][j][1] %= MOD
    result = 0
    for j in range(1, M+1):
        for k in range(3):
            result += dp[N][j][k]
        result %= MOD
    return result
N, M = map(int, input().split())
print(solution(N, M))
```

```java


```
