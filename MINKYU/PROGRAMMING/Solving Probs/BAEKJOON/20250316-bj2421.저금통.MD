# 백준 문제 풀이

## bj 2421. 저금통(2025-03-16)

## 문제 설명

홍태석은 저금통 2개를 가지고 있다. 홍태석은 매일매일 하나의 저금통에 1원을 넣는다. 두 저금통에 모두 N원이 모이면 태석이는 새로운 장난감을 살 수 있기 때문에, 저금을 멈춘다.

홍태석은 소수를 좋아하는 것으로 서강대에서 유명하기 때문에, 첫째 저금통에 들어있는 돈의 양과 둘째 저금통의 돈의 양을 이어붙였을 때, 그것이 소수가 되는 것을 너무나도 좋아한다.

예를 들어, 첫째 저금통에 12원이 있고, 둘째 저금통에 7원이 있다고 하자. 그럼 그 두 수를 이은 127은 소수가 된다.

이제, 최대한 소수가 많이 나오도록, 홍태석이 돈을 넣는 최적의 순서를 찾아내면 된다. 가장 처음에 두 저금통에는 1원씩 들어있다.

예를 들어, N=4일 때를 보자.

1,1 → 2,1 → 2,2 → 3,2 → 3,3 → 4,3 → 4,4

위와같이 돈을 넣으면 소수는 오직 1번 등장한다. (43)

하지만, 다음과 같이 돈을 넣으면 소수는 3번 (31,41,43) 등장하게 된다.

1,1 → 2,1 → 3,1 → 4,1 → 4,2 → 4,3 → 4,4

위의 예가 N=4일 때 의 답이다. 가장 처음에 11은 세지 않는다.

## 입력

첫째 줄에 N이 주어진다. (1<=N<=999)

## 출력

첫째 줄에 소수가 가장 많이 나오는 저금 방법에서 소수가 나오는 횟수를 출력한다.

## 문제풀이

dp를 활용한 문제이다. 1000 X 1000짜리에 대해, 왼쪽 저금통에 i개, 오른쪽 저금통에 j개가 있을 경우에 대한 최대값을 dp[i][j]에 담았다.

점화식은 다음과 같다.

- dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + (ij가 소수일 경우 1, 아닐 경우 0)

저금통에 (i-1, j)개가 담긴 경우 또는 (i, j-1)개가 담긴 경우가 이전 상황이고, 이 경우 중 최대값에 현재 수(ij)가 소수인지에 대한 결과를 추가로 더해주면 된다.

## 문제풀이 코드

```python
# 백준 2421. 저금통
import sys

def get_primes():
    is_prime = [1] * (1000000)
    is_prime[0] = 0
    is_prime[1] = 0
    for i in range(2, 1001):
        if is_prime[i] == 0:
            continue
        for j in range(2*i, 1000000, i):
            is_prime[j] = 0
    return is_prime

is_prime = get_primes()

dp = [[0] * 1000 for _ in range(1000)]
for i in range(1, 1000):
    for j in range(1, 1000):
        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + int(is_prime[int(str(i) + str(j))] == 1)

def solution():
    # N : 두 저금통에 모이는 금액(1 <= N <= 999)
    N = int(input())
    print(dp[N][N] - 1)

solution()
```

```java

```
