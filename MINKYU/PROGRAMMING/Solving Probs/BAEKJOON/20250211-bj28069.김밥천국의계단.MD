# 백준 문제 풀이

## bj 28069. 김밥천국의 계단(2025-02-11)

## 문제 설명

민희는 미니김밥이 유명한 천국에 가려고 합니다.

천국 문 앞에는 무한히 많은 계단이 있고 가장 아래 계단의 번호가 0번이며, 위로 올라가면서 순서대로 번호가 붙어있습니다. 그중 N번째 계단 옆에 김밥 가게가 있습니다.

민희는 매번 다음의 2가지 행동 중 하나를 선택해서 총 K번 행동할 수 있으며, 정확히 K번째 행동에서 N번째 계단에 도달하면 미니김밥을 먹을 수 있습니다.

1. 계단 한 칸을 올라갑니다.
2. 민희가 집에서 가지고 온 지팡이를 계단에 두드립니다. 만약 민희가 i번째 계단에서 지팡이를 두드리면 i + i//2번째 계단으로 순간이동합니다.
   현재 민희는 0번째 계단에 있습니다. 민희가 미니김밥을 먹을 수 있을지 구해 봅시다.

## 입력

첫 번째 줄에 계단 개수에 해당하는 N, 계단을 오르는 횟수 K가 주어진다. (1 <= N, K <= 1,000,000)

## 출력

민희가 N개의 계단을 K번 만에 올라 미니김밥을 먹을 수 있으면 minigimbob을, 그러지 못해 물만 마신다면 water을 출력한다.

## 문제풀이

0에서 시작했을 때, 횟수만 늘리면서 0에 위치할 수 있음을 알아야 쉽게 풀 수 있는 dp 문제이다. 다시 말해, K번의 횟수 전에 N에 도착이 가능할 경우, K번에 딱 맞추어 N에 도착이 가능하기 때문에 dp에 각 인덱스 별로 최소 횟수를 저장하면 된다.

## 문제풀이 코드

```python
# 백준 28069. 김밥천국의 계단
import sys

def dynamic_programming(N, K):
    dp = [int(1e9)] * (N+1)
    dp[0] = 0
    for i in range(N+1):
        if i + 1 <= N:
            dp[i+1] = min(dp[i+1], dp[i] + 1)
        if i + i//2 <= N:
            dp[i+i//2] = min(dp[i+i//2], dp[i] + 1)
    # print(dp)
    if dp[N] <= K:
        return 'minigimbob'
    return 'water'

def solution():
    # N : 계단 수(1 <= N <= 1000000)
    # K : 계단을 오르는 횟수(1 <= K <= 100000)
    N, K = map(int, input().split())
    '''
    1. 계단 한 칸을 올라갑니다.
    2. 민희가 집에서 가지고 온 지팡이를 계단에 두드립니다.
    - 만약 민희가 i번째 계단에서 지팡이를 두드리면
    - i + int(i/2)번째 계단으로 순간이동합니다.
    '''
    print(dynamic_programming(N, K))

solution()
```
