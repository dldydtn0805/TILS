# 백준 문제 풀이

## bj 26607. 시루의 백화점 구경(2025-08-20)

## 문제 유형

1. Breadth First Search

## 문제 설명

시루는 부모님과 함께 백화점에 갔다. 부모님은 쇼핑할 것이 많기 때문에 여러 곳을 돌아다녀야 하고, 시루는 부모님과 함께 걸어다니는 것이 너무 힘들어서 의자에 앉아서 쉬려고 한다.

백화점은 세로 길이가 N, 가로 길이가 M인 격자 형태이고, 상하좌우로 인접한 칸으로 이동할 때마다 1 만큼의 체력을 소모한다. 시루는 현재 위치에서 출발해 백화점 곳곳에 있는 의자 중 하나를 찾아가서 앉으려고 한다. 시루는 백화점 밖으로 나가면 부모님께 혼나기 때문에 백화점 밖으로 나갈 수 없다.

백화점에는 건물을 지탱하기 위한 기둥과 옷을 전시하기 위한 마네킹이 있다. 시루는 기둥이 있는 칸으로 이동하지 못하고, 마네킹을 무서워하기 때문에 마네킹과 거리가 K 이하인 칸은 사용하지 않으려고 한다. 단, 시루가 출발할 때는 부모님과 함께 있기 때문에, 출발 지점과 마네킹과의 거리가
K 이하가 되어도 출발할 수 있다.

시루는 다리가 너무 아프기 때문에 체력 소모를 최소화하면서 의자까지 찾아가려고 한다. 시루가 소모하는 체력의 최솟값을 구해보자.

## 입력

첫째 줄에 백화점의 세로 길이, 가로 길이, 마네킹과 떨어져야 하는 거리를 의미하는 정수 N, M, K가 공백으로 구분되어 주어진다. (1 <= N,M <= 2,000, 0 <= K <= 4,000)

둘째 줄부터 N개의 줄에 각각 M개씩 위에서부터 차례로 백화점의 상태가 주어진다. 아무것도 없는 칸은 0, 기둥이 있는 칸은 1, 의자가 있는 칸은 2, 마네킹이 있는 칸은 3, 시루의 시작 위치는 4로 주어진다. 시루의 시작 위치는 정확히 한 번 주어지고, 해당 위치에 기둥, 의자, 마네킹이 존재하지 않는다.

## 출력

시루가 의자를 찾아갈 수 있다면 시루가 소모하는 체력의 최솟값을 출력한다.

만약 의자를 찾아갈 수 없다면 -1을 출력한다.

## 문제풀이

처음에는 단순한 bfs인줄 알고 접근했다. 마네킹들을 set으로 묶어서, 각 위치 별로 마네킹과의 거리를 계속 체크했더니 시간초과가 났다.

따라서, 각 마네킹을 1(기둥)으로 변경 후, 해당 마네킹들을 que에 집어넣어서 N X M의 이차원 배열에 대한 마네킹과의 거리가 K 이하인 경우에 대한 여부를 dists에 저장했다.

이후, 정상적으로 시작 위치에 대해 bfs를 진행했다.

쓸데없이 이상한 짓을 해서 괜한 고생을 한 문제이다. k가 0이 되는 경우를 고려해야 하는 문제라 이 부분을 놓쳤다..

## 문제풀이 코드

```python
# 백준 25307
import sys
from collections import deque

# N, M : 백화점의 크기(1 <= N, M <= 2000)
# K : 마네킹과 떨어져야 하는 거리(0 <= K <= 4000)
# arr[i][j] = 0 : 빈 칸
# arr[i][j] = 1: 기둥
# arr[i][j] = 2 : 의자
# arr[i][j] = 3 : 마네킹
# arr[i][j] = 4 : 시작 위치
def solution(N, M, K, arr):
    start_i = 0
    start_j = 0
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    is_in = [[0] * M for _ in range(N)]
    visited = [[0] * M for _ in range(N)]
    que = deque()

    for i in range(N):
        for j in range(M):
            if arr[i][j] == 4:
                start_i = i
                start_j = j
            elif arr[i][j] == 3:
                que.append((i, j, 0))
                is_in[i][j] = 1
                arr[i][j] = 1
    if K > 0:
        while que:
            i, j, k = que.popleft()
            if k == K:
                continue
            for di, dj in dir:
                ni = i + di
                nj = j + dj
                if not (0 <= ni < N and 0 <= nj < M):
                    continue
                if is_in[ni][nj] == 1:
                    continue
                que.append((ni, nj, k+1))
                is_in[ni][nj] = 1

    def bfs():
        que = deque()
        visited = [[0] * M for _ in range(N)]

        que.append((start_i, start_j, 0))
        visited[start_i][start_j] = 1
        while que:
            i, j, cnt = que.popleft()
            if arr[i][j] == 2:
                return cnt
            for di, dj in dir:
                ni = i + di
                nj = j + dj
                if not (0 <= ni < N and 0 <= nj < M):
                    continue
                if arr[ni][nj] == 1:
                    continue
                if visited[ni][nj] == 1:
                    continue
                if is_in[ni][nj] == 1:
                    continue
                que.append((ni, nj, cnt+1))
                visited[ni][nj] = 1
        return -1
    return bfs()

N, M, K = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]
print(solution(N, M, K, arr))
```

```java


```
