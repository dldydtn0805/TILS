# 백준 문제 풀이
## bj 17299. 오등큰수(2024-10-01)

## 문제 설명
    크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.
    Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.
    예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.

## 입력
    첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

## 출력
    총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.

## 문제풀이
    이 문제는 배열이 주어지고, 각 배열의 인덱스 별로 해당하는 숫자의 오등큰수를 구하는 문제이다. 만약, 해당 숫자의 오등큰수가 존재하지 않으면 이를 -1로 대체한다.
    처음에 보고 i번 인덱스에 해당하는 숫자의 오등큰수를 구하기 위해 접근하였다. 이렇게 접근할 경우, 결국 해당 인덱스보다 큰 모든 인덱스에 접근해야 하기 때문에 시간초과가 발생했다.
    내가 생각한 다른 방법은 i번 인덱스에 해당하는 숫자를 오등큰수로 가지는 수들을 찾는 것이다.
        1. i번 인덱스에 접근하여 숫자(num1 = arr[i])를 조회
        2. i번 인덱스를 오등큰수로 가질 수 있는 특정 후보군들에 접근하여 확인
    이 방법을 쓰기 위해서는, 특정 후보군들을 모아놔야 한다.
    특정 후보군들을 모을 배열으로 Stack을 활용하고, 해당 Stack의 top에 위치한(현재 접근한 인덱스 i보다 작은 인덱스들, 그리고 top 인덱스에는 그 중 가장 큰(i와 가장 가까운)) 인덱스를 활용하였다.
    또한, 0번 인덱스부터 조회하는 방법과, N-1번 인덱스부터 조회하는 방법 두 가지로 문제를 풀어보았다.
    
    이 문제에서 핵심은 Stack에 남아있는 인덱스의 정의이다.
        Stack에는 오등큰수를 찾고 싶어하는 숫자가 위치한 인덱스(j)들을 담고 있다.
        즉, 아직 자기 자신보다 큰 인덱스에 위치하면서(j < i), 배열 내의 숫자 개수가 더 큰 숫자(F[j] < F[i])를 찾지 못했다는 뜻이다.
        결국, Stack에 담긴 인덱스(j = stack[-1])가 위의 조건을 만족하는 숫자(arr[i] = num1)를 찾을 경우, 결과값에 값을 대입하고(result[j] = arr[i]) Stack에서 해당 인덱스를 제거(stack.pop())하면 된다. 현재 조회중인 인덱스 i는 새로운 후보군이 되기 위해 Stack에 추가(stack.append(i))된다.

## 문제풀이 코드 - 1
```python
# 백준 17299. 오등큰수
import sys
from collections import defaultdict
input = sys.stdin.readline

# N : 수열의 크기(1 <= N <= 1000000)
N = int(input().rstrip())
# arr[i] : i번 인덱스에 위치한 숫자
arr = list(map(int, input().rstrip().split()))
# F[num] : 배열 내의 num의 개수
F = defaultdict(int)
for n in arr:
    F[n] += 1

# 출력할 결과값을 담을 배열
result = [-1] * N
# 조회한 인덱스를 오등큰수로 가질 수 있는 후보군 배열
stack = []

# 풀이 1. 0번부터 조회
for i in range(N):
    # num1를 오등큰수로 하는 위치 찾기
    num1 = arr[i]
    while stack:
        # j는 i보다 더 먼저 위치한 수들
        # arr[j]의 오등큰수가 arr[i]가 될 수 있을까?
        j = stack.pop()
        num2 = arr[j]
        # num2의 오등큰수가 num1이 될 조건 성립 X -> 넘겨(원상복구)
        if F[num1] <= F[num2]:
            stack.append(j)
            break
        # 조건 성립 -> j기준에서는 아직 마땅한 i를 만나지 못하다가 처음으로 만남
        # -> 할당
        result[j] = num1
    stack.append(i)

print(result)
```
## 문제풀이 코드 - 2
```python
# 백준 문제 풀이
## bj 17299. 오등큰수(2024-10-01)

## 문제 설명
    크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.
    Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.
    예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.

## 입력
    첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

## 출력
    총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.

## 문제풀이
    이 문제는 배열이 주어지고, 각 배열의 인덱스 별로 해당하는 숫자의 오등큰수를 구하는 문제이다. 만약, 해당 숫자의 오등큰수가 존재하지 않으면 이를 -1로 대체한다.
    처음에 보고 i번 인덱스에 해당하는 숫자의 오등큰수를 구하기 위해 접근하였다. 이렇게 접근할 경우, 결국 해당 인덱스보다 큰 모든 인덱스에 접근해야 하기 때문에 시간초과가 발생했다.
    내가 생각한 다른 방법은 i번 인덱스에 해당하는 숫자를 오등큰수로 가지는 수들을 찾는 것이다.
        1. i번 인덱스에 접근하여 숫자(num1 = arr[i])를 조회
        2. i번 인덱스를 오등큰수로 가질 수 있는 특정 후보군들에 접근하여 확인
    이 방법을 쓰기 위해서는, 특정 후보군들을 모아놔야 한다.
    특정 후보군들을 모을 배열으로 Stack을 활용하고, 해당 Stack의 top에 위치한(현재 접근한 인덱스 i보다 작은 인덱스들, 그리고 top 인덱스에는 그 중 가장 큰(i와 가장 가까운)) 인덱스를 활용하였다.
    또한, 0번 인덱스부터 조회하는 방법과, N-1번 인덱스부터 조회하는 방법 두 가지로 문제를 풀어보았다.
    
    이 문제에서 핵심은 Stack에 남아있는 인덱스의 정의이다.
        Stack에는 오등큰수를 찾고 싶어하는 숫자가 위치한 인덱스(j)들을 담고 있다.
        즉, 아직 자기 자신보다 큰 인덱스에 위치하면서(j < i), 배열 내의 숫자 개수가 더 큰 숫자(F[j] < F[i])를 찾지 못했다는 뜻이다.
        결국, Stack에 담긴 인덱스(j = stack[-1])가 위의 조건을 만족하는 숫자(arr[i] = num1)를 찾을 경우, 결과값에 값을 대입하고(result[j] = arr[i]) Stack에서 해당 인덱스를 제거(stack.pop())하면 된다. 현재 조회중인 인덱스 i는 새로운 후보군이 되기 위해 Stack에 추가(stack.append(i))된다.

## 문제풀이 코드 - 1
```python
# 백준 17299. 오등큰수
import sys
from collections import defaultdict
input = sys.stdin.readline

# N : 수열의 크기(1 <= N <= 1000000)
N = int(input().rstrip())
# arr[i] : i번 인덱스에 위치한 숫자
arr = list(map(int, input().rstrip().split()))
# F[num] : 배열 내의 num의 개수
F = defaultdict(int)
for n in arr:
    F[n] += 1

# 출력할 결과값을 담을 배열
result = [-1] * N
# 조회한 인덱스를 오등큰수로 가질 수 있는 후보군 배열
stack = []

# 풀이 2. N-1번부터 조회
for i in range(N-1, -1, -1):
    # i번에 위치한 숫자
    num1 = arr[i]
    
    # stack에 숫자가 있을 경우, 해당 숫자 j는 i보다 오른쪽에 위치
    while stack:
        # j : i보다 크면서, i에 가장 가까운 위치에 있는 후보 index
        j = stack[-1]
        # j번에 위치한 숫자
        num2 = arr[j]
    
        # i < j, F[num1] < F[num2] -> num1의 오등큰수는 num2 만족
        if F[num1] < F[num2]:
            result[i] = num2
            break
        stack.pop()
    
    stack.append(i)

print(result)
```
