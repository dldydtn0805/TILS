# 백준 문제 풀이
## bj 14712. 넴모넴모(Easy)(2024-10-08)

## 문제 설명
    네모는 뿌××× 게임에 깊은 감명을 받아, 직사각형 모양의 격자판과 “넴모”라는 수수께끼의 생물을 이용하는 “넴모넴모”라는 게임을 만들었다. 이 게임의 규칙은 아주 간단하다. 격자판의 비어 있는 칸을 임의로 골라 “넴모”를 하나 올려놓거나, “넴모”가 올라간 칸 네 개가 2 × 2 사각형을 이루는 부분을 찾아 그 위에 있는 “넴모”들을 모두 없애는 것을 질릴 때까지 반복하면 된다.
    하지만 안타깝게도 게임은 정말 재미가 없었고, 네모는 아주 빨리 질려 버리고 말았다. 실망한 네모는 게임을 적당히 플레이하다가, “넴모”를 없애고 싶은데 격자판 위에 없앨 수 있는 “넴모”가 없으면 게임을 그만두기로 했다. 네모가 게임을 그만두었을 때 나올 수 있는 “넴모”의 배치의 가짓수를 구하여라.

## 입력
    첫 번째 줄에 격자판의 행의 개수 N, 열의 개수 M(1 ≤ N, M ≤ 25, 1 ≤ N × M ≤ 25)이 공백으로 구분되어 주어진다.

## 출력
    첫 번째 줄에 주어진 격자판에서 나올 수 있는, “넴모”들이 올라간 칸이 2 × 2 사각형을 이루지 않는 모든 배치의 가짓수를 출력한다.

## 문제풀이
    입력 케이스가 굉장히 작아서 모든 경우의 수를 다 구할 수 있다고 판단했다. 모든 점에서 추가했을 때, 네모가 만들어지지 않을 때를 구해야 하는 문제이기 때문에 각 조건에 맞게 분기 별 조건에 만족하는 경우를 백트래킹으로 해결하였다.
    
## 문제풀이 코드
```python
# 백준 14712. 넴모넴모
import sys
input = sys.stdin.readline

# (i, j)에 네모를 넣어도 2 X 2 네모가 되지 않는지 확인
def check(i, j):
    if i >= 1 and j >= 1 and arr[i][j] == 0 and arr[i-1][j-1] == 0 or arr[i-1][j] == 0 or arr[i][j-1] == 0:
        return True
    return False

# (i, j)에서 백트래킹
def backtracking(i, j):
    global result

    # 종료 조건 (N-1, M-1) -> (N, M) -> (N, 0)
    if i == N and j == 0:
        result += 1
        return

    # 새로운 ni, nj(같은 행 오른쪽 열 or 다음 행 0번 열)
    ni = i + int((j + 1) % M == 0)
    nj = (j + 1) % M
    # i, j에 네모 X
    backtracking(ni, nj)

    # i, j에 네모 가능
    if check(i, j):
        arr[i][j] = 1
        backtracking(ni, nj)
        arr[i][j] = 0

# N, M : 격자판의 행과 열의 개수(1 <= N, M <= 25, 1 <= N * M <= 25)
N, M = map(int, input().rstrip().split())
arr = [[0] * M for _ in range(N)]

result = 0
backtracking(0, 0)
print(result)
```