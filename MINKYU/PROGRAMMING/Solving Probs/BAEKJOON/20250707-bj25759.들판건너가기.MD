# 백준 문제 풀이

## bj 25759. 들판 건너가기(2025-07-07)

## 문제 설명

농부는 N개의 꽃이 일렬로 활짝 핀 들판을 왼쪽에서 오른쪽으로 걷고 있다. 심심한 농부는 들판에 핀 꽃을 몇 개 따서 꽃다발을 만들려 한다.

꽃다발의 아름다움은 꽃을 딴 순서대로 놓았을 때 (인접한 꽃의 아름다움 차이)^2의 전체 합으로 정의된다.

산수를 어려워하는 농부는 가장 아름다운 꽃다발을 만들 수 있는 방법을 물어봤다. 농부가 만들 수 있는 꽃다발의 가장 높은 아름다움 값을 구해주자.

## 입력

첫 번째 줄에 들판에 핀 꽃의 개수 N이 주어진다. (2 <= N <= 100,000)

두 번째 줄에 i번째 꽃의 아름다움 값 A_i이 공백으로 구분되어 주어진다. (1 <= A_i <= 100)

## 출력

꽃다발의 가장 높은 아름다움 값을 출력한다.

## 문제풀이

조금 특이한 dp 문제였다. 처음에는 꽃의 개수가 최대 10만 개이기 때문에 접근이 어려웠지만, 단일 꽃의 아름다움이 최대 100이었기 때문에, dp를 101 크기의 일차원 배열로 구현할 수 있었다.

dp[k]는 마지막으로 선택된 꽃의 아름다움이 k일 경우의 아름다움의 합 최대값을 의미한다.

초기 값에 대한 dp만 0으로 초기화 한 후, 2번 꽃부터 마지막 꽃까지 순회하며 1 ~ 최대 아름다움 사이의 꽃에 대해 이미 선택된 경우 갱신하는 방식으로 순회하였다.

## 문제풀이 코드

```python
# 백준 25759
import sys

# N : 꽃의 개수(2 <= N <= 100000)
# arr[i] : i번째 꽃의 아름다움의 값(1 <= arr[i] <= 100)
def solution(N, arr):
    MAX = max(arr)
    # dp[k] : 마지막 선택한 꽃의 값이 k일 때 최대 아름다움 합
    dp = [-1] * (MAX+1)
    dp[arr[1]] = 0
    for i in range(2, N+1):
        # 선택하려고 하는 현재 꽃의 아름다움
        k = arr[i]
        for j in range(1, MAX+1):
            # 마지막으로 j만큼의 아름다움을 가진 꽃이 선택되었을 경우
            if dp[j] != -1:
                dp[k] = max(dp[k], dp[j] + (k-j)**2)
    # print(dp)
    return max(dp)

N = int(input())
arr = [0] + list(map(int, input().split()))
print(solution(N, arr))
```

```java


```
