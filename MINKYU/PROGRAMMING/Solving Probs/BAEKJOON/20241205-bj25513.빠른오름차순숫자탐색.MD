# 백준 문제 풀이

## bj 25513. 빠른 오름차순 숫자 탐색(2024-12-05)

## 문제 설명

5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자에는 -1, 0, 1, 2, 3, 4, 5, 6중 하나의 수가 적혀 있다. 격자의 위치는 (r, c)로 표시한다. r은 행 번호, c는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다. -1이 적혀 있는 칸으로는 이동할 수 없고 0, 1, 2, 3, 4, 5, 6이 적혀 있는 칸으로는 이동할 수 있다.

현재 한 명의 학생이 (r, c) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한가지 방향으로 한 칸 이동할 수 있다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하려고 한다. 보드에는 1, 2, 3, 4, 5, 6이 적혀 있는 칸이 1개씩 존재하고 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 여러 번 방문할 수 있다. 즉, 1이 적혀 있는 칸에서 2가 적혀 있는 칸으로 이동하고, 2가 적혀 있는 칸에서 3이 적혀 있는 칸으로 이동하고, ... , 5가 적혀 있는 칸에서 6이 적혀 있는 칸으로 이동한다. i가 적혀 있는 칸에서 i + 1이 적혀 있는 칸으로 이동할 때 다른 번호가 적힌 칸을 방문해도 된다.(1 ≤ i ≤ 5) 마찬가지로, 현재 위치 (r, c)에서 1이 적혀 있는 칸으로 이동할 때 다른 번호가 적힌 칸을 방문해도 된다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하는 최소 이동 횟수를 출력하자. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문할 수 없는 경우 -1을 출력한다.

## 입력

첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 각 칸에 적혀있는 수가 순서대로 주어진다. i번째 줄의 j번째 수는 보드의 (i - 1)번째 행, (j - 1)번째 열에 적혀있는 수를 나타낸다. 보드의 각 칸에 적혀 있는 수는 -1, 0, 1, 2, 3, 4, 5, 6중 하나이다. 1부터 6까지의 숫자는 모두 한 번씩 적혀 있다.
다음 줄에 학생의 현재 위치 r, c(0 <= r, c <= 4)가 빈칸을 사이에 두고 순서대로 주어진다.

## 출력

학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하는 최소 이동 횟수를 출력한다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문할 수 없는 경우 -1을 출력한다.

## 문제풀이

다양한 방식으로 해결 가능한 문제인 것 같다. dp로 풀어도, bfs로 풀어도, dfs로 풀어도, dijkstra로 풀어도 될 것 같다. 나는 bfs로 해결하였다. visited를 3차원으로 구성하여 (방문한 숫자, i좌표, j좌표)를 기준으로 방문 여부를 판단하였다. 앞서 방문한 좌표를 재방문할 수 있기 때문에, 이를 해당 위치를 방문하였을 때를 기준으로 가장 최근에 방문한 숫자(1 ~ 6)를 기준으로 방문여부를 파악하였다.

## 문제풀이 코드

```python
# 백준 25513. 빠른 오름차순 숫자 탐색
import sys
from collections import deque

def bfs(r, c, arr, dir):
    que = deque()
    visited = [[[0] * 5 for _ in range(5)] for _ in range(7)]
    que.append((r, c, 0, 0))
    visited[0][r][c] = 1
    while que:
        i, j, now, cnt = que.popleft()
        if now == 6:
            return cnt

        next = now + 1
        for di, dj in dir:
            ni = i + di
            nj = j + dj
            if not (0 <= ni < 5 and 0 <= nj < 5):
                continue
            if arr[ni][nj] == -1:
                continue
            if arr[ni][nj] == next and visited[next][ni][nj] == 0:
                que.append((ni, nj, next, cnt+1))
                visited[next][ni][nj] = 1
            elif arr[ni][nj] != next and visited[now][ni][nj] == 0:
                que.append((ni, nj, now, cnt+1))
                visited[now][ni][nj] = 1
    return -1



def solution():
    arr = [list(map(int, input().split())) for _ in range(5)]
    r, c = map(int, input().split())
    dir = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    print(bfs(r, c, arr, dir))

solution()
```
