# 백준 문제 풀이

## bj 14404. 동전시스템(2025-08-13)

## 문제 유형

1. Integer Theory
2. Euclid Theory
3. Dynamic Programming

## 문제 설명

영선이가 살고 있는 나라에는 두 종류의 동전 A와 B가 있다. 이 나라의 모든 제품은 A*p + B*q (p와 q는 음이 아닌 정수)의 형태이기 때문에, 두 동전만 있어도 충분하다.

영선이는 어느 날 다른 동전 시스템으로도 이 나라의 모든 제품의 가격을 만들 수 있는지 궁금해졌다.

A와 B, X가 주어졌을 때, A*p + B*q 형태의 가격을 모두 만들 수 있는 두 동전의 가치를 구하는 프로그램을 작성하시오. 이때, 한 동전의 가치는 X이고, 다른 동전의 가치는 Y(≠X)이다. X는 입력으로 주어지기 때문에, Y를 구하는 것이 문제이다.

## 입력

첫째 줄에 A, B, X (1 ≤ A, B, X ≤ 200)이 주어진다.

## 출력

첫째 줄에 가능한 Y의 개수를 출력한다. 만약, 가능한 Y가 무한대라면 -1을 출력한다.

## 문제풀이

유클리드 호제법을 이용한 DP 문제이다.

A, B의 각 곱에 대한 합으로 만들 수 있는 모든 정수들이 X, Y의 각 곱에 대한 합으로 만들 수 있는 모든 정수들에 포함되어있는지를 봐야 하는 문제이다.

A, B를 통해 기준으로 삼을 DP를 만들고, 1 ~ 200 사이의 Y에 대해 DP를 만들어서 각 수에 대해 첫 번째 DP에서는 가능하지만 두 번째 DP에서는 불가능한 경우가 있으면 해당 Y로는 안된다.

만약, A와 B의 최대공약수로 X를 나눌 경우, 나머지가 0이 되면 모든 Y에 대해 0을 곱하면 가능하기 때문에 -1을 출력한다.

## 문제풀이 코드

```python
# 백준 14404
import sys
from math import gcd
# A, B : 동전 종류(1 <= A, B <= 200)
# X : A * p + B * q 형태의 가격을 모두 만들 수 있는 동전의 가치(1 <= X <= 200)

def solution(A, B, X):
    gcd_AB = gcd(A, B)
    if gcd_AB % X == 0:
        return -1

    dp_AB = [0] * 40001
    for i in range(0, 40001, A):
        dp_AB[i] = 1
    for i in range(B, 40001):
        if dp_AB[i-B] == 1:
            dp_AB[i] = 1

    dp_XY = [0] * 40001
    for i in range(0, 40001, X):
        dp_XY[i] = 1

    result = 0
    for Y in range(1, 201):
        if gcd_AB % gcd(X, Y) != 0:
            continue

        dp = dp_XY[:]
        for i in range(Y, 40001):
            if dp[i-Y] == 1:
                dp[i] = 1

        for i in range(40001):
            if dp_AB[i] == 1 and dp[i] == 0:
                break
        else:
            result += 1

    return result
A, B, X = map(int, input().split())
print(solution(A, B, X))
```

```java


```
