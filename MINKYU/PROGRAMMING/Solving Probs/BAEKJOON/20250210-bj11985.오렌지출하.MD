# 백준 문제 풀이

## bj 11985. 오렌지 출하(2025-02-10)

## 문제 설명

Juicy Orange Industry(JOI)는 맛있는 오렌지를 포장해서 출하하는 것이 주된 업무인 회사이다.

JOI사에서는 수집한 N개의 오렌지를 상자에 넣어서 출하한다. 먼저, 오렌지는 공장에 있는 컨베이어 벨트 위에 나란히 놓아야 한다. 컨베이어 벨트 위에 놓여져있는 오렌지는 앞에서부터 순서대로 1부터 N까지 번호가 붙여져 있다. i번째 오렌지의 크기는 Ai이다.

그 다음 작업은 오렌지를 앞에서부터 순서대로 상자에 나눠서 넣는 것이다. 한 상자 넣는 오렌지의 번호는 연속해야 한다.

한 상자에는 최대 M개의 오렌지를 넣을 수 있다. 상자에 오렌지를 넣는 비용은 K + s × (a − b) 로 구할 수 있다. 여기서 a는 상자에 넣은 가장 큰 오렌지의 크기, b는 상자에 넣은 가장 작은 오렌지의 크기, s는 상자에 넣은 오렌지의 개수이다. K는 상자를 포장하는 비용이고, 모든 상자에 공통적으로 적용되는 값이다.

컨베이어 벨트 위에 놓여져 있는 오렌지의 정보와, 한 상자에 넣을 수 있는 오렌지 개수의 최댓값, 상자를 포장하는 비용 K가 주어졌을 때, 모든 오렌지를 포장하는 비용의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 오렌지의 개수 N (1 ≤ N ≤ 20,000), 한 상자에 넣을 수 있는 오렌지 개수의 최댓값 M (1 ≤ M ≤ 1,000, M ≤ N), 상자를 포장하는 비용 K (0 ≤ k ≤ 1,000,000,000)가 주어진다.

둘째 줄부터 N개의 줄에는 오렌지의 크기 Ai (1 ≤ Ai ≤ 1,000,000,000)가 순서대로 주어진다.

## 출력

첫째 줄에 모든 오렌지를 포장하는 비용의 최솟값을 출력한다.

## 문제풀이

dp 문제이다. N, M이 주어졌기에 처음에는 2차원 배열로 구현하려 했지만, N과 M의 범위가 20000, 1000이기 때문에 메모리초과와 시간초과가 걸렸다.
따라서, dp를 1차원 배열로 구현하고, 각 i에 대해 앞에 위치한 인덱스와 비교하며 최대, 최소값을 갱신한 후, dp를 갱신하였다.

1. dp를 최대값(float('inf'))이 담긴 (N+1)개의 인덱스를 가진 배열로 초기화한다.
2. dp의 0번, 1번 인덱스를 각각 0, K로 갱신한다

- 아무것도 포장하지 않았을 경우 : 0
- 1개만 포장했을 경우 : K + 1 \* (arr[0] - arr[0]) = K

3. 2 ~ N+1번 인덱스에 대해 다음과 같은 과정을 거친다

- 주어진 i번 인덱스에 대해 max_v, min_v를 초기화한다
  - max_v = arr[i], min_v = arr[i]
- 포장하려는 오렌지의 개수 s를 설정한다
  - s의 범위 : 1 ~ i(1개부터 i개까지)
  - 이 때, s는 M을 넘어갈 수 없다
- s개로 설정했을 때의 시작 인덱스 j(j = i - s + 1)를 기준으로 하여 갱신한다
  - max_v 갱신
  - min_v 갱신
  - dp[i] 갱신(현재 저장된 값 vs j-1번까지 저장했을 때의 최소비용 + 비용 공식)

## 문제풀이 코드

```python
# 백준 11985. 오렌지 출하
import sys

def dynamic_programming(N, M, K, arr):
    # K + S(a-b)
    # dp[i] : i번 오렌지까지 포장했을 때 최소 비용 합
    dp = [float('inf')] * (N+1)
    dp[0] = 0
    dp[1] = K
    for i in range(2, N+1):
        min_v = arr[i]
        max_v = arr[i]
        for s in range(1, min(i+1, M+1)):
            j = i-s+1
            max_v = max(max_v, arr[j])
            min_v = min(min_v, arr[j])
            dp[i] = min(dp[i], dp[j-1] + K + s * (max_v - min_v))

    return dp[N]
def solution():
    # N : 오렌지의 개수(1 <= N <= 20000)
    # M : 한 상자에 넣을 수 있는 오렌지 개수의 최대값(1 <= M <= 1000)
    # K : 상자를 포장하는 비용(0 <= K <= 1000000000)
    N, M, K = map(int, input().split())
    arr = [0] + [int(input()) for _ in range(N)]
    print(dynamic_programming(N, M, K, arr))

solution()
```
