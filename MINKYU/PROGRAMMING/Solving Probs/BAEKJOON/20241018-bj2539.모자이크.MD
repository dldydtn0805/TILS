# 백준 문제 풀이
## bj 2539. 모자이크(2024-10-18)

## 문제 설명
    수찬이는 선생님을 도와서 교실 벽면을 장식할 모자이크 그림을 그리기로 하였다. 이를 위하여 직사각형 모양의 큰 도화지를 준비하여 교실 벽에 붙이고 1cm 간격으로 가로선과 세로선을 그려서 정사각형 모양의 칸을 만들고, 각 칸마다 같은 색의 물감으로 색칠을 하였다. 그런데 잘못 칠해진 칸이 있음을 발견하게 되었다.

    수찬이는 도화지와 색깔이 같은 색종이를 사서 잘못 칠해진 칸에 색종이를 붙이고 다시 그리는 것이 좋겠다고 생각하고 선생님께 상의를 드렸다. 선생님께서는 정해진 장수의 색종이를 사용하여 아래와 같은 조건을 따르면서 잘못 칠해진 칸을 모두 가리되, 가장 작은 색종이의 크기를 구하는 새로운 문제를 내셨다.

        1. 사용되는 색종이는 모두 크기가 같고 정사각형 모양이다.   
        2. 색종이 크기는 한 변의 길이로 나타내며, 원하는 크기의 색종이는 모두 구할 수 있다.
        3. 모든 색종이는 반드시 도화지의 밑변에 맞추어 붙인다. 이때 색종이를 겹쳐서 붙일 수 있다.
    
    도화지 위의 행은 다음 그림과 같이 맨 아래에서 위쪽으로 1번부터 순서대로 번호가 매겨져 있고, 열은 왼쪽에서 오른쪽으로 1번부터 번호가 매겨져 있다. 이 그림은 도화지에 가로선과 세로선을 그어서 4개의 행과 14개의 열, 그리고 56개의 칸으로 나눈 모양을 보여준다. 잘못 칠해진 칸은 회색으로 표시되어 있다.

![](https://upload.acmicpc.net/c954c2d8-b39f-4918-bba7-9a3ea6fb0d14/-/preview/)

    도화지 위의 칸은 행 번호와 열 번호로 나타낸다. 예를 들어 위 그림에서 가장 왼쪽에 있는 잘못 칠해진 칸 A의 위치는 (2, 1)이다. 위 그림과 같이 도화지에서 잘못 칠해진 칸이 9개 주어지고 색종이 4장을 사용한다면 가장 작은 색종이의 크기는 3cm이다.

    도화지의 행의 개수와 열의 개수, 그리고 도화지에 잘못 칠해진 칸들의 위치가 주어질 때, 주어진 장수의 색종이를 사용하여 앞의 세 가지 조건에 따라 모든 잘못 칠해진 칸을 가릴 수 있는 가장 작은 색종이의 크기를 구하는 프로그램을 작성하시오.

## 입력
    첫째 줄에는 도화지 위의 행의 개수와 열의 개수를 나타내는 자연수가 빈칸을 사이에 두고 주어진다. 행의 개수와 열의 개수는 모두 1000000 이하이다. 둘째 줄에는 사용할 색종이의 장수를 나타내는 자연수가 주어진다. 사용할 색종이는 100장 이하이다. 셋째 줄에는 도화지에 잘못 칠해진 칸의 개수를 나타내는 자연수가 주어진다. 잘못 칠해진 칸은 1000개 이하이다. 넷째 줄부터 마지막 줄까지 잘못 칠해진 칸의 위치가 한 줄에 하나씩 주어진다. 잘못 칠해진 칸의 위치는 빈칸을 사이에 두고 행 번호가 주어진 다음 열 번호가 주어진다.

## 출력
    첫째 줄에 주어진 장수의 색종이를 사용하여 잘못 칠해진 칸을 모두 가릴 수 있는 가장 작은 색종이의 크기가 몇 cm인지를 나타내는 자연수를 출력한다.

## 문제풀이
    처음에는 주어진 행과 열의 범위(~100000), 최소값이라는 힌트를 보고도 이진탐색인 것을 알아채지 못해서 헤매었다.. 요즘 문제 유형을 한 번에 알아채지 못하는 경우가 너무 많다 내일 코딩테스트인데 큰일
    반드시 색종이를 주어진 도화지의 아래에 딱 붙여야 한다는 조건을 통해 최소(l)과 최대(r)를 초기화 할 수 있었다. 가장 위쪽에 위치한 행의 위치가 l이 되어야 하고, 정사각형 색종이이기 문에 열의 위치는 주어진 행과 열의 크기 중 작은 값이 되어야 한다. 중앙값(m = (l+r)//2)를 현재 색종이의 한 변의 길이로 두고, 가장 왼쪽에 위치한 잘못 칠해진 칸을 기준으로 하여 필요한 색종이의 개수를 센 후, 이 값이 주어진 색종이의 개수보다 클 경우(불가능한 경우), 색종이의 한 변의 길이를 키우기 위해 l을 증가시킨다. 주어진 색종이의 개수보다 작거나 같을 경우(가능할 경우), 색종이의 한 변의 길이를 줄이기 위해 r을 감소시키고 결과값을 m로 갱신한다.
    
## 문제풀이 코드
```python
# 백준 2539. 모자이크
import sys
input = sys.stdin.readline

def mosaic(wrong, mid, K):
    now = wrong[0] # 현재 위치한 칸의 열 정보
    cnt = 1        # 현재 사용한 색종이 개수

    for x in wrong:
        if cnt > K:
            return False
        # 현재위치에서 색종이 끝까지 했을 때 넘어감 -> 새로운 색종이 필요
        if x >= now + mid:
            now = x
            cnt += 1
    if cnt > K:
        return False
    return True

def binary_search(l, r, wrong, K):
    result = 0
    while l <= r:
        m = (l + r) // 2

        if mosaic(wrong, m, K):
            result = m
            r = m - 1
        else:
            l = m + 1
    return result

def solution():
    # N, M : 도화지 위의 행과 열의 개수(1 <= N, M <= 100000)
    N, M = map(int, input().split())
    # K : 사용할 색종이의 장 수(1 <= K <= 100)
    K = int(input())
    # Q : 도화지에 잘못 칠해진 칸의 개수(1 <= Q <= 1000)
    Q = int(input())

    l = 0
    r = 1000000
    # 잘못 칠해진 칸의 열 정보
    wrong = []
    for _ in range(Q):
        i, j = map(int, input().split())
        l = max(l, i)
        wrong.append(j)
    wrong.sort()

    print(binary_search(l, r, wrong, K))

solution()
```