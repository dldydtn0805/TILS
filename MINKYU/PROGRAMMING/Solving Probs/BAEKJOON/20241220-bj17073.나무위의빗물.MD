# 백준 문제 풀이

## bj 17073. 나무 위의 빗물(2024-12-20)

## 문제 설명

트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.

사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.

이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.

물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.

영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느 정도가 될까?

## 입력

첫째 줄에 트리의 노드의 수 N과 1번 노드에 고인 물의 양을 의미하는 정수 W가 주어진다. (2 ≤ N ≤ 500,000, 1 ≤ W ≤ 109)

다음 N-1줄에 걸쳐, 트리에 존재하는 간선의 정보가 U V의 형태로 주어진다. (1 ≤ U, V ≤ N​​​​, U ≠ V)

이는 양 끝 정점이 각각 U와 V인 간선이 트리에 존재한다는 의미이다.

입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.

## 출력

문제의 정답을 출력한다. 정답과의 차이가 10-3 이하인 값은 모두 정답으로 인정된다.

## 문제풀이

처음 문제를 봤을 때, N의 범위가 왜이리 크지?라는 생각과, 뭐 어떻게 풀어야 하는거지? 라는 생각이 들었다. 바로 시간(초)가 문제에 주어졌기 때문이다. 결론적으로, 시간이 상관 없는 문제였다. 어차피 루트 노드(1)에서 모여있던 빗물은 마지막에 각 리프 노드로 분배되기 때문이다. 따라서, 확률과 상관없이 리프 노드의 개수를 구하는 것이 문제의 전부였다. 따라서 bfs(또는 dfs로 풀어도 될 듯)로 접근하여 해결하였다.
다른 사람의 풀이를 보니, 결국 leaf노드는 인접 노드의 개수가 1인 노드이다(본인과 연결된 부모 노드 한 가지만 인접한 노드가 곧 리프 노드임). 따라서, 이를 이용하여 graph[i]의 개수를 파악하여 구하는 방식으로 푼 사람도 있었다. 이 생각을 그동안 왜 못했을까? 사실 리프 노드 개수를 구할 필요가 있는 문제는 많지 않긴 했지만, 한 번도 떠오르지 못했던 아이디어다!

## 문제풀이 코드

```python
# 백준 17073. 나무 위의 빗물
import sys
from collections import deque

def bfs(N, graph):
    que = deque()
    visited = [0] * (N+1)
    leaf = [0] * (N+1)
    que.append(1)
    visited[1] = 1

    while que:
        now = que.popleft()
        flag = 0
        for next in graph[now]:
            if visited[next] == 0:
                flag = 1
                que.append(next)
                visited[next] = 1
        if flag == 0:
            leaf[now] = 1
    return leaf


def solution():
    # N : 트리 노드 개수(2 <= N <= 500000)
    # W : 1번 노드에 고인 물의 양(1 <= W <= 10^9)
    N, W = map(int, input().split())

    graph = [[] for _ in range(N+1)]
    for _ in range(N-1):
        u, v = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)
    leaf = bfs(N, graph)
    cnt = sum(1 for i in range(1, N+1) if leaf[i] == 1)
    print(W/cnt)
    '''
    매 초마다
    1. 물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다.
    - 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
    2. 만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.
    '''
solution()
```
