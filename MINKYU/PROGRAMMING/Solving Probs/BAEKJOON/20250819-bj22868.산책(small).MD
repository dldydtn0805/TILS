# 백준 문제 풀이

## bj 22868. 산책(small) (2025-08-19)

## 문제 유형

1. Breadth First Search

## 문제 설명

코로나로 인하여 확찐자가 되버려 오늘부터 산책을 하려고 한다. 이를 위해 산책할 경로를 정하려고 한다.

현재 있는 곳 S에서 출발하여 S와 다른 곳인 E를 찍고 다시 S로 돌아오는 경로로 만들려고 한다. 산책을 할 때 이미 갔던 정점을 또 가기 싫어 E에서 S로 올 때 S에서 E로 가는 도중에 방문한 정점을 제외한 다른 정점으로 이동하려고 한다. 또한 산책 거리가 긴 것을 싫어하여 S에서 E로 가는 가장 짧은 거리와 E에서 S로 가는 가장 짧은 거리를 원한다.

정점 S에서 정점 E로 이동할 때, 가장 짧은 거리의 경로가 여러개 나올 수 있다. 그 중, 정점 S에서 정점 E로 이동한 경로를 나열했을 때, 사전순으로 가장 먼저 오는 것을 선택한다.

예를 들어, 정점 1에서 정점 2로 이동한다고 했을 때, 가장 짧은 거리의 경로가 1 4 3 2와 1 3 4 2가 있다고 가정을 해보자. 두 개의 경로중 사전순으로 먼저 오는 것은 1 3 4 2이므로 정점 1에서 정점 2로 가는 최단 경로 중 두 번째 것을 선택한다.

이와 같이 산책 경로를 정할 때, 산책 전체 경로의 거리(S에서 E로 가는 거리 + E에서 S로 가는 거리)를 구해보자.

## 입력

첫 번째 줄에는 정점의 개수 N과 두 정점 사이를 잇는 도로의 개수 M이 공백으로 구분되어 주어진다.

두 번째 줄부터 M + 1 번째 줄까지 정점 A, B가 공백으로 구분되어 주어진다. 정점 A와 정점 B 사이의 거리는 항상 1이다. 이때, 정점 A와 정점 B는 양방향으로 이동해도 된다.

정점 A와 정점 B를 잇는 도로는 두개 이상 주어지지 않는다.

M + 2번째 줄에는 정점 S와 정점 E가 공백으로 구분되어 주어진다.

산책을 할 수 있는 경로가 있는 데이터만 주어진다.

## 출력

산책의 전체 경로의 길이를 출력한다.

## 문제풀이

bfs 문제이다. S에서 E로 가는 최소 길이 방법들 중, 경로가 사전순인 경로를 파악한다. 해당 경로에서 방문한 점들(S 제외)를 제외하고, E에서 S로 가는 최소 길이를 더해주어 결과값을 리턴하면 된다.

S에서 E로 갈 때의 bfs와 E에서 S로 갈 때의 bfs를 구분하여 진행하면 된다.

## 문제풀이 코드

```python
# 백준 22868
import sys
from collections import deque

# N : 정점의 개수(1 <= N <= 10000)
# M : 간선의 개수(1 <= M <= 50000)
# graph[i] : i에서 갈 수 있는 정점
# S, E : 시작점과 끝점

def solution(N, M, graph, S, E):
    for i in range(1, N+1):
        graph[i].sort()
    def bfs2(loads):
        visited_nodes = list(map(int, loads.split(' ')))
        que = deque()
        visited = [0] * (N+1)
        for i in visited_nodes:
            visited[i] = 1
        visited[S] = 0
        que.append((E, 0))

        while que:
            now, dist = que.popleft()
            if now == S:
                return dist
            for next in graph[now]:
                if visited[next] == 0:
                    que.append((next, dist+1))
                    visited[next] = 1

    def bfs1():
        que = deque()
        visited = [0] * (N+1)
        que.append((S, 0, str(S)))
        visited[S] = 1
        while que:
            now, dist, string = que.popleft()
            if now == E:
                return dist + bfs2(string)
            for next in graph[now]:
                if visited[next] == 0:
                    que.append((next, dist+1, string + ' ' + str(next)))
                    visited[next] = 1
    return bfs1()

N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
for _ in range(M):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
S, E = map(int, input().split())
print(solution(N, M, graph, S, E))
```

```java


```
