# 백준 문제 풀이

## bj 7938. 내일 할거야(2025-07-10)

## 문제 유형

1. 그리디(Greedy)
2. 최대 힙(Max Heap)
3. 정렬(Sort)

## 문제 설명

아 과제 하기 싫다. 아무 것도 안 하고 싶다. 더 적극적이고 격렬하게 아무 것도 안 하고 싶다.

있잖아. 내가 아까 책상에다가 n개의 과제 목록을 적어놨어. 각각의 과제 i는 di 일이 걸리고, 오늘로부터 ti 일 안에 끝내야 해. 그러니까 오늘이 0일이면, ti일이 끝나기 전에 제출이야. 과제는 한번 시작하면 쉬지 않고 계속해야 해. 안 그러면 머리 아파 지거든.

근데 있잖아. 내가 지금 너무, 너무 아무 것도 안 하고 싶어. 그래서 오늘은 아무 것도 안 할 거야. 더 중요한 게 뭔지 알아? 사실 나 내일도, 모레도, 아무 것도 안 하고 싶어. 한 며칠 동안은 계속 아무 것도 안하려고. 아. 과제가 있을 때 내가 내일부터 연속으로 최대 며칠동안 놀 수 있는지 궁금하다. 궁금하긴 한데, 난 아무 것도 안 하고 싶어.

좋은 생각이 났다. 너희가 이걸 대신 구해주면, 내가 너희의 맞은 문제 수를 하나 올려줄게.

## 입력

첫째 줄에는 과제의 개수인 정수 n (1 ≤ n ≤ 106)이 주어진다.

이후 n개의 줄에 각각의 과제를 나타내는 두 정수 di, ti (1 ≤ di, ti ≤ 109)가 순서대로 주어진다. 오늘은 0일이다.

모든 입력에 대해, 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다.

## 출력

내일(1일)부터 연속으로 최대 며칠 동안 놀 수 있는지를 출력한다. 가령, 답이 0이면, 내일 과제를 해야 하며, 1 이면, 모레에 과제를 해야 한다.

## 문제풀이

정렬과 그리디를 통해 해결할 수 있는 문제이다. 가장 나중까지 끌어도 되는 문제(주어진 t가 큰 문제)를 기준으로 내림차순 정렬 후, 앞에서부터 현재 주어진 숙제 시작 날짜(result)와 마감 날짜(t)의 최소값을 비교 후, 해당 최소값과 숙제를 해결하기 위해 필요한 일 수(d)의 차를 결과값에 저장하면서 갱신한다.

예를 들어,

3

2 8

1 13

3 10이 주어진 경우,

1. 정렬을 진행한다.

- arr = [(1, 13), (3, 10), (2, 8)]

2. arr에 포함된 요소(d, t)를 순차적으로 탐색하며 다음과 같이 진행한다.

- 현재 저장된 최소 시작 날짜(result)와 현재 숙제 마감 날짜(t)를 비교한다
- 두 값의 최소값에 현재 숙제를 끝내기 위해 필요한 날짜(d)를 뺀 값을 최소값으로 갱신한다(result = min(result, t) - d)

그렇게 될 경우, 다음과 같이 진행된다

1. result = int(1e9), d = 1, t = 13

- result = 13 - 1 = 12
- 첫 번째 과제를 완수하기 위해서는 반드시 12일 이후에는 과제를 시작해야 한다

2. result = 12, d = 3, t = 10

- result = 10 - 3 = 7
- 두 번째 과제까지 완수하기 위해서는 반드시 7일 이후에는 과제를 시작해야 한다

3. result = 7, d = 2, t = 8

- result = 7 - 2 = 5
- 세 번째 과제까지 완수하기 위해서는 반드시 5일 이후에는 과제를 시작해야 한다.

즉, 각 과제 별로 걸리는 일, 마감일을 고려하여 0일 이후 쉴 수 있는 최대 일수와 비교하며 갱신하면 되는 문제이다.

정렬과 비슷하게 최대 힙을 통해서도 풀 수 있는 문제이다(-t, d)

## 문제풀이 코드 - 1(정렬)

```python
# 백준 7983
import sys
def solution(N, pq, arr):
    result = int(1e9)
    for d, t in arr:
        result = min(result, t) - d
    return result
N = int(input())
arr = []
for _ in range(N):
    d, t = map(int, input().split())
    arr.append((d, t))
arr.sort(key=lambda x : x[1], reverse=True)
print(solution(N, arr))
```

## 문제풀이 코드 - 2(최대 힙)

```python
# 백준 7983
import sys
import heapq

def solution(N, pq):
    # 숙제를 시작해야 하는 날짜
    result = int(1e9)
    while pq:
        # t : -마감날짜
        # d : 걸리는 시간
        t, d = heapq.heappop(pq)
        result = min(result, -t) - d
    return result
N = int(input())
pq = []
for _ in range(N):
    d, t = map(int, input().split())
    heapq.heappush(pq, (-t, d))
print(solution(N, pq))
```

```java


```
