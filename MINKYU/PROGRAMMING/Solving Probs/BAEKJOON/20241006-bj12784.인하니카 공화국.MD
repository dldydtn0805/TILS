# 백준 문제 풀이
## bj 12784. 인하니카 공화국(2024-10-06)

## 문제 설명
    인하니카 공화국은 1번~ N번까지 N개의 섬으로 이루어진 나라이다. 이 나라에서는 섬 간의 왕래가 매우 어려웠지만, 위대한 다리 설계자 ‘진’이 두 섬을 연결하는 다리를 최소한의 개수로 만들어 모든 섬 간의 왕래가 가능하도록 만들었다. 1번섬에서 살고 있는 진은 어느 날 위험한 소문을 듣게 되었다. 1번섬을 제외한 다리가 하나밖에 없는 어느 섬에서 유명한 연쇄 살인마 괴도‘루팡’이 자신의 목숨을 노리고 있다는 소문이었다. 너무 불안한 나머지 진은 몇 개의 다리를 폭파하여, 루팡이 있을 가능성이 있는 모든 섬에서 자신의 섬으로의 모든 경로를 차단하려고 한다. 하지만 각 다리를 폭파하려면 다리의 크기에 따라 다이너마이트의 개수가 다르다. 다이너마이트는 매우 비싸기 때문에 진은 사용하는 다이너마이트의 개수를 최소화하고 싶어 한다. 각 섬을 연결하는 다리를 폭파하기 위한 다이너마이트의 개수가 주어졌을 때, 진을 도와 필요한 최소 다이너마이트의 개수를 구하라.

![alt text](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/12784/1.png)

    예를 들어, 위의 그림과 같이 섬과 다리를 폭파하기 위한 다이너마이트의 수가 주어졌을 때, 빨간색 다리를 폭파하면 다이너마이트의 개수를 최소화하면서 루팡으로부터 안전할 수 있다.

## 입력
    입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 100)가 주어진다.
    각 테스트 케이스의 첫 번째 줄에는 섬의 수 N(1 ≤ N ≤ 1,000)과 다리의 수 M이 주어진다.
    다음으로 M개의 줄에는 각 다리를 통해 이어진 두 섬의 번호와 다리를 파괴하기 위한 다이너마이트의 수 D(1 ≤ D ≤ 20)가 주어진다.

## 출력
    각 테스트 케이스마다 필요한 최소 다이너마이트의 개수를 출력한다.

## 문제풀이
    dfs를 활용하여 부모 노드에 저장된 값과 자식 노드들에 저장된 값의 합을 비교하며 최소 값만 저장하는 방식이었다. 요즘 bfs에 비해 dfs를 활용한 그래프 순회 방법을 통해 문제를 푸는 것에 많이 어려움을 느끼고 있다. dfs 관련 문제를 열심히 풀어야 겠다..
    
## 문제풀이 코드
```python
# 백준 12784. 인하니카 공화국
import sys
input = sys.stdin.readline

def dfs(node):
    # 현재 노드 방문
    visited[node] = 1

    # 리프 노드인 경우
    if leaves[node] == 1:
        return int(1e9)

    # 필요한 다이너마이트 수
    d = 0
    for next, cost in graph[node]:
        if visited[next] == 0:
            d += min(cost, dfs(next))

    return d

T = int(input().rstrip())
for tc in range(T):
    # N : 섬의 수(1 <= N <= 1000)
    # M : 다리의 수
    N, M = map(int, input().rstrip().split())
    graph = [[] for _ in range(N+1)]
    for _ in range(M):
        # a와 b는 다리로 이어져 있다
        # a와 b를 잇는 다리를 파괴하기 위해 다이너마이트 d개가 필요하다
        a, b, d = map(int, input().rstrip().split())
        graph[a].append((b, d))
        graph[b].append((a, d))
    visited = [0] * (N+1)
    leaves = [0] * (N+1)

    for i in range(2, N+1):
        if len(graph[i]) == 1:
            leaves[i] = 1
    # print(leaves)
    '''
    3                                   6
       (4)                         (1)
            2   (1)   1   (4)   5    
       (1)                         (2)
    4                                   7
    
    node와 연결된 자식 노드들로 가는 길을 파괴할 것인가
    그 자식 노드들의 자식 노드들로 가는 길을 파괴할 것인가
    
    1(1 -> 2) vs 4(2 -> 3) + 1(2 -> 4) 
    4(1 -> 5) vs 1(5 -> 6) + 2(5 -> 7)
    '''
    print(dfs(1))
```