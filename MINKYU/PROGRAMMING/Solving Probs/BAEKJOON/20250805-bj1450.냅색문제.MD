# 백준 문제 풀이

## bj 1450. 냅색문제(2025-08-05)

## 문제 유형

1. Dynamic Programming(DP)
2. Knapsack Problem
3. Binary Search
4. Meeting in the Middle

## 문제 설명

세준이는 N개의 물건을 가지고 있고, 최대 C만큼의 무게를 넣을 수 있는 가방을 하나 가지고 있다.

N개의 물건을 가방에 넣는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 C가 주어진다. N은 30보다 작거나 같은 자연수, C는 109보다 작거나 같은 음이 아닌 정수이다. 둘째 줄에 물건의 무게가 주어진다. 무게도 109보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 가방에 넣는 방법의 수를 출력한다.

## 문제풀이

Knapsack 문제이다. 하지만, 주어진 최대값이 10\*\*9라서 상당히 효율적인 방법으로 풀어야 한다. 처음 생각한게 이분 탐색이긴 했지만, '중간에서 만나기'라는 새로운 알고리즘이 필요했다.

중간에서 만나기(Meet in the Middle)은 완전 탐색의 시간 복잡도를 줄이기 위해 탐색 범위를 둘로 나눈 후, 각 부분에 대해 탐색을 수행하여 결과를 결합하는 것이다. 부분집합, 순열 등에서 활용된다.

이를 활용하기 위해 주어진 배열을 절반으로 나누고, 이분 탐색을 활용할 배열은 조합을 통해 만든 합들을 모아놓은 정렬된 배열로, 숫자만 활용할 배열은 (합 -> 개수)를 key - value로 하는 defaultdict로 만들었다.

defaultdict의 key에 들어간 각 숫자(뒤의 N//2개의 숫자들로 만들 수 있는 조합에 대한 원소합들로 이루어진 값들)에 대해, 앞의 정렬된 배열에 대한 값들을 이분탐색을 활용하여 합쳤을 때 C와 가장 가까운 C보다 작거나 같은 값들의 인덱스를 찾게 될 경우, 해당 인덱스 이하에 해당하는 경우는 다 가능하다. 따라서, 인덱스 + 1을 리턴해주면 된다.

리턴 받은 개수(index + 1)에 해당 값의 개수(key -> value)를 곱한 값을 결과값에 더해주면서 리턴해주면 답을 얻을 수 있다.

중요한게, 이분 탐색 과정에서 뽑은 m에 대해

- m번 인덱스에 해당하는 값(subset[m])과 현재 순차적으로 순회한 값(n)의 합이 C가 되었다고 해서 바로 해당 인덱스+1(m+1)을 리턴해서는 안된다.
- 결국 subset은 모든 조합에 대한 원소의 합을 원소로 가지는 배열이기 때문에, 해당 m번 인덱스에 해당하는 값이 중복될 수 있다(subset[m] = subset[m+1] = ...) 따라서, 중간에 만났다고 return을 하는 것이 아닌, 끝까지 이분탐색을 진행하며 마지막 end값이 최대 인덱스가 됨을 인지해야 한다.

완전 탐색이 너무 클 경우(ex. 조합, 순열 등) 이를 둘로 나누어 결합하는 방식을 활용하는 MitM을 잘 알고 있어야 겠따....

## 문제풀이 코드

```python
# 백준 1450
import sys
from itertools import combinations
from collections import defaultdict

# N : 물건의 개수(1 <= N <= 30)
# C : 가방에 담을 수 있는 최대 무게(0 <= C <= 10**9)
# arr[i] : i번 물건의 개수(1 <= arr[i] <= 10**9)
def solution(N, C, arr):
    if C == 0:
        return 1

    arr.sort()
    # 반 가르기
    num_1 = arr[:N//2]
    num_2 = arr[N//2:]
    # 주어진 배열의 원소들 조합으로 만들 수 있는 조합의 합 배열
    def get_subset(arr):
        subset = []
        # subset = []
        for i in range(len(arr) + 1):
            # 배열의 원소들 중 i개의 조합으로 만들 수 있는 것들
            combi = combinations(arr, i)
            for c in combi:
                sum_v = 0
                for n in c:
                    sum_v += n
                # subset[sum_v] += 1
                subset.append(sum_v)
        return subset

    # 0 ~ (N//2-1) 사이의 원소들로 만들 수 있는 조합 합 배열
    subset_1 = get_subset(num_1)
    # N//2 ~ N-1 사이의 원소들로 만들 수 있는 조합 합 배열
    subset_2 = get_subset(num_2)
    # print(subset_1)
    # print(subset_2)

    # 주어진 숫자와 합쳤을 때 C와 가깝게 만들 수 있는 경우의 수
    def binary_search(subset, num):
        l = 0
        r = len(subset) - 1

        while l <= r:
            m = (l+r)//2
            # C를 넘어갈 경우 최대값 줄이기
            if subset[m] + num > C:
                r = m-1
            # C와 가까울 경우 최소값 늘리기
            else:
                l = m+1
        return r + 1
    result = 0
    for n in subset_2:
        result += binary_search(subset_1, n)
    return result


N, C = map(int, input().split())
arr = list(map(int, input().split()))
print(solution(N, C, arr))
```

```java


```
